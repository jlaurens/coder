% \iffalse meta-comment
% !TEX program  = lualatex
% !TEX encoding  = utf8
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
inlinecode --- description text
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

Some text about the package: probably the same as the abstract.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
inlinecode --- code inlined in a LaTeX document.
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2022 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  inlinecode.dtx
and the derived files           inlinecode.ins,
                                inlinecode.pdf and
                                inlinecode.sty.

\endpostamble
\usedir{tex/latex/inlinecode}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/inlinecode}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/inlinecode}
\generate{
  \file{README.md}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*package>
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{needspace, xcolor, verbatim}
\ProvidesExplPackage{inlinecode}
  {2022/01/21}
  {1.0a}
  {code inlined in documents}
%</package>
%<*driver>
\ExplSyntaxOff
\documentclass{l3doc}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\AddToHook{env/variable/after}{\vspace{0.5\baselineskip}}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%\GetFileInfo{\jobname.sty}
%
%\title{^^A
%  \textsf{inlinecode} --- code inlined in a \LaTeX\ document\thanks{^^A
%    This file describes version \fileversion, last revised \filedate.^^A
%  }^^A
%}
%\author{^^A
%  Jérôme LAURENS\thanks{E-mail: jerome.laurens@u-bourgogne.fr}^^A
%}
%\date{Released \filedate}
%
%\maketitle
%
% \begin{documentation}
%
%\changes{v1.0a}{2022/01/20}{First public release}
%
% \section{Basic example}
% \begin{verbatim}
%   \documentclass{article}
%   \RequirePackage{inlinecode}
%   \InlineCodeNew{file=Readme.txt, chunks=txt}
%   \begin{document}
%   \begin{InlineCode}{chunks=txt}
%   This is a readme text file
%   \end{InlineCode}
%   \end{document}
% \end{verbatim}
% Typesetting this document creates a |readme.txt| file
% which content reads \texttt{This is a readme text file}.
%
% \section{Initialize}
% To load the package
% |\RequirePackage{inlinecode}|.
%
% \begin{function}{\InlineCodeSetup}
% \begin{syntax}
% \cs{InlineCodeSetup} \marg{key[=value] list}
% \end{syntax}
% To set up the package.
% Must be used only once.
% The \texttt{\meta{key}[=\meta{value}]} items are:
% \end{function}
% \begin{description}
% \item[\ttfamily minted] to activate syntax coloring with pygment,
% \item[\ttfamily minted style=\meta{name}]
% to select a predefined minted style,
% \item[\ttfamily sty=\meta{package name}]
% to load a package, possibly the created package,
% \item[\ttfamily only top] to avoid chunk names repetitions,
% \item[\ttfamily only description] to typeset only the description.
% \end{description}
%
% \section{Files}
% \begin{function}{\InlineCodeNew}
% \begin{syntax}
% \cs{InlineCodeNew}\marg{key[=value] list}
% \end{syntax}
% The \texttt{\meta{key}[=\meta{value}]} items are:
% \end{function}
% \begin{description}
% \item[\ttfamily file=\meta{file name}] is mandatory, the file named \meta{file name} will be created,
% \item[\ttfamily chuncks=\meta{comma separated  list of chunk names}] to list the chunks inserted as file contents, ordered and mandatory, 
% \item[\ttfamily lang] to specify the language, defaults to \texttt{latex},
% \item[\ttfamily raw] to remove any additional material,
% \item[\ttfamily preamble] the added preamble.
% \end{description}
%
% \begin{function}{\InlineCodeStorePreamble}
% \begin{syntax}
% \cs{InlineCodeStorePreamble} \marg{variable} \marg{file name}
% \end{syntax}
% Store the content of \meta{file name} into the variable \meta{variable}.
% \end{function}
%%
% \section{Code chunks}
% The chunk name are displayed in the margin, uness \texttt{only top} was specified and not at the top and continue.
% \begin{variable}{\g_NLNCD_chunks_tl}
% The comma separated list of current chunks.
% \end{variable}
%    \begin{macrocode}
\tl_new:N \g_NLNCD_chunks_tl
%    \end{macrocode}
% \begin{environment}{InlineCode}
% \begin{syntax}
% \cs{begin}\Arg{InlineCode}\oarg{key[=value] list} ... \cs{end}\Arg{InlineCode}
% \end{syntax}
% \noindent The \texttt{\meta{key}[=\meta{value}]} items are:
% \end{environment}
% \begin{description}
% \item[\ttfamily chunks=\meta{comma separated list of chunk names}] defines the list of all the chunks where the environment body is append, required,
% \item[\ttfamily no display] to not display he chunk names
% \end{description}
%
%\StopEventually{^^A
%  \PrintChanges
%  \PrintIndex
%}
%
% \section{Separators}
% \begin{function}{\InlineCodeImplementation}
% \begin{syntax}
% \cs{InlineCodeImplementation}
% \end{syntax}
% Start an implementation part where all the sectioning commands do nothing.
% \end{function}
% \begin{function}{\InlineCodeFinale}
% \begin{syntax}
% \cs{InlineCodeFinale}
% \end{syntax}
% Stop an implementation part.
% \end{function}

% \end{documentation}
%
% \begin{implementation}
%
% \section{\pkg{inlinecode} implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
% \subsection{All purpose messaging}
%    \begin{macrocode}
\msg_new:nnn { inlinecode } { :n } { #1 }
%    \end{macrocode}
% \subsection{minted related variables and conditionals}
% Whether minted is available:
%    \begin{macrocode}
\bool_new:N \g_NLNCD_can_minted_bool
\bool_gset_false:N \g_NLNCD_can_minted_bool
%    \end{macrocode}
% Whether minted is used and an associate conditional:
%    \begin{macrocode}
\bool_new:N \g_NLNCD_use_minted_bool
\bool_gset_false:N \g_NLNCD_use_minted_bool
%    \end{macrocode}
% \begin{function}[TF]
%   {\_NLNCD_if_use_minted:}
%   \begin{syntax}
%     \cs{_NLNCD_if_use_minted:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when using |minted|, \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \_NLNCD_if_use_minted: { T, F, TF } {
  \bool_if:NTF \g_NLNCD_use_minted_bool
    { \prg_return_true:  }
    { \prg_return_false: }
}
%    \end{macrocode}
% \end{function}
%
% Conditional for \texttt{pygmentize} availability:
%    \begin{macrocode}
\prg_new_conditional:Nnn\_NLNCD_if_pygmentize: { T, F, TF } {
  \group_begin:
  \sys_get_shell:nnN {which~pygmentize} {} \l_tmpa_tl
  \tl_if_empty:NTF \l_tmpa_tl {
    \tl_set:Nn \l_tmpa_tl { \prg_return_false: }
  } {
    \tl_set:Nn \l_tmpa_tl { \prg_return_true: }
  }
  \exp_last_unbraced:NV \group_end: \l_tmpa_tl
}

%    \end{macrocode}
% |pygment| processing
%    \begin{macrocode}
\tl_new:N \g_NLNCD_post_processor_tl
\tl_new:N \g_NLNCD_post_processor_args_tl
  
\makeatletter
%    \end{macrocode}
% \subsection{\cs{InlineCodeSetup}}
% \begin{variable}{\g_NLNCD_only_top_bool}
% Whether chunk names should only display at the top.
% \end{variable}
%    \begin{macrocode}
\bool_new:N \g_NLNCD_only_top_bool
\bool_gset_false:N \g_NLNCD_only_top_bool
%    \end{macrocode}
% \begin{variable}{\g_NLNCD_with_impl_bool}
% 
% \end{variable}
%    \begin{macrocode}
\bool_new:N \g_NLNCD_with_impl_bool
\bool_gset_true:N \g_NLNCD_with_impl_bool
%    \end{macrocode}
% \texttt{NLNCDSetup} keys definitions used to parse \cs{InlineCodeSetup} unique argument.
%    \begin{macrocode}
\keys_define:nn { NLNCDSetup } {
  sty .tl_set_x:N = \l_tmpa_str,
  sty .default:V = \c_sys_jobname_str,
  sty .initial:n = ,
  minted~style .code:n = {
    \RemoveFromHook { begindocument/before } [NLNCDMinted]
    \AddToHook { begindocument/before } [NLNCDMinted] {
      \usemintedstyle { #1 }
    }
  },
  minted .code:n = \_NLNCD_minted_setup:n { #1 },
  post~processor .tl_set_x:N = \g_NLNCD_post_processor_tl,
  post~processor~args .tl_set_x:N = \g_NLNCD_post_processor_args_tl,
  font .tl_set:N = \g_NLNCD_font_tl,
  font .initial:n = \ttfamily,
  only~top .bool_gset:N = \g_NLNCD_only_top_bool,
  only~top .initial:n = false,  
  only~top .code:n = {
    \bool_gset_true:N \g_NLNCD_only_top_bool
  },
  only~description .bool_gset_inverse:N = \g_NLNCD_with_impl_bool,
  only~description .initial:n = false,  
  only~description .code:n = {
    \bool_gset_false:N \g_NLNCD_with_impl_bool
  },
  unknown .code:n = \PackageWarning
    { inlinecode }
    { Unknown~option~`\l_keys_key_str' },
}

%    \end{macrocode}
% Main command
%    \begin{macrocode}
\NewDocumentCommand \InlineCodeSetup { m } {
  \str_clear:N \l_tmpa_str
  \keys_set:nn { NLNCDSetup } {#1}
  \str_if_empty:NF \l_tmpa_str {
    \file_if_exist:nT { \l_tmpa_str.sty } {
      \RequirePackage{ \l_tmpa_str }
    }
  }
  \bool_if:NF \g_NLNCD_use_minted_bool {
    \bool_if:NT \g_NLNCD_can_minted_bool {
      \sys_if_shell:TF {
        \_NLNCD_if_pygmentize:TF {
          \bool_gset_true:N \g_NLNCD_use_minted_bool
          \RequirePackage{minted}
          \renewcommand { \theFancyVerbLine } {
            \scriptsize \g_NLNCD_font_tl
            \textcolor { lightgray } {
              \arabic { FancyVerbLine }
            }
          }
        } {
          \msg_warning:nnn
            { inlinecode }
            { :n }
            { No~"pygmentize"~found. }
        }
      } {
        \msg_warning:nnn
          { inlinecode }
          { :n }
          { No~unrestricted~shell~escape~for~"pygmentize".}
      }
    }
  }
}
%    \end{macrocode}
% Utilities to setup |pygment| post processing.
% The |pygment| post processor marks some code with \cs{InlineCodeEmph}.
%    \begin{macrocode}
\providecommand{\InlineCodeEmph}[1]{\textcolor{red}{#1}}
\cs_set:Npn \_NLNCD_minted_setup:n #1 {
  \bool_gset_true:N \g_NLNCD_can_minted_bool
  \RequirePackage{minted}
  \setkeys { minted@opt@g } { #1 }
  \minted@def@opt{post~processor}
  \minted@def@opt{post~processor~args}
  \pretocmd\minted@inputpyg{%
    \NLNCD@postprocesspyg
      {\minted@outputdir\minted@infile}%
  }{}{\fail}
%    \end{macrocode}
% In the execution context of \cs{minted@inputpyg},
% \begin{description}
% \item[\texttt{\#1}] is the name of the python script, e.g., ``\texttt{process.py}''
% \item[\texttt{\#2}] is the input ``.pygtex'' file ``\cs{minted@outputdir}\cs{minted@infile}''
% \item[\texttt{\#3}] are more args passed to the python script, possibly empty
% \end{description}
%    \begin{macrocode}
  \newcommand{\NLNCD@postprocesspyg}[1]{%
    \tl_if_empty:NTF \g_NLNCD_post_processor_tl {
      DEBUG:~NO~POST~PROCESSING
    } {
%    \end{macrocode}
% Execute \texttt{`python3 <script.py> <file.pygtex> <more_args>`}
%    \begin{macrocode}
       \exp_args:Nx
       \sys_shell_now:n {
         python3\space
         \g_NLNCD_post_processor_tl\space
         ##1\space
         \g_NLNCD_post_processor_args_tl
       }  
    }
  }
}
\InlineCodeSetup {}
%    \end{macrocode}
% \begin{variable}{\l_NLNCD_in}
% Input file identifier
% \end{variable}
%    \begin{macrocode}
\ior_new:N \l_NLNCD_in
%    \end{macrocode}
% \begin{variable}{\l_NLNCD_out}
% Output file identifier
% \end{variable}
%    \begin{macrocode}
\iow_new:N \l_NLNCD_out
%    \end{macrocode}
% \begin{variable}{\g_NLNCD_file_prop}
% Global property list of \texttt{\meta{file name}=\meta{comma separated list of chunk names}} items.
% \end{variable}
%    \begin{macrocode}
\prop_new:N \g_NLNCD_file_prop
%    \end{macrocode}
% \begin{variable}{\g_NLNCD_preamble_prop}
%   Global property list of \texttt{\meta{file name}=\meta{preamble}} items.
% \end{variable}
%    \begin{macrocode}
\prop_new:N \g_NLNCD_preamble_prop
%    \end{macrocode}
% \begin{variable}{\g_NLNCD_banner_prop}
%   Global property list of \texttt{\meta{file name}=\meta{banner}} items.
% \end{variable}
%    \begin{macrocode}
\prop_new:N \g_NLNCD_banner_prop
%    \end{macrocode}
% \begin{variable}{\g_NLNCD_raw_prop}
% Global property list of \texttt{\meta{file name}=\meta{boolean value}}
% items indicating whether the given file should not contain
% extra material like banners.
%    \begin{macrocode}
\prop_new:N \g_NLNCD_raw_prop
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLNCD_lang_prop}
% Global property list of \texttt{\meta{chunk name}=\meta{language}} items.
%    \begin{macrocode}
\prop_new:N \g_NLNCD_lang_prop
%    \end{macrocode}
% \end{variable}
% |\l_tmpa_bool| to store the value for \texttt{raw}, 
%    \begin{macrocode}
\keys_define:nn { NLNCDNew } {
  file .tl_set_x:N = \g_tmpa_tl,
  file .value_required:n = true,
  chunks .clist_set:N = \g_tmpa_clist,
  chunks .value_required:n = true,
  lang .code:n = {
    \str_set:Nn \g_tmpa_str { #1 }
  },
  lang .value_required:n = true,
  preamble .default:n = ,
  preamble .code:n = {
    \exp_args:NNx \str_set:Nn \l_tmpa_str { #1 }
  },
  raw .bool_set:N = \l_tmpa_bool,
  raw .code:n = {
    \bool_set_true:N \l_tmpa_bool
  },
}
%    \end{macrocode}
% Now the main command.
% It loads lately \pkg{datetime2}.
%    \begin{macrocode}
\DeclareDocumentCommand \InlineCodeNew { m } {
  \RequirePackage{datetime2}
  \group_begin:
  \clist_clear:N \g_tmpa_clist
  \str_clear:N \l_tmpa_str
  \bool_set_false:N \l_tmpa_bool
  \str_set:Nn \g_tmpa_str { latex }
  \exp_args:Nnx \keys_set:nn { NLNCDNew } { #1 }  
  \exp_args:NNV \prop_if_in:NnT \g_NLNCD_file_prop \g_tmpa_tl {
    \msg_critical:nnx
      { inlinecode }
      { :n }
      { Duplicate~file "\g_tmpa_tl'' }
  }
  \prop_gput:NVx \g_NLNCD_file_prop \g_tmpa_tl
    { \clist_use:Nn \g_tmpa_clist , }
  \prop_gput:NVV \g_NLNCD_preamble_prop \g_tmpa_tl \l_tmpa_str
  \str_set:Nx \l_tmpa_str { \str_head:N \g_tmpb_tl }
  \str_if_empty:NT \l_tmpa_str {
    \str_set_eq:NN \l_tmpa_str \c_percent_str
  }
  \tl_set:Nx \l_tmpb_tl {
    \l_tmpa_str\l_tmpa_str\space\space
    This~is~file~`\g_tmpa_tl'~
    generated~from~`\c_sys_jobname_str.tex'~on~\DTMnow.
  }
  \prop_gput:NVV \g_NLNCD_banner_prop \g_tmpa_tl \l_tmpb_tl
  \clist_map_inline:Nn \g_tmpa_clist {
    \prop_gput:NnV \g_NLNCD_lang_prop { ##1 } \g_tmpa_str
  }
  \group_end:
}
\AddToHook { begindocument / end } {
  \RenewDocumentCommand \InlineCodeNew { m } {
    \msg_fatal:nn { :n } { Only~in~preamble:~\cs{InlineCodeNew} }
  }
}
%    \end{macrocode}
% \begin{variable}{\g_NLNCD_chunks_prop}
%   Global property list of \texttt{\meta{chunk name}=\meta{chunk content}} items.
%    \begin{macrocode}
\prop_new:N \g_NLNCD_chunks_prop
%    \end{macrocode}
% \end{variable}
% Files are created at the end of the process.
%    \begin{macrocode}
\AddToHook { enddocument / end } {
  \group_begin:
  \prop_map_inline:Nn \g_NLNCD_file_prop {
    \iow_open:Nn \l_NLNCD_out {#1}
    \iow_term:x {Exporting~chunks~#2~to~#1}
    \bool_set_false:N \l_tmpa_bool
    \prop_get:NnNT \g_NLNCD_raw_prop { #1 } \l_tmpa_tl {
      \bool_set:Nn \l_tmpa_bool { \l_tmpa_tl }
    }
    \bool_if:NF \l_tmpa_bool {
      \prop_get:NnNT \g_NLNCD_banner_prop { #1 } \l_tmpa_tl {
        \iow_now:Nx \l_NLNCD_out { \l_tmpa_tl }
      }
      \prop_get:NnNT \g_NLNCD_preamble_prop { #1 } \l_tmpa_tl {
        \iow_now:Nx \l_NLNCD_out { \l_tmpa_tl }
      }
    }
    \clist_map_inline:nn { #2 } {
      \prop_get:NnN \g_NLNCD_chunks_prop { ##1 } \l_tmpa_tl
      \exp_args:NNV \iow_now:Nn \l_NLNCD_out \l_tmpa_tl
    }
    \iow_close:N \l_NLNCD_out
  }
  \group_end:
}
%    \end{macrocode}
% \begin{variable}{\g_NLNCD_in_impl_bool}
% Whether we are currently in the implementation section.
%    \begin{macrocode}
\bool_new:N \g_NLNCD_in_impl_bool
\bool_gset_false:N \g_NLNCD_in_impl_bool
%    \end{macrocode}
% \end{variable}
% \begin{function}[TF]
%   {\_NLNCD_if_print_code:}
%   \begin{syntax}
%     \cs{\_NLNCD_if_print_code:T} \Arg{true code}
%   \end{syntax}
%   Execute code only when required.
%    \begin{macrocode}
\prg_new_conditional:Nnn \_NLNCD_if_print_code: { T, F, TF } {
  \bool_if:nTF {
    \g_NLNCD_in_impl_bool &&
    !\g_NLNCD_with_impl_bool
  } {
    \prg_return_false:
  } {
    \prg_return_true:
  }
}
%    \end{macrocode}
% \end{function}
% Key value definitions. |\l_tmpa_bool| for \texttt{no display}.
%    \begin{macrocode}
\keys_define:nn { NLNCDCode } {
  chunks .clist_set:N = \g_tmpa_clist,
  chunks .value_required:n = true,
  lang .code:n = {
    \str_set:Nn \g_tmpa_str { #1 }
  },
  no~display .bool_set:N = \l_tmpa_bool,
  no~display .code:n = {
    \bool_set_true:N \l_tmpa_bool
  },
  unknown .code:n = \PackageWarning
    { inlinecode }
    { Unknown~option~`\l_keys_key_str' },
}
\DeclareDocumentEnvironment { InlineCode } { m } {
  \bool_set_false:N \l_tmpa_bool
  \str_clear:N \g_tmpa_str
  \exp_args:Nnx \keys_set:nn { NLNCDCode } { #1 }
  \_NLNCD_if_print_code:T {
    \vspace { -\baselineskip }
    \vspace { 0.25\baselineskip }
    \par\noindent
    \_NLNCD_if_use_minted:T {
      \vspace*{ -\baselineskip }
    }
    \cs_set:Npn \NLNCD_line_number: {
      \makebox [0mm] [r] {
        \g_NLNCD_font_tl \scriptsize
        \textcolor { lightgray } {
          \arabic { FancyVerbLine }
        }
        \hspace {1.5ex}
      }
    }
  }
  \NLNCD_verbatim
} {
  \endNLNCD_verbatim
  \_NLNCD_if_print_code:T {
    \vspace{ .2\baselineskip }
    \par\noindent
  }
}
\newenvironment {NLNCD_verbatim} {%
  \clist_map_inline:Nn \g_tmpa_clist {
    \prop_if_in:NnF \g_NLNCD_chunks_prop { ##1 } {
      \int_zero_new:c { NLNCD@lineno@ ##1 }    
    }
    \int_compare:nNnT { \int_use:c {NLNCD@lineno@##1} }=\c_zero_int {
      \int_gincr:c { NLNCD@lineno@##1 }
    }
  }
  \_NLNCD_if_print_code:T {
    \group_begin:
    \tl_set:Nx \l_tmpa_tl { \clist_use:Nn \g_tmpa_clist , }
    \bool_if:NF \l_tmpa_bool {
      \bool_if:NTF \g_NLNCD_only_top_bool {
        \tl_if_eq:NNF \l_tmpa_tl \g_NLNCD_chunks_tl {
          \makebox [0mm] [r] {
            \g_NLNCD_font_tl
            \scriptsize
            \color{gray}
            \tl_use:N \l_tmpa_tl :
            \hspace{6ex}
          }
        }
      } {
        \makebox [0mm] [r] {
          \g_NLNCD_font_tl
          \scriptsize
          \color{gray}
          \tl_use:N \l_tmpa_tl :
          \hspace{6ex}
        }
      }
    }
    \tl_gset_eq:NN \g_NLNCD_chunks_tl \l_tmpa_tl
    \group_end:
    \_NLNCD_if_use_minted:TF {
      \setkeys{ minted@opt@g } { linenos }
      \setkeys { FV } {
        firstnumber=last,
      }
      \clist_map_inline:Nn \g_tmpa_clist {
        \exp_args:Nnx \setkeys { FV } {
          firstnumber=\int_use:c { NLNCD@lineno@##1 },
        }
        \clist_map_break:
      }
      \iow_open:Nn \minted@code { \jobname.pyg }
      \Needspace* { 2\baselineskip }
    } {
      \@bsphack
    }
  }
  \def \verbatim@processline {
    \clist_map_inline:Nn \g_tmpa_clist {
      \prop_get:NnNTF \g_NLNCD_chunks_prop { ####1 } \l_tmpa_tl {
        \tl_put_right:Nx \l_tmpa_tl { \the\verbatim@line \iow_newline: }
        \exp_args:NNnV
        \prop_gput:Nnn \g_NLNCD_chunks_prop { ####1 } \l_tmpa_tl
      } {
        \exp_args:NNnx
        \prop_gput:Nnn \g_NLNCD_chunks_prop { ####1 }
          { \the\verbatim@line \iow_newline: }
      }
    }
    \_NLNCD_if_print_code:T {
      \_NLNCD_if_use_minted:TF {
        \iow_now:Nx \minted@code { \the\verbatim@line }
      } {
        \noindent\leavevmode
        \hspace*{-5ex}
        \begin{minipage}[c][1ex]{\textwidth}
          \makebox[4ex]{%
            \leavevmode
            \sffamily\tiny\color{lightgray}\hfill%
            \clist_map_inline:Nn \g_tmpa_clist {
              \int_use:c { NLNCD@lineno@####1 }
            }
          }
          \hspace* { 1ex }
          {
            \g_NLNCD_font_tl
            \the\verbatim@line
          }
        \end{minipage}
        \par
      }
    }
    \clist_map_inline:Nn \g_tmpa_clist {
      \int_gincr:c { NLNCD@lineno@####1 }
    }
  }
  \group_begin:
  \let \do \@makeother
  \dospecials \catcode `\^^M \active
  \_NLNCD_if_print_code:T {
    \_NLNCD_if_use_minted:F {
      \frenchspacing\@vobeyspaces
    }
  }
  \verbatim@start
} {
  \group_end:
  \str_if_empty:NT \g_tmpa_str {
    \clist_map_inline:Nn \g_tmpa_clist {
      \prop_get:NnNT \g_NLNCD_lang_prop { ##1 } \g_tmpa_str {
        \str_if_empty:NF \g_tmpa_str {
          \clist_map_break:
        }
      }
    }
  }
  \str_if_empty:NT \g_tmpa_str {
    \str_set:Nn \g_tmpa_str { latex }
  }
  \clist_map_inline:Nn \g_tmpa_clist {
    \prop_gput:NnV \g_NLNCD_lang_prop { ##1 } \g_tmpa_str
  }
  \_NLNCD_if_print_code:T {
    \_NLNCD_if_use_minted:TF {
      \iow_close:N \minted@code
      \vspace* { \dimexpr -\topsep-\partopsep-\parskip }
      \exp_args:NV \minted@pygmentize \g_tmpa_str
      \DeleteFile { \jobname.pyg }
      \vspace* { \dimexpr -\topsep -\partopsep }
    } {
      \@esphack
    }
  }
}
\DeclareDocumentCommand \InlineCodeStorePreamble { m m } {
  \group_begin:
  \msg_info:nnn
    { inlinecode }
    { :n }
    { Reading~preamble~from~file~"#2". }
  \tl_clear:N \g_tmpa_tl
  \tl_clear:N \g_tmpb_tl
  \ior_open:Nn \l_NLNCD_in { #2 }
  \bool_until_do:nn { \ior_if_eof_p:N \l_NLNCD_in } {
    \ior_str_get:NN \l_NLNCD_in \l_tmpa_tl
    \tl_if_empty:NTF \l_tmpa_tl {
      \tl_put_right:Nn \g_tmpb_tl { \iow_newline: }
    } {
      \tl_put_right:Nx \g_tmpa_tl { \g_tmpb_tl }
      \tl_set:Nn \g_tmpb_tl { \iow_newline: }
      \tl_put_right:NV \g_tmpa_tl \l_tmpa_tl
    }
  }
  \ior_close:N \l_NLNCD_in
  \exp_args:NNNx
  \group_end:
  \tl_set:Nn #1 { \tl_to_str:N \g_tmpa_tl }
}
\newcounter{NLNCD@impl@page}
\DeclareDocumentCommand \InlineCodeImplementation {} {
  \bool_if:NF \g_NLNCD_with_impl_bool {
    \clearpage
    \bool_gset_true:N \g_NLNCD_in_impl_bool
    \let\NLNCD@old@part\part
    \DeclareDocumentCommand\part{som}{}
    \let\NLNCD@old@section\section
    \DeclareDocumentCommand\section{som}{}
    \let\NLNCD@old@subsection\subsection
    \DeclareDocumentCommand\subsection{som}{}
    \let\NLNCD@old@subsubsection\subsubsection
    \DeclareDocumentCommand\subsubsection{som}{}
    \let\NLNCD@old@paragraph\paragraph
    \DeclareDocumentCommand\paragraph{som}{}
    \let\NLNCD@old@subparagraph\subparagraph
    \DeclareDocumentCommand\subparagraph{som}{}
    \cs_if_exist:NT \refsection{ \refsection }
    \setcounter{ NLNCD@impl@page }{ \value{page} }
  }
}
\DeclareDocumentCommand\InlineCodeFinale {} {
  \bool_if:NF \g_NLNCD_with_impl_bool {
    \clearpage
    \bool_gset_false:N \g_NLNCD_in_impl_bool
    \let\part\NLNCD@old@part
    \let\section\NLNCD@old@section
    \let\subsection\NLNCD@old@subsection
    \let\subsubsection\NLNCD@old@subsubsection
    \let\paragraph\NLNCD@old@paragraph
    \let\subparagraph\NLNCD@old@subparagraph
    \setcounter { page } { \value{ NLNCD@impl@page } }
  }
}
\cs_set_eq:NN \NLNCD_line_number: \prg_do_nothing:
\AddToHook { cmd/FancyVerbFormatLine/before } {
  \NLNCD_line_number:
}
\AddToHook { shipout/before } {
  \tl_gclear:N \g_NLNCD_chunks_tl
}
%</package>
%    \end{macrocode}
% \end{implementation}
%\Finale
%
% % ^^A \PrintIndex
