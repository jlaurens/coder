% \iffalse meta-comment
% !TEX program  = lualatex
% !TEX encoding  = utf8
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
inlinecode --- description text
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

Some text about the package: probably the same as the abstract.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
inlinecode --- code inlined in a LaTeX document.
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2022 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  inlinecode.dtx
and the derived files           inlinecode.ins,
                                inlinecode.pdf and
                                inlinecode.sty.

\endpostamble
\usedir{tex/latex/inlinecode}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/inlinecode}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/inlinecode}
\generate{
  \file{README.md}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
% \def\fileversion{v1.0}
% \def\filedate{2009/10/06}
%<*package>
\def\fileversion{v1.0}
\def\filedate{2009/10/06}
\NeedsTeXFormat{LaTeX2e}
\RequirePackage{needspace, xcolor, verbatim}
\ProvidesExplPackage{inlinecode}
  {2022/01/21}
  {1.0a}
  {code inlined in documents}
%</package>
%<*driver>
\ExplSyntaxOff
\documentclass{l3doc}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%\GetFileInfo{\jobname.sty}
%
%\title{^^A
%  \textsf{inlinecode} --- code inlined in a \LaTeX\ document\thanks{^^A
%    This file describes version \fileversion, last revised \filedate.^^A
%  }^^A
%}
%\author{^^A
%  Jérôme LAURENS\thanks{E-mail: jerome.laurens@u-bourgogne.fr}^^A
%}
%\date{Released \filedate}
%
%\maketitle
%
% \begin{documentation}
%
%\changes{v1.0a}{2022/01/20}{First public release}
%
% \begin{abstract}
% Usually, documentation is put inside the code,
% \pkg{inlinecode} allows to work the other way round
% by putting code inside the documentation.
% This is particularly interesting when different code files share some logic
% and should be documented all at once.
%
% The file \texttt{inlinecode-manual} gives different examples. Here is the implementation of the package.
% \end{abstract}
%
% \section{Other packages and technologies}
% \begin{description}
% \item [\texttt{docstrip}] offers similar features,
% it is somehow more powerful than \pkg{inlinecode} at the cost of
% more technicality and less practicality,
% \item [\texttt{ydoc.cls}, \texttt{skdoc.cls}] are full document class with similar features but many more unrelated.
% \pkg{inlinecode} focuses on code inlining and interfaces well with |minted|
% for a smart syntax hilighting.
% \end{description}
%
% \section{Known bugs and limitations}
% \begin{itemize}
% \item
% vertical spacing above and below \texttt{InlineCode} environment is
% not allways properly managed
% \item
% \pkg{inlinecode} should not be used with \pkg{l3doc}.
% \end{itemize}
%
% \end{documentation}
% 
% \begin{implementation}
%
%    \begin{macrocode}
%<*package>
%    \end{macrocode}
%    \begin{macrocode}
\makeatletter
%    \end{macrocode}
% \section{\texttt{InlineCode} environment}
% \begin{environment}{InlineCode}
% \begin{syntax}
% \cs{begin}\Arg{InlineCode}\oarg{key[=value] list} ... \cs{end}\Arg{InlineCode}
% \end{syntax}
% \end{environment}
% The \texttt{\meta{key}[=\meta{value}]} items are defined by the \texttt{NLNCDCode} key-value controls.
%    \begin{macrocode}
\keys_define:nn { NLNCDCode } {
%    \end{macrocode}
% We cannot allways use scratch variables here.
% \begin{description}
% \item[\ttfamily chunks=\meta{comma separated list of chunk names}],
% for each chunk name of the given list, 
% the body of the environment is appended to a dedicated storage.
%    \begin{macrocode}
  chunks .code:n = {
    \clist_set:Nn \l_NLNCD_chunks_clist { #1 }
    \clist_sort:Nn \l_NLNCD_chunks_clist {
      \str_compare:nNnTF { ##1 } > { ##2 } {
        \sort_return_swapped:
      } {
        \sort_return_same:
      }
    }
  },
%    \end{macrocode}
% \item[\ttfamily no lineno{[=true/false]}] to not display the line numbers
%    \begin{macrocode}
  no~lineno .bool_set:N = \g_tmpa_bool,
  no~lineno .code:n = {
    \bool_set_true:N \g_tmpa_bool
  },
%    \end{macrocode}
% \item[\ttfamily no name{[=true/false]}] to not display the chunk names
%    \begin{macrocode}
  no~name .bool_set:N = \g_tmpb_bool,
  no~name .code:n = {
    \bool_set_true:N \g_tmpb_bool
  },
%    \end{macrocode}
% \cs{g_tmpa_str} for \texttt{lang}.
%    \begin{macrocode}
  lang .code:n = {
    \str_set:Nn \g_tmpa_str { #1 }
  },
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  unknown .code:n = \PackageWarning
    { inlinecode }
    { Unknown~option~`\l_keys_key_str' },
}
\DeclareDocumentEnvironment { InlineCode } { m } {
  \bool_set_false:N \g_tmpa_bool
  \bool_set_false:N \g_tmpb_bool
  \bool_set_false:N \l_tmpa_bool
  \str_clear:N \g_tmpa_str
  \clist_clear:N \l_NLNCD_chunks_clist
  \exp_args:Nnx \keys_set:nn { NLNCDCode } { #1 }
  \_NLNCD_if_print_code:T {
    \if_mode_vertical:\noindent\else
      \vspace*{ \topsep }
      \par\noindent
    \fi
    \cs_set:Npn \NLNCD_line_number: {
      \hbox_overlap_left:n {
        {
          \g_NLNCD_font_lineno_tl
          \arabic { FancyVerbLine }
        }
        \hspace {1ex}
      }
    }
  }
  \NLNCD_verbatim
} {
  \endNLNCD_verbatim
  \_NLNCD_if_print_code:T {
    \vspace*{ \topsep }
    \par
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\int_zero_new:c { NLNCD_lineno_ }
%    \end{macrocode}
%    \begin{macrocode}
\tl_new:N \g_NLNCD_chunk_name_tl
\newenvironment {NLNCD_verbatim} {%
  \clist_if_empty:NTF \l_NLNCD_chunks_clist {
    \int_compare:nNnT { \int_use:c { NLNCD_lineno_ } }=\c_zero_int {
      \int_gincr:c { NLNCD_lineno_ }
    }
  } {
    \clist_map_inline:Nn \l_NLNCD_chunks_clist {
      \prop_if_in:NnF \g_NLNCD_chunks_prop { ##1 } {
        \int_zero_new:c { NLNCD_lineno_ ##1 }
      }
      \int_compare:nNnT { \int_use:c {NLNCD_lineno_##1} }=\c_zero_int {
        \int_gincr:c { NLNCD_lineno_##1 }
      }
    }
  }
  \_NLNCD_if_print_code:T {
    \bool_set_false:N \l_tmpb_bool
    \group_begin:
    \tl_set:Nx \l_tmpa_tl { \clist_use:Nn \l_NLNCD_chunks_clist , }
    \tl_if_empty:NF \l_tmpa_tl {
      \bool_if:NF \g_NLNCD_no_lineno_bool {
        \bool_if:NF \l_tmpa_bool {
          \bool_if:NTF \g_NLNCD_only_top_bool {
            \tl_if_eq:NNF \l_tmpa_tl \g_NLNCD_chunks_tl {
              \bool_set_true:N \l_tmpb_bool
            }
          } {
            \bool_set_true:N \l_tmpb_bool
          }
        }
      }
    }
    \tl_gset_eq:NN \g_NLNCD_chunks_tl \l_tmpa_tl
    \bool_if:NTF \l_tmpb_bool {
      \exp_args:NNNV
      \group_end:
      \bool_set:Nn \l_tmpb_bool \l_tmpb_bool
    } {
      \group_end:
    }
    \NLNCD_if_use_minted:TF {
      \setkeys { FV } {
        firstnumber=last,
      }
      \clist_if_empty:NTF \l_NLNCD_chunks_clist {
        \exp_args:Nnx \setkeys { FV } {
          firstnumber=\int_use:c { NLNCD_lineno_ },
        }
      } {
        \clist_map_inline:Nn \l_NLNCD_chunks_clist {
          \exp_args:Nnx \setkeys { FV } {
            firstnumber=\int_use:c { NLNCD_lineno_##1 },
          }
          \clist_map_break:
        }
      }
      \iow_open:Nn \minted@code { \jobname.pyg }
    } {
      \@bsphack
    }
  }
  \def \verbatim@processline {
    \group_begin:
    \clist_map_inline:Nn \l_NLNCD_chunks_clist {
      \prop_get:NnNTF \g_NLNCD_chunks_prop { ####1 } \l_tmpa_tl {
        \tl_put_right:Nx \l_tmpa_tl { \the\verbatim@line \iow_newline: }
        \exp_args:NNnV
        \prop_gput:Nnn \g_NLNCD_chunks_prop { ####1 } \l_tmpa_tl
      } {
        \exp_args:NNnx
        \prop_gput:Nnn \g_NLNCD_chunks_prop { ####1 }
          { \the\verbatim@line \iow_newline: }
      }
    }
    \_NLNCD_if_print_code:T {
      \NLNCD_if_use_minted:TF {
        \tl_set:Nx \l_tmpa_tl { \the\verbatim@line }
        \exp_args:NNV \iow_now:Nn \minted@code \l_tmpa_tl
      } {
        \noindent
        \tl_use:N \g_NLNCD_chunk_name_tl
        \tl_clear:N \g_NLNCD_chunk_name_tl
        \hbox_to_wd:nn { \textwidth } {
          \bool_if:NF \g_tmpa_bool {
            \hspace*{-1ex}
            \hbox_overlap_left:n {
              \g_NLNCD_font_lineno_tl
              \clist_if_empty:NTF \l_NLNCD_chunks_clist {
                \int_use:c { NLNCD_lineno_ }
              } {
                \clist_map_inline:Nn \l_NLNCD_chunks_clist {
                  \int_use:c { NLNCD_lineno_####1 }
                  \clist_map_break:
                }
              }
            }
            \hspace*{1ex}
          }
          \g_NLNCD_font_tl
          \the\verbatim@line        
          \hfill
        }
        \par
      }
    }
    \clist_if_empty:NTF \l_NLNCD_chunks_clist {
      \int_gincr:c { NLNCD_lineno_ }
    } {
      \clist_map_inline:Nn \l_NLNCD_chunks_clist {
        \int_gincr:c { NLNCD_lineno_####1 }
      }
    }
    \group_end:
  }
  \group_begin:
  \tl_clear:N \g_NLNCD_chunk_name_tl
  \let \do \@makeother
  \dospecials \catcode `\^^M \active
  \_NLNCD_if_print_code:T {
    \NLNCD_if_use_minted:TF {
      \Needspace* { 2\baselineskip }
    } {
      \frenchspacing\@vobeyspaces
    }
  }
  \tl_if_empty:NF \g_NLNCD_chunks_tl {
    \bool_if:NF \g_tmpb_bool {
      \bool_if:NT \l_tmpb_bool {
        \tl_set:Nn \g_NLNCD_chunk_name_tl {
          \hbox_overlap_left:n {
            \g_NLNCD_font_name_tl
            \tl_use:N \g_NLNCD_chunks_tl :
            \hspace{1ex}
            {
              \g_NLNCD_font_lineno_tl
              \bool_if:NF \g_tmpa_bool {
                \hspace{4ex}
              }
            }
          }
        }
      }
    }
  }
  \tl_show:N \g_NLNCD_chunk_name_tl
  \verbatim@start
} {
  \group_end:
  \str_if_empty:NT \g_tmpa_str {
    \clist_map_inline:Nn \l_NLNCD_chunks_clist {
      \prop_get:NnNT \g_NLNCD_lang_prop { ##1 } \g_tmpa_str {
        \str_if_empty:NF \g_tmpa_str {
          \clist_map_break:
        }
      }
    }
  }
  \str_if_empty:NT \g_tmpa_str {
    \str_set:Nn \g_tmpa_str { latex }
  }
  \clist_map_inline:Nn \l_NLNCD_chunks_clist {
    \prop_gput:NnV \g_NLNCD_lang_prop { ##1 } \g_tmpa_str
  }
  \_NLNCD_if_print_code:T {
    \NLNCD_if_use_minted:TF {
      \iow_close:N \minted@code
      \vspace* { \dimexpr -\topsep-\parskip }
      \tl_show:N \g_NLNCD_chunks_tl
      \tl_show:N \g_NLNCD_chunk_name_tl
      \tl_if_empty:NF \g_NLNCD_chunk_name_tl {
        \tl_use:N \g_NLNCD_chunk_name_tl
        \vspace* { \dimexpr -\topsep-\parskip-\baselineskip }        
        \par\noindent
      }
      \exp_args:NV \minted@pygmentize \g_tmpa_str
      \DeleteFile { \jobname.pyg }
      \vspace* { \dimexpr -\topsep -\partopsep }
    } {
      \@esphack
    }
  }
}
%    \end{macrocode}
% \section{Global variables and utilities}
%
% \subsection{Output}
%
% \begin{variable}{\l_NLNCD_in}
% Input file identifier
%    \begin{macrocode}
\ior_new:N \l_NLNCD_in
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLNCD_out}
% Output file identifier
%    \begin{macrocode}
\iow_new:N \l_NLNCD_out
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLNCD_preamble_prop}
%   Global property list of \texttt{\meta{file name}=\meta{preamble}} items.
%    \begin{macrocode}
\prop_new:N \g_NLNCD_preamble_prop
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLNCD_raw_prop}
% Global property list of \texttt{\meta{file name}=\meta{boolean value}}
% items indicating whether the given file should not contain
% extra material like banners.
%    \begin{macrocode}
\prop_new:N \g_NLNCD_raw_prop
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLNCD_files_prop}
% Global property list of \texttt{\meta{file name}=\meta{comma separated list of chunk names}} items.
%    \begin{macrocode}
\prop_new:N \g_NLNCD_files_prop
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLNCD_lang_prop}
% Global property list of \texttt{\meta{chunk name}=\meta{language}} items.
%    \begin{macrocode}
\prop_new:N \g_NLNCD_lang_prop
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLNCD_chunks_prop}
%   Global property list of \texttt{\meta{chunk name}=\meta{chunk content}} items.
%    \begin{macrocode}
\prop_new:N \g_NLNCD_chunks_prop
%    \end{macrocode}
% \end{variable}
% \subsection{Management}
% \begin{variable}{\g_NLNCD_in_impl_bool}
% Whether we are currently in the implementation section.
%    \begin{macrocode}
\bool_new:N \g_NLNCD_in_impl_bool
%    \end{macrocode}
% \end{variable}
% \begin{function}[TF]
%   {\_NLNCD_if_print_code:}
%   \begin{syntax}
%     \cs{\_NLNCD_if_print_code:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when code should be printed, \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \_NLNCD_if_print_code: { T, F, TF } {
  \bool_if:nTF {
    \g_NLNCD_in_impl_bool && !\g_NLNCD_with_impl_bool
  } {
    \prg_return_false:
  } {
    \prg_return_true:
  }
}
%    \end{macrocode}
% \end{function}
% \begin{variable}{\g_NLNCD_chunks_tl}
% The comma separated list of current chunks.
% If the next list of chunks is the same as the current one,
% then it might not display. 
%    \begin{macrocode}
\tl_new:N \g_NLNCD_chunks_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLNCD_chunks_clist}
% The comma separated list of current chunks.
%    \begin{macrocode}
\clist_new:N \l_NLNCD_chunks_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_NLNCD_only_top_bool}
% Whether chunk names should only display at the top.
% \end{variable}
%    \begin{macrocode}
\bool_new:N \g_NLNCD_only_top_bool
%    \end{macrocode}
% \begin{variable}{\g_NLNCD_with_impl_bool}
%    \begin{macrocode}
\bool_new:N \g_NLNCD_with_impl_bool
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLNCD_no_lineno_bool}
% Whether line numbers are displayed in the margin (false) or in the text (true)
%    \begin{macrocode}
\bool_new:N \g_NLNCD_no_lineno_bool
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_NLNCD_font_tl}
% Font specifier for inline code.
%    \begin{macrocode}
\tl_set:Nn \g_NLNCD_font_tl {
  \ttfamily
}
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_NLNCD_font_name_tl}
% Font specifier for inline code.
%    \begin{macrocode}
\tl_set:Nn \g_NLNCD_font_name_tl {
  \sffamily
  \scriptsize
  \color{gray}
}
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_NLNCD_font_lineno_tl}
% Font specifier for inline code.
%    \begin{macrocode}
\tl_set:Nn \g_NLNCD_font_lineno_tl {
  \sffamily
  \tiny
  \color{lightgray}
}
%    \end{macrocode}
% \end{variable}
%
% \section{All purpose messaging}
%    \begin{macrocode}
\msg_new:nnn { inlinecode } { :n } { #1 }
%    \end{macrocode}
%
% \section{\cs{InlineCodeSet}}
% \begin{function}{\InlineCodeSet}
% \begin{syntax}
% \cs{InlineCodeSet} \marg{key[=value] list}
% \end{syntax}
% To set up the package. This is executed at the end of the preamble.
% \end{function}
%    \begin{macrocode}
\NewDocumentCommand \InlineCodeSet { m } {
  \keys_set:nn { NLNCDSet } {#1}
  \NLNCD_if_use_minted:F {
    \bool_if:NT \g_NLNCD_minted_on_bool {
      \sys_if_shell:TF {
        \_NLNCD_if_pygmentize:TF {
          \bool_gset_true:N \g_NLNCD_use_minted_bool
        } {
          \msg_warning:nnn
            { inlinecode }
            { :n }
            { No~"pygmentize"~found. }
        }
      } {
        \msg_warning:nnn
          { inlinecode }
          { :n }
          { No~unrestricted~shell~escape~for~"pygmentize".}
      }
    }
  }
}
%    \end{macrocode}
% The unique mandatory argument of \cs{InlineCodeSet} is a list of \texttt{\meta{key}[=\meta{value}]} items defined by \texttt{NLNCDSet} key-value controls.
% \begin{variable}{\g_NLNCD_post_processor_tl}
% \texttt{pygment} post processor.
%    \begin{macrocode}
\tl_new:N \g_NLNCD_post_processor_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLNCD_post_processor_args_tl}
% \texttt{pygment} post processor arguments.
%    \begin{macrocode}
\tl_new:N \g_NLNCD_post_processor_args_tl
%    \end{macrocode} 
% \end{variable}
%    \begin{macrocode}
\keys_define:nn { NLNCDSet } {
%    \end{macrocode}
% \begin{description}
% \item[\ttfamily minted] to activate syntax coloring with \texttt{pygment},
% calls \cs{_NLNCD_minted_on} and forwards the argument as \texttt{minted} option,
%    \begin{macrocode}
  minted .code:n = {
    \_NLNCD_minted_on:
    \setkeys { minted@opt@g } { #1 }
  },
%    \end{macrocode}
% \item[\ttfamily minted style=\meta{name}]
% to select a predefined minted style, forwarded to \cs{usemintedstyle},
%    \begin{macrocode}
  minted~style .code:n = {
    \RemoveFromHook { begindocument/before } [NLNCDMinted]
    \AddToHook { begindocument/before } [NLNCDMinted] {
      \usemintedstyle { #1 }
    }
  },
%    \end{macrocode}
% \item[\ttfamily only top] to avoid chunk names repetitions, if on the same page,
% two consecutive code chunks have the same chunk names, the second names are not displayed.
%    \begin{macrocode}
  only~top .bool_set:N = \g_NLNCD_only_top_bool,
  only~top .code:n = {
    \bool_set_true:N \g_NLNCD_only_top_bool
  },
%    \end{macrocode}
% \item[\ttfamily no lineno] to globally display no line numbers,
% can be overriden on a pare chunk basis,
%    \begin{macrocode}
  no~lineno .bool_set:N = \g_NLNCD_no_lineno_bool,
  no~lineno .code:n = {
    \bool_set_true:N \g_NLNCD_no_lineno_bool
  },
%    \end{macrocode}
% \item[\ttfamily font] initially \cs{ttfamily}, used for the code.
%    \begin{macrocode}
  font .tl_set:N = \g_NLNCD_font_tl,
%    \end{macrocode}
% \item[\ttfamily font name] initially \cs{ttfamily}, used for chunks names, line numbers and code.
%    \begin{macrocode}
  name font .tl_set:N = \g_NLNCD_font_name_tl,
%    \end{macrocode}
% \item[\ttfamily font lineno] initially \cs{ttfamily}, used for chunks names, line numbers and code.
%    \begin{macrocode}
  lineno font .tl_set:N = \g_NLNCD_font_name_lineno_tl,
%    \end{macrocode}
% \item[\ttfamily only description] to typeset only the description.
%    \begin{macrocode}
  only~description .bool_set_inverse:N = \g_NLNCD_with_impl_bool,
  only~description .initial:n = false,  
  only~description .code:n = {
    \bool_set_false:N \g_NLNCD_with_impl_bool
  },
%    \end{macrocode}
% \item[\ttfamily post processor] the name of the pygment post processor,
%    \begin{macrocode}
  post~processor .tl_set_x:N = \g_NLNCD_post_processor_tl,
%    \end{macrocode}
% \item[\ttfamily post processor args] the arguments of the pygment post processor,
%    \begin{macrocode}
  post~processor~args .tl_set_x:N = \g_NLNCD_post_processor_args_tl,
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  post~processor .tl_set_x:N = \g_NLNCD_post_processor_tl,
  post~processor~args .tl_set_x:N = \g_NLNCD_post_processor_args_tl,
%    \end{macrocode}
%    \begin{macrocode}
  unknown .code:n = \PackageWarning
    { inlinecode }
    { Unknown~option~`\l_keys_key_str' },
}
%    \end{macrocode}
% \section{\texttt{minted} and \texttt{pygment}}
% \begin{variable}{\g_NLNCD_minted_on_bool}
% Whether minted is available, initially set to \texttt{false}.
%    \begin{macrocode}
\bool_new:N \g_NLNCD_minted_on_bool
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLNCD_use_minted_bool}
% Whether minted is used, initially set to \texttt{false}.
%    \begin{macrocode}
\bool_new:N \g_NLNCD_use_minted_bool
%    \end{macrocode}
% \end{variable}
% \begin{function}[TF]
%   {\NLNCD_if_use_minted:}
%   \begin{syntax}
%     \cs{NLNCD_if_use_minted:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when using |minted|, \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLNCD_if_use_minted: { T, F, TF } {
  \bool_if:NTF \g_NLNCD_use_minted_bool
    { \prg_return_true:  }
    { \prg_return_false: }
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}[TF]
%   {\_NLNCD_if_pygmentize:}
%   \begin{syntax}
%     \cs{NLNCD_if_pygmentize:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when \texttt{pygmentize} is available,
% \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn\_NLNCD_if_pygmentize: { T, F, TF } {
  \group_begin:
  \sys_get_shell:nnN {which~pygmentize} {} \l_tmpa_tl
  \tl_if_empty:NTF \l_tmpa_tl {
    \tl_set:Nn \l_tmpa_tl { \prg_return_false: }
  } {
    \tl_set:Nn \l_tmpa_tl { \prg_return_true: }
  }
  \exp_last_unbraced:NV
  \group_end: \l_tmpa_tl
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\_NLNCD_minted_on:}
% \begin{syntax}
% \cs{_NLNCD_minted_on:}
% \end{syntax}
% Private function. During the preamble, loads \pkg{minted},
% sets \cs{g_NLNCD_minted_on_bool} to \texttt{true} and prepares \texttt{pygment} processing.
% \end{function}
%    \begin{macrocode}
\cs_set:Npn \_NLNCD_minted_on: {
  \bool_gset_true:N \g_NLNCD_minted_on_bool
  \RequirePackage{minted}
  \setkeys{ minted@opt@g } { linenos=false }
  \minted@def@opt{post~processor}
  \minted@def@opt{post~processor~args}
  \pretocmd\minted@inputpyg{
    \NLNCD@postprocesspyg {\minted@outputdir\minted@infile}
  }{}{\fail}  
%    \end{macrocode}
% In the execution context of \cs{minted@inputpyg},
% \begin{description}
% \item[\texttt{\#1}] is the name of the python script, e.g., ``\texttt{process.py}''
% \item[\texttt{\#2}] is the input ``.pygtex'' file ``\cs{minted@outputdir}\cs{minted@infile}''
% \item[\texttt{\#3}] are more args passed to the python script, possibly empty
% \end{description}
%    \begin{macrocode}
  \newcommand{\NLNCD@postprocesspyg}[1]{%
    \tl_if_empty:NF \g_NLNCD_post_processor_tl {
%    \end{macrocode}
% Execute \texttt{`python3 <script.py> <file.pygtex> <more_args>`}
%    \begin{macrocode}
       \exp_args:Nx
       \sys_shell_now:n {
         python3\space
         \g_NLNCD_post_processor_tl\space
         ##1\space
         \g_NLNCD_post_processor_args_tl
       }  
    }
  }
}
%    \end{macrocode}
%    \begin{macrocode}
\AddToHook { begindocument / end } {
  \cs_set_eq:NN \_NLNCD_minted_on: \prg_do_nothing:
}
%    \end{macrocode}
% Utilities to setup |pygment| post processing.
% The |pygment| post processor marks some code with \cs{InlineCodeEmph}.
%    \begin{macrocode}
\ProvideDocumentCommand{\InlineCodeEmph}{m}{\textcolor{red}{#1}}
%    \end{macrocode}
%    \begin{macrocode}
\AddToHook { begindocument / end } {
  \cs_set_eq:NN \_NLNCD_minted_on: \prg_do_nothing:
}
%    \end{macrocode}
% \section{Files}
% \begin{function}{\InlineCodeNew}
% \begin{syntax}
% \cs{InlineCodeNew}\marg{key[=value] list}
% \end{syntax}
% It loads lately \pkg{datetime2}.
% The \texttt{\meta{key}[=\meta{value}]} items are defined below as \texttt{NLNCDNew} key-value controls.
% \end{function}
%    \begin{macrocode}
\keys_define:nn { NLNCDNew } {
%    \end{macrocode}
% This is only used in the scope of the \cs{InlineCodeNew} function such that
% scratch variable are sufficient.
% \begin{description}
% \item[\ttfamily file=\meta{file name}] is mandatory, the file named \meta{file name} will be created at the end of the document, \meta{file name} is stored in \cs{l_tmpa_tl},
%    \begin{macrocode}
  file .tl_set_x:N = \l_tmpa_tl,
  file .value_required:n = true,
%    \end{macrocode}
% \item[\ttfamily chuncks=\meta{comma separated  list of chunk names}] to list the chunks inserted as file contents, ordered and mandatory, 
%    \begin{macrocode}
  chunks .code:n = {
    \clist_set:Nn \l_tmpa_clist { #1 }
    \clist_sort:Nn \l_tmpa_clist {
      \str_compare:nNnTF { ##1 } > { ##2 } {
        \sort_return_swapped:
      } {
        \sort_return_same:
      }
    }
  },
  chunks .value_required:n = true,
%    \end{macrocode}
% \item[\ttfamily lang] to specify the language, defaults to \texttt{latex},
%    \begin{macrocode}
  lang .code:n = {
    \str_set:Nn \l_tmpa_str { #1 }
  },
  lang .value_required:n = true,
%    \end{macrocode}
% \item[\ttfamily raw] to remove any additional material,
% |\l_tmpa_bool| to store the value for \texttt{raw}, 
%    \begin{macrocode}
  raw .bool_set:N = \l_tmpa_bool,
  raw .code:n = {
    \bool_set_true:N \l_tmpa_bool
  },
%    \end{macrocode}
% \item[\ttfamily preamble] the added preamble.
%    \begin{macrocode}
  preamble .tl_set:N = \l_tmpb_tl,
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
}
%    \end{macrocode}
%    \begin{macrocode}
\DeclareDocumentCommand \InlineCodeNew { m } {
  \RequirePackage{datetime2}
  \group_begin:
  \clist_clear:N \l_tmpa_clist
  \tl_clear:N \l_tmpb_tl
  \bool_set_false:N \l_tmpa_bool
  \str_set:Nn \l_tmpa_str { latex }
  \exp_args:Nnx \keys_set:nn { NLNCDNew } { #1 }
  \exp_args:NNV \prop_if_in:NnT \g_NLNCD_files_prop \l_tmpa_tl {
    \msg_critical:nnx
      { inlinecode }
      { :n }
      { Duplicate~file "\l_tmpa_tl'' }
  }
  \prop_gput:NVx \g_NLNCD_files_prop \l_tmpa_tl
    { \clist_use:Nn \l_tmpa_clist , }
  \prop_gput:NVV \g_NLNCD_preamble_prop \l_tmpa_tl \l_tmpb_tl
  \clist_map_inline:Nn \l_tmpa_clist {
    \prop_gput:NnV \g_NLNCD_lang_prop { ##1 } \l_tmpa_str
  }
  \group_end:
}
\AddToHook { begindocument / end } {
  \RenewDocumentCommand \InlineCodeNew { m } {
    \msg_fatal:nn { :n } { Only~in~preamble:~\cs{InlineCodeNew} }
  }
}
%    \end{macrocode}
% Files are created at the end of the process.
%    \begin{macrocode}
\AddToHook { enddocument / end } {
  \group_begin:
  \prop_map_inline:Nn \g_NLNCD_files_prop {
    \iow_open:Nn \l_NLNCD_out {#1}
    \iow_term:x {Exporting~chunks~#2~to~#1}
    \bool_set_false:N \l_tmpa_bool
    \prop_get:NnNT \g_NLNCD_raw_prop { #1 } \l_tmpa_tl {
      \bool_set:Nn \l_tmpa_bool { \l_tmpa_tl }
    }
    \bool_if:NF \l_tmpa_bool {
      \prop_get:NnNT \g_NLNCD_preamble_prop { #1 } \l_tmpa_tl {
        \str_set:Nx \l_tmpa_str {
          \exp_args:Nx \str_head_ignore_spaces:n { \l_tmpa_tl }
        }
        \str_if_empty:NT \l_tmpa_str {
          \str_set_eq:NN \l_tmpa_str \c_percent_str
        }
        \tl_set:Nx \l_tmpb_tl {
          \l_tmpa_str\l_tmpa_str\space\space
          This~is~file~`#1'~
          generated~from~`\c_sys_jobname_str.tex'~on~\DTMnow.
        }
        \iow_now:Nx \l_NLNCD_out { \l_tmpb_tl }
        \iow_now:Nx \l_NLNCD_out { \l_tmpa_tl }
      }
    }
    \clist_map_inline:nn { #2 } {
      \prop_get:NnNT \g_NLNCD_chunks_prop { ##1 } \l_tmpa_tl {
        \exp_args:NNV \iow_now:Nn \l_NLNCD_out \l_tmpa_tl
      }
    }
    \iow_close:N \l_NLNCD_out
  }
  \group_end:
}
%    \end{macrocode}
%
% \begin{function}{\InlineCodeStorePreamble}
% \begin{syntax}
% \cs{InlineCodeStorePreamble} \marg{variable} \marg{file name}
% \end{syntax}
% Store the content of \meta{file name} into the variable \meta{variable}.
% \end{function}
%
% \section{Separators}
% \begin{function}{\InlineCodeImplementation}
% \begin{syntax}
% \cs{InlineCodeImplementation}
% \end{syntax}
% Start an implementation part where all the sectioning commands do nothing.
% \end{function}
% \begin{function}{\InlineCodeFinale}
% \begin{syntax}
% \cs{InlineCodeFinale}
% \end{syntax}
% Stop an implementation part.
% \end{function}
% \section{Finale}
%    \begin{macrocode}
\DeclareDocumentCommand \InlineCodeStorePreamble { m m } {
  \group_begin:
  \msg_info:nnn
    { inlinecode }
    { :n }
    { Reading~preamble~from~file~"#2". }
  \tl_clear:N \g_tmpa_tl
  \tl_clear:N \g_tmpb_tl
  \ior_open:Nn \l_NLNCD_in { #2 }
  \bool_until_do:nn { \ior_if_eof_p:N \l_NLNCD_in } {
    \ior_str_get:NN \l_NLNCD_in \l_tmpa_tl
    \tl_if_empty:NTF \l_tmpa_tl {
      \tl_put_right:Nn \g_tmpb_tl { \iow_newline: }
    } {
      \tl_put_right:Nx \g_tmpa_tl { \g_tmpb_tl }
      \tl_set:Nn \g_tmpb_tl { \iow_newline: }
      \tl_put_right:NV \g_tmpa_tl \l_tmpa_tl
    }
  }
  \ior_close:N \l_NLNCD_in
  \exp_args:NNNx
  \group_end:
  \tl_set:Nn #1 { \tl_to_str:N \g_tmpa_tl }
}
\newcounter{NLNCD@impl@page}
\DeclareDocumentCommand \InlineCodeImplementation {} {
  \bool_if:NF \g_NLNCD_with_impl_bool {
    \clearpage
    \bool_gset_true:N \g_NLNCD_in_impl_bool
    \let\NLNCD@old@part\part
    \DeclareDocumentCommand\part{som}{}
    \let\NLNCD@old@section\section
    \DeclareDocumentCommand\section{som}{}
    \let\NLNCD@old@subsection\subsection
    \DeclareDocumentCommand\subsection{som}{}
    \let\NLNCD@old@subsubsection\subsubsection
    \DeclareDocumentCommand\subsubsection{som}{}
    \let\NLNCD@old@paragraph\paragraph
    \DeclareDocumentCommand\paragraph{som}{}
    \let\NLNCD@old@subparagraph\subparagraph
    \DeclareDocumentCommand\subparagraph{som}{}
    \cs_if_exist:NT \refsection{ \refsection }
    \setcounter{ NLNCD@impl@page }{ \value{page} }
  }
}
\DeclareDocumentCommand\InlineCodeFinale {} {
  \bool_if:NF \g_NLNCD_with_impl_bool {
    \clearpage
    \bool_gset_false:N \g_NLNCD_in_impl_bool
    \let\part\NLNCD@old@part
    \let\section\NLNCD@old@section
    \let\subsection\NLNCD@old@subsection
    \let\subsubsection\NLNCD@old@subsubsection
    \let\paragraph\NLNCD@old@paragraph
    \let\subparagraph\NLNCD@old@subparagraph
    \setcounter { page } { \value{ NLNCD@impl@page } }
  }
}
\cs_set_eq:NN \NLNCD_line_number: \prg_do_nothing:
%    \end{macrocode}
% \section{Finale}
%    \begin{macrocode}
\AddToHook { cmd/FancyVerbFormatLine/before } {
  \NLNCD_line_number:
}
\AddToHook { shipout/before } {
  \tl_gclear:N \g_NLNCD_chunks_tl
}
\InlineCodeSet {}
%    \end{macrocode}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{implementation}
%\Finale
%
% % ^^A \PrintIndex
