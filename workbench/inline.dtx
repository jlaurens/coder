% \iffalse meta-comment
% !TEX program  = lualatex
% !TEX encoding  = utf8
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
inline --- description text
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

Some text about the package: probably the same as the abstract.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\preamble
----------------------------------------------------------------
inline --- code inlined in a LuaLaTeX document.
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\postamble

Copyright (C) 2022 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  inline.dtx
and the derived files           inline.ins,
                                inline.pdf and
                                inline.sty.

\endpostamble
\usedir{tex/latex/inline}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{package}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/inline}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\nopreamble\nopostamble
\usedir{doc/latex/inline}
\generate{
  \file{README.md}{\from{\jobname.dtx}{readme}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
% \def\fileversion{v1.0}
% \def\filedate{2009/10/06}
%<*package>
\def\fileversion{v1.0}
\def\filedate{2009/10/06}
\RequirePackage{luacode, needspace, xcolor, verbatim}
\AddToHook { begindocument / before } {
  \RequirePackage{datetime2}
}
\ProvidesExplPackage{inline}
  {2022/01/21}
  {1.0a}
  {code inlined in documents}

\NeedsTeXFormat{LaTeX2e}
\msg_new:nnn { inline } { :n } { #1 }
\cs_if_exist:NTF\IfFormatAtLeastTF {
  \IfFormatAtLeastTF{2021/06/01} {} {
    \msg_fatal:nnn { inline } { :n } { Please~update~LaTeX.~Emergency~stop }
  }
} {
  \msg_fatal:nnn { inline } { :n } { Please~update~LaTeX.~Emergency~stop }
}
\begin{luacode}
NLN = {}
function NLN.make_directory(path)
  mode,_,__ = lfs.attributes(path,"mode")
  if mode == "directory" then
    return true
  elseif mode ~= nil then
    return nil,path.." exist and is not a directory",1
  end
  if os["type"] == "windows" then
    path = path:gsub("/", "\\")
    _,_,__ = os.execute(
      "if not exist "  .. path .. "\\nul " .. "mkdir " .. path
    )
  else
    _,_,__ = os.execute("mkdir -p " .. path)
  end
  mode = lfs.attributes(path,"mode")
  if mode == "directory" then
    return true
  end
  return nil,path.." exist and is not a directory",1
end
function NLN.start_recording()
  NLN.records = {}
  function NLN.records.append (t,v)
    t[#t+1]=v
    return t
  end
end
\end{luacode}

%</package>
%<*driver>
\ExplSyntaxOff
\documentclass{l3doc}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%\GetFileInfo{\jobname.sty}
%
%\title{^^A
%  \textsf{inline} --- code inlined in a \LaTeX\ document\thanks{^^A
%    This file describes version \fileversion, last revised \filedate.^^A
%  }^^A
%}
%\author{^^A
%  Jérôme LAURENS\thanks{E-mail: jerome.laurens@u-bourgogne.fr}^^A
%}
%\date{Released \filedate}
%
%\maketitle
%
% \begin{documentation}
%
%\changes{v1.0a}{2022/01/20}{First public release}
%
% \begin{abstract}
% Usually, documentation is put inside the code,
% \pkg{inline} allows to work the other way round
% by putting code inside the documentation.
% This is particularly interesting when different code files share some logic
% and should be documented all at once.
%
% The file \texttt{inline-manual} gives different examples. Here is the implementation of the package.
%
% This \LaTeX{} package requires \LuaTeX{} and may use syntax coloring based on \pkg{pygment}.
% \end{abstract}
%
% \section{Package dependencies}
% \pkg{luacode}, \pkg{verbatim}, \pkg{datetime2}, \pkg{xcolor}, \pkg{fancyvrb} and dependencies of these packages.
% \section{Similar technologies}
% \begin{description}
% \item The \pkg{docstrip} utility offers similar features,
% it is somehow more powerful than \pkg{inline} at the cost of
% more technicality and less practicality,
% \item The \pkg{ydoc.cls} and \pkg{skdoc.cls} are
% full document classes with similar features but
% many more that are unrelated.
% \pkg{inline} focuses on code inlining and interfaces well with \pkg{pygment}
% for a smart syntax hilighting.
% \end{description}
%
% \section{Known bugs and limitations}
% \begin{itemize}
% \item
% \pkg{inline} does not play well with \pkg{docstrip}.
% \end{itemize}
%
% \end{documentation}
% 
% \begin{implementation}
%
%    \begin{macrocode}
%<*package>
\makeatletter
%    \end{macrocode}
% \section{Constants}
% \begin{variable}{\c_NLN_comment_prop}
% One line comment marker per language.
%    \begin{macrocode}
\prop_const_from_keyval:Nn \c_NLN_comment_prop {
  tex=\c_percent_str,
  lua=--,
  python=\c_hash_str,
  c=//,
  c++=//,
  javascript=//,
}
%    \end{macrocode}
% \end{variable}
% \section{Global properties}
% \begin{variable}{\g/NLN/code/ }
% \begin{variable}{\g/NLN/code/<name>}
% Tree storage for global generic code properties or named code properties.
% These are overriden locally in environments using
% key-value actions. \cs{l_NLN_code_name_tl} is used as \meta{name}.
%    \begin{macrocode}
\prop_new:c { g/NLN/code/ }
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \begin{variable}{\l_NLN_code_name_tl}
% Locally used as \meta{name} in \cs{g/NLN/code/<name>}
% \cs{g/NLN/int/<name>} and similar.
%    \begin{macrocode}
\tl_new:N \l_NLN_code_name_tl
%    \end{macrocode}
% \end{variable}
% \subsection{Management}
% \begin{function}{\NLN_item:n}
% \begin{syntax}
% \cs{NLN_item:n} \marg{key}
% \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \NLN_item:n #1 {
  \prop_item:cn { g/NLN/code/ } { #1 }
}
%    \end{macrocode}
% \end{function}
% \begin{function} [TF] {\NLN_get:nN}
%   \begin{syntax}
%     \cs{NLN_get:nNTF} \marg{key} \meta{tl var} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when \cs{g/NLN/code/} prop's
% \texttt{\meta{key}} is retrieved in \meta{tl var},
% \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_get:nN { T, F, TF } {
  \prop_get:cnNTF { g/NLN/code/ } { #1 } #2 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{function}
% \begin{function}[EXP]{\NLN_item:nn}
% \begin{syntax}
% \cs{NLN_item:nn} \marg{name} \marg{key}
% \end{syntax}
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_item:nn #1 #2 {
  \prop_item:cn { g/NLN/code/#1 } { #2 }
}
%    \end{macrocode}
% \end{function}
% \begin{function} [TF] {\NLN_get:nnN}
%   \begin{syntax}
%     \cs{NLN_get:nnNTF} \marg{name} \marg{key} \meta{tl var} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when \texttt{g/NLN/code/\marg{meta}}
% prop's \texttt{\meta{key}} is retrieved in \meta{tl var},
% \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_get:nnN { T, F, TF } {
  \prop_get:cnNTF { g/NLN/code/#1 } { #2 } #3 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_put:nn,\NLN_put:nV,\NLN_gput:nn,\NLN_gput:nV}
% \begin{syntax}
% \cs{NLN_put:nn} \marg{key} \marg{value}
% \cs{NLN_gput:nn} \marg{key} \marg{value}
% \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \NLN_put:nn #1 #2 {
  \prop_put:cnn { g/NLN/code/ } { #1 } { #2 }
}
\cs_new:Npn \NLN_gput:nn #1 #2 {
  \prop_gput:cnn { g/NLN/code/ } { #1 } { #2 }
}
\cs_generate_variant:Nn \NLN_put:nn { nV }
\cs_generate_variant:Nn \NLN_gput:nn { nV }
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_put:nnn, \NLN_put:nnV, \NLN_gput:nnn, \NLN_gput:nnV}
% \begin{syntax}
% \cs{NLN_put:nnn} \marg{name} \marg{key} \marg{value}
% \cs{NLN_gput:nnn} \marg{name} \marg{key} \marg{value}
% \end{syntax}
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_put:nnn #1 #2 #3 {
  \prop_put:cnn { g/NLN/code/#1 } { #2 } { #3 }
}
\cs_new:Npn \NLN_gput:nnn #1 #2 #3 {
  \prop_gput:cnn { g/NLN/code/#1 } { #2 } { #3 }
}
\cs_generate_variant:Nn \NLN_put:nnn { nnV }
\cs_generate_variant:Nn \NLN_gput:nnn { nnV }
%    \end{macrocode}
% \end{function}
% \subsection{Known keys and conditionals}
% \begin{function}{\NLN_new_conditional:n}
%   \begin{syntax}
%     \cs{NLN_new_conditional:n} \marg{key}
%   \end{syntax}
% Create new conditionals for the given key.
% Does nothing out of this package..
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \NLN_new_conditional:n #1 {
  \exp_last_unbraced:Nx
  \prg_new_conditional:Nnn { \use:c { NLN_if_#1: } } { T, F, TF } {
    \group_begin:
    \NLN_get:nNTF { #1 } \l_tmpa_tl {
      \exp_args:NnV
      \regex_match:nnTF
      { ^\s*[tTyY] }
      \l_tmpa_tl
      { \group_end: \prg_return_true:  }
      { \group_end: \prg_return_false: }
    } { \group_end: \prg_return_false: }
  }
}
%    \end{macrocode}

%\begin{description}
% \item[\ttfamily format/code] Font/size/color specifier for inline code.
%    \begin{macrocode}
\NLN_gput:nn { format/code } {
  \ttfamily
}
%    \end{macrocode}
% \item[\ttfamily format/name] Font/size/color specifier for chunk name.
%    \begin{macrocode}
\NLN_gput:nn { format/name } {
  \sffamily
  \scriptsize
  \color{gray}
}
%    \end{macrocode}
% \item[\ttfamily format/lineno] Font/size/color specifier for line numbers.
%    \begin{macrocode}
\NLN_gput:nn { format/lineno } {
  \sffamily
  \tiny
  \color{gray}
}
%    \end{macrocode}
% \item[\ttfamily lang] the langage, defaults to \texttt{tex}
%    \begin{macrocode}
\NLN_gput:nn { lang } { tex }
%    \end{macrocode}
% \item[\ttfamily lineno] show line numbers, defaults to \texttt{true}
%    \begin{macrocode}
\NLN_gput:nn { show_lineno } { T }
%    \end{macrocode}
% \begin{function}[TF]
%   {\NLN_if_show_lineno:}
%   \begin{syntax}
%     \cs{NLN_if_show_lineno:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{show_lineo} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { show_lineno }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily name] show chunk names, defaults to \texttt{true}
%    \begin{macrocode}
\NLN_gput:nn { show_name } { T }
%    \end{macrocode}
% \begin{function}[TF]
%   {\NLN_if_show_name:}
%   \begin{syntax}
%     \cs{NLN_if_show_name:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{show_name} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { show_name }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily only top] show names only on top, defaults to \texttt{true}
%    \begin{macrocode}
\NLN_gput:nn { only_top } { T }
%    \end{macrocode}
% \begin{function}[TF]
%   {\NLN_if_only_top:}
%   \begin{syntax}
%     \cs{NLN_if_only_top:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{only_top} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { only_top }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily margin] use the margin to display line numbers and chunk names, defaults to \texttt{true}
%    \begin{macrocode}
\NLN_gput:nn { use_margin } { T }
%    \end{macrocode}
% \begin{function}[TF]
%   {\NLN_if_use_margin:}
%   \begin{syntax}
%     \cs{NLN_if_use_margin:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{use_margin} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { use_margin }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily ignore] ignore that chunk or that export, defaults to \texttt{false}
%    \begin{macrocode}
\NLN_gput:nn { ignore } { F }
%    \end{macrocode}
% \begin{function}[TF]
%   {\NLN_if_ignore:}
%   \begin{syntax}
%     \cs{NLN_if_ignore:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{ignore} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { ignore }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily reset] reset line numbering, defaults to \texttt{false}
%    \begin{macrocode}
\NLN_gput:nn { reset } { F }
%    \end{macrocode}
% \begin{function}[TF]
%   {\NLN_if_reset:}
%   \begin{syntax}
%     \cs{NLN_if_reset:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{reset} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { reset }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily export] whether the code should be exported, defaults to \texttt{true}
%    \begin{macrocode}
\NLN_gput:nn { export } { T }
%    \end{macrocode}
% \begin{function}[TF]
%   {\NLN_if_export:}
%   \begin{syntax}
%     \cs{NLN_if_export:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{export} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { export }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily parskip] the parskip used to separate lines of code
%    \begin{macrocode}
\AddToHook { begindocument/end } {
  \prop_if_in:cnF { g/NLN/code } { parskip } {
    \exp_args:Nnx
    \NLN_gput:nn { parskip } { \the\parskip }
  }
}
%    \end{macrocode}
% \item[\ttfamily sep] the separation between inline code blocks
% and surrounding text.
%    \begin{macrocode}
\NLN_gput:nn { sep } { 4pt plus 2pt minus 2pt }
%    \end{macrocode}
% \item[\ttfamily code] the cumulated inline code
%    \begin{macrocode}
\NLN_gput:nn { .code } {}
%    \end{macrocode}
% \end{description}
% Clean memory.
%    \begin{macrocode}
\cs_set_eq:NN \NLN_new_conditional:n \prg_do_nothing:
%    \end{macrocode}
% \section{Counters}
% \begin{function}{\NLN_int_new:nn}
% \begin{syntax}
% \cs{NLN_int_new:n} \marg{name} \marg{value}
% \end{syntax}
% Create an integer after \meta{name} and
% set it globally to \meta{value}.
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_int_new:nn #1 #2 {
  \int_new:c { g/NLN/int/#1 }
  \int_gset:cn { g/NLN/int/#1 } { #2 }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_int_set:nn,\NLN_int_gset:nn}
% \begin{syntax}
% \cs{NLN_int_set:n} \marg{name} \marg{value}
% \end{syntax}
% Set the integer named after \meta{name} to the \meta{value}. \cs{NLN_int_gset:n} makes a global change.
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_int_set:nn #1 #2 {
  \int_set:cn { g/NLN/int/#1 } { #2 }
}
\cs_new:Npn \NLN_int_gset:nn #1 #2 {
  \int_gset:cn { g/NLN/int/#1 } { #2 }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_int_add:nn,\NLN_int_gadd:nn}
% \begin{syntax}
% \cs{NLN_int_add:n} \marg{name} \marg{value}
% \end{syntax}
% Add the \meta{value} to the integer named after \meta{name}. \cs{NLN_int_gadd:n} makes a global change.
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_int_add:nn #1 #2 {
  \int_add:cn { g/NLN/int/#1 } { #2 }
}
\cs_new:Npn \NLN_int_gadd:nn #1 #2 {
  \int_gadd:cn { g/NLN/int/#1 } { #2 }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_int_sub:nn,\NLN_int_gsub:nn}
% \begin{syntax}
% \cs{NLN_int_sub:n} \marg{name} \marg{value}
% \end{syntax}
% Substract the \meta{value} from the integer named after \meta{name}. \cs{NLN_int_gsub:n} makes a global change.
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_int_sub:nn #1 #2 {
  \int_sub:cn { g/NLN/int/#1 } { #2 }
}
\cs_new:Npn \NLN_int_gsub:nn #1 #2 {
  \int_gsub:cn { g/NLN/int/#1 } { #2 }
}
%    \end{macrocode}
% \end{function}
% \begin{function}[TF]
%   {\NLN_int_if_exist:n}
%   \begin{syntax}
%     \cs{NLN_int_if_exist:nTF} \marg{name} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when
% an integer named after \meta{name} exist,
% \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_int_if_exist:n { T, F, TF } {
  \int_if_exist:cTF { g/NLN/int/#1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{function}
% \begin{variable}{\g/NLN/int/}
% \begin{variable}{\g/NLN/int/<name>}
% Generic and named line number counter.
% \cs{l_NLN_code_name_t} is used as \meta{name}.
%    \begin{macrocode}
\NLN_int_new:nn {} { 1 }
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \begin{function}[EXP]{\NLN_int_use:n}
% \begin{syntax}
% \cs{NLN_int_use:n} \marg{name}
% \end{syntax}
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_int_use:n #1 {
  \int_use:c { g/NLN/int/#1 }
}
%    \end{macrocode}
% \end{function}
% \section{Variables}
% Line number counter for the code chunks.
% \begin{variable}{\g_NLN_code_int}
% Chunk number counter.
%    \begin{macrocode}
\int_new:N \g_NLN_code_int
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLN_code_prop}
% Global code property list.
%    \begin{macrocode}
\prop_new:N \g_NLN_code_prop
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLN_export_prop}
% Global storage for \texttt{\meta{file name}=\meta{comma separated chunk name}}
%    \begin{macrocode}
\prop_new:N \g_NLN_export_prop
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLN_chunks_tl}
% \begin{variable}{\l_NLN_chunks_tl}
% The comma separated list of current chunks.
% If the next list of chunks is the same as the current one,
% then it might not display. 
%    \begin{macrocode}
\tl_new:N \g_NLN_chunks_tl
\tl_new:N \l_NLN_chunks_tl
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \begin{variable}{\g_NLN_vars}
% Tree storage for global variables.
%    \begin{macrocode}
\prop_new:N \g_NLN_vars
%    \end{macrocode}
% \begin{description}
% \item[\ttfamily WHAT]
% \end{description}
% \end{variable}
% \begin{variable}{\g_NLN_vars}
% Tree storage for global variables.
%    \begin{macrocode}
\tl_new:N \g_NLN_hook_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g/NLN/Chunks/<name>}
% List of chunk keys for given named code.
% \end{variable}
%
% \subsection{Local variables}
% \begin{variable}{\l_NLN_recorded_tl}
% Full verbatim body of the \texttt{Inline} environment.
%    \begin{macrocode}
\tl_new:N \l_NLN_recorded_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLN_int}
% Global integer to store linenos locally in time.
%    \begin{macrocode}
\int_new:N \g_NLN_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_NLN_line_tl}
% Token list for one line.
%    \begin{macrocode}
\tl_new:N \l_NLN_line_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_lineno_tl}
% Token list for lineno display.
%    \begin{macrocode}
\tl_new:N \l_NLN_lineno_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_name_tl}
% Token list for chunk name display.
%    \begin{macrocode}
\tl_new:N \l_NLN_name_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_info_tl}
% Token list for the info of line.
%    \begin{macrocode}
\tl_new:N \l_NLN_info_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_clist}
% The comma separated list of current chunks.
%    \begin{macrocode}
\clist_new:N \l_NLN_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_NLN_in}
% Input file identifier
%    \begin{macrocode}
\ior_new:N \l_NLN_in
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_out}
% Output file identifier
%    \begin{macrocode}
\iow_new:N \l_NLN_out
%    \end{macrocode}
% \end{variable}
% \section{Utilities}
% Utilities
% \begin{function}{\NLN_clist_map_inline:Nnn}
% \begin{syntax}
% \cs{NLN_clist_map_inline:Nnn} \meta{clist var}
% \marg {non empty code} \marg {empty code}
% \end{syntax}
% Call \texttt{\cs{clist_map_inline:Nnn} \meta{clist var}
% \marg {non empty code}} when the list is not empty,
% execute meta{empty code} otherwise.
%    \begin{macrocode}
\cs_new:Npn \NLN_clist_map_inline:Nnn #1 #2 #3 {
  \clist_if_empty:NTF #1 { #3 } {
    \clist_map_inline:Nn #1 { #2 }
  }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_process_record:}
% Record the current line or not.
%    \begin{macrocode}
\cs_new:Npn \NLN_process_record: {}
%    \end{macrocode}
% \end{function}
% \section{Shared key-value controls}
% Each action is meant to store the values in a code property, for the almost eponym key.
%    \begin{macrocode}
\keys_define:nn { NLN } {
%    \end{macrocode}
% Keys are:
% \begin{description}
% \item[\ttfamily lineno{[=true/false]}] to display the line numbers, or not,
%    \begin{macrocode}
  lineno .code:n = \NLN_put:nn { show_lineno } { #1 },
  lineno .default:n = true,
%    \end{macrocode}
% \item[\ttfamily name{[=true/false]}] to display the chunk names
%    \begin{macrocode}
  name .code:n = \NLN_put:nn { show_name } { #1 },
  name .default:n = true,
%    \end{macrocode}
% \item[\ttfamily only top] to avoid chunk names repetitions, if on the same page,
% two consecutive code chunks have the same chunk names, the second names are not displayed.
%    \begin{macrocode}
  only~top .code:n = \NLN_put:nn { only_top } { #1 },
  only~top .default:n = true,
%    \end{macrocode}
% \item[\ttfamily ignore] to ignore chunks.
%    \begin{macrocode}
  ignore .code:n = \NLN_put:nn { ignore } { #1 },
  ignore .default:n = true,
%    \end{macrocode}
% \item[\ttfamily margin{[=true/false]}] to use the magin to display line numbers, or not,
%    \begin{macrocode}
  margin .code:n = \NLN_put:nn { use_margin } { #1 },
  margin .default:n = true,
%    \end{macrocode}
% \item[\ttfamily lang=\meta{language name}], where \meta{language name} is recognized by \texttt{pygment},
%    \begin{macrocode}
  lang .code:n = \NLN_put:nn { lang } { #1 },
%    \end{macrocode}
% \item[\ttfamily code format=\meta{format}], where \meta{format} is used to display the code (mainly font, size and color),
%    \begin{macrocode}
  code~format .code:n = \NLN_put:nn { format/code } { #1 },
%    \end{macrocode}
% \item[\ttfamily lineno format=\meta{format}], where \meta{format} is used to display the line numbers (mainly font, size and color),
%    \begin{macrocode}
  name~format .code:n = \NLN_put:nn { format/name } { #1 },
%    \end{macrocode}
% \item[\ttfamily name format=\meta{format}], where \meta{name format} is used to display the chunk names (mainly font, size and color),
%    \begin{macrocode}
  lineno~format .code:n = \NLN_put:nn { format/lineno } { #1 },
%    \end{macrocode}
% \item[\ttfamily post processor] the name of the pygment post processor,
%    \begin{macrocode}
  post~processor .code:n = \NLN_put:nn { post_processor } { #1 },
%    \end{macrocode}
% \item[\ttfamily post processor args] the arguments of the pygment post processor,
%    \begin{macrocode}
  post~processor~args .code:n = \NLN_put:nn { post_processor_args } { #1 },
%    \end{macrocode}
% \item[\ttfamily sep] the separation with the surrounding text,
%    \begin{macrocode}
  sep .code:n = \NLN_put:nn { sep } { #1 },
%    \end{macrocode}
% \item[\ttfamily parskip] the value of the \cs{parskip} in inline code blocks,
%    \begin{macrocode}
  parskip .code:n = \NLN_put:nn { parskip } { #1 },
%    \end{macrocode}
% \item[\ttfamily test] whether the chunk is a test,
%    \begin{macrocode}
  test .code:n = \NLN_put:nn { test } { #1 },
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  unknown .code:n = \PackageWarning
    { inline }
    { Unknown~option~`\l_keys_key_str' },
}
%    \end{macrocode}
% \section{\cs{InlineSet}}
% \begin{function}{\InlineSet}
% \begin{syntax}
% \cs{InlineSet} \marg{key[=value] list}
% \end{syntax}
% To set up the package. This is executed at least once at the end of the preamble.
% The unique mandatory argument of \cs{InlineSet} is a
% list of \texttt{\meta{key}[=\meta{value}]} items defined by 
% \end{function}
% \subsection{\texttt{NLN/set} key-value controls.}
%    \begin{macrocode}
\keys_define:nn { } { NLN/set .inherit:n = NLN }
\keys_define:nn { NLN/set } {
%    \end{macrocode}
% \begin{description}
% \item[\ttfamily minted] to activate syntax coloring with \texttt{pygment},
% calls \cs{_NLN_minted_on:} and forwards the argument as \texttt{minted} option,
%    \begin{macrocode}
  minted .code:n = {
    \_NLN_minted_on:
    \setkeys { minted@opt@g } { #1 }
  },
%    \end{macrocode}
% \item[\ttfamily minted style=\meta{name}]
% to select a predefined minted style, forwarded to \cs{usemintedstyle},
%    \begin{macrocode}
  minted~style .code:n = {
    \RemoveFromHook { begindocument/before } [NLN/Minted]
    \AddToHook { begindocument/before } [NLN/Minted] {
      \usemintedstyle { #1 }
    }
  },
%    \end{macrocode}
% \item[\ttfamily only description] to typeset only the description
% section and ignore the implementation section.
%    \begin{macrocode}
  only~description .code:n = \prop_put:Nnn \l_NLN_vars
    { only_description } { #1 },
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  unknown .code:n = \PackageWarning
    { NLN/set }
    { Unknown~option~`\l_keys_key_str' },
}
%    \end{macrocode}
%
% \subsection{Implementation}
%    \begin{macrocode}
\NewDocumentCommand \InlineSet { m } {
  \keys_set:nn { NLN/set } {#1}
  \NLN_if_use_minted:F {
    \bool_if:NT \g_NLN_minted_on_bool {
      \sys_if_shell:TF {
        \_NLN_if_pygmentize:TF {
          \bool_gset_true:N \g_NLN_use_minted_bool
        } {
          \msg_warning:nnn
            { inline }
            { :n }
            { No~"pygmentize"~found. }
        }
      } {
        \msg_warning:nnn
          { inline }
          { :n }
          { No~unrestricted~shell~escape~for~"pygmentize".}
      }
    }
  }
}
%    \end{macrocode}
%
% \section{\texttt{InlineSplit} environment}
% 
% \section{\texttt{Inline} environment}
% \begin{environment}{Inline}
% \begin{syntax}
% \cs{begin}\Arg{Inline}\marg{key[=value] list} ... \cs{end}\Arg{Inline}
% \end{syntax}
% \end{environment}
% The \texttt{\meta{key}[=\meta{value}]} items are defined by the
% \subsection{\texttt{NLN/code} key-value controls}
%    \begin{macrocode}
\keys_define:nn { } { NLN/code .inherit:n = NLN }
\keys_define:nn { NLN/code } {
%    \end{macrocode}
% \begin{description}
% \item[\ttfamily chunks=\meta{comma separated list of chunk names}]
% When declaring an exported file,
% this is the list of chunks that will appear in that file.
% When declaring a code chunk, this the list of chunks where it will be stored.
% Chunks are collected unordered and ordered for comparison.
%    \begin{macrocode}
  chunks .clist_set:N = \l_NLN_clist,
%    \end{macrocode}
% \item[\ttfamily reset[=<boolean string>]
% When declaring an exported file,
% this is the list of chunks that will appear in that file.
% When declaring a code chunk, this the list of chunks where it will be stored.
% Chunks are collected unordered and ordered for comparison.
%    \begin{macrocode}
  reset .code:n = \NLN_put:nn { reset } { #1 },
  reset .default:n = true,
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  unknown .code:n = \PackageWarning
    { NLN/code }
    { Unknown~option~`\l_keys_key_str' },
}
%    \end{macrocode}
%
% \subsection{Implementation}
% \begin{function}[TF]
%   {\NLN_if_record:}
%   \begin{syntax}
%     \cs{NLN_if_record:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when code should be recorded, \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_if_record: { T, F, TF } {
  \NLN_if_export:TF {
    \prg_return_true:
  } {
    \NLN_if_use_minted:TF {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{function}
%    \begin{macrocode}
\cs_set:Npn \NLN_process_record: {
  \tl_put_right:Nx \l_NLN_recorded_tl { \the\verbatim@line \iow_newline: }
  \group_begin:
  \tl_set:Nx \l_tmpa_tl { \the\verbatim@line }
  \exp_args:Nx \directlua {NLN.records.append([===[\l_tmpa_tl]===])}
  \group_end:
}
%    \end{macrocode}
%    \begin{macrocode}
\DeclareDocumentEnvironment { Inline } { m } {
  \directlua{NLN.start_recording()}
  \clist_clear:N \l_NLN_clist
  \keys_set:nn { NLN/code } { #1 }
  \clist_map_inline:Nn \l_NLN_clist {
    \NLN_int_if_exist:nF { ##1 } {
      \NLN_int_new:nn { ##1 } { 1 }
      \seq_new:c { g/NLN/chunks/##1 }
    }
  }
  \NLN_if_reset:T {
    \NLN_clist_map_inline:Nnn \l_NLN_clist {
      \NLN_int_gset:nn { ##1 } 1
    } {
      \NLN_int_gset:nn { } 1
    }
  }
  \tl_clear:N \l_NLN_code_name_tl
  \clist_map_inline:Nn \l_NLN_clist {
    \prop_concat:ccc
      { g/NLN/code/ }
      { g/NLN/code/##1 }
      { g/NLN/code/ }
    \tl_set:Nn \l_NLN_code_name_tl { ##1 }
    \clist_map_break:
  }
  \int_gset:Nn \g_NLN_int
    { \NLN_int_use:n { \l_NLN_code_name_tl } }
  \tl_clear:N \l_NLN_info_tl
  \tl_clear:N \l_NLN_name_tl
  \tl_clear:N \l_NLN_recorded_tl
  \tl_clear:N \l_NLN_chunks_tl
  \cs_set:Npn \verbatim@processline {
    \NLN_process_record:
  }
  \NLN_if_show_code:TF {
    \exp_args:NNx
    \skip_set:Nn \parskip { \NLN_item:n { parskip } }
    \clist_if_empty:NTF \l_NLN_clist {
      \tl_gclear:N \g_NLN_chunks_tl
    } {
      \clist_set_eq:NN \l_tmpa_clist \l_NLN_clist
      \clist_sort:Nn \l_tmpa_clist {
        \str_compare:nNnTF { ##1 } > { ##2 } {
          \sort_return_swapped:
        } {
          \sort_return_same:
        }
      }
      \tl_set:Nx \l_tmpa_tl { \clist_use:Nn \l_tmpa_clist , }
      \NLN_if_show_name:T {
        \NLN_if_use_margin:T {
          \NLN_if_only_top:T {
            \tl_if_eq:NNT \l_tmpa_tl \g_NLN_chunks_tl {
              \tl_gset_eq:NN \g_NLN_chunks_tl \l_tmpa_tl
              \tl_clear:N \l_tmpa_tl
            }
          }
          \tl_if_empty:NF \l_tmpa_tl {
            \tl_set:Nx \l_NLN_chunks_tl {
              \clist_use:Nn \l_NLN_clist ,
            }
            \tl_set:Nn \l_NLN_name_tl {
              {
                \NLN_item:n { format/name }
                \l_NLN_chunks_tl :
                \hspace*{1ex}
              }
            }
          }
        }
        \tl_if_empty:NF \l_tmpa_tl {
          \tl_gset_eq:NN \g_NLN_chunks_tl \l_tmpa_tl          
        }
      }
    }
    \if_mode_vertical:
    \else:
    \par
    \fi:
    \vspace{ \NLN_item:n { sep } }
    \noindent
    \frenchspacing
    \@vobeyspaces
    \normalfont\ttfamily
    \NLN_item:n { format/code }
    \hyphenchar\font\m@ne
    \@noligs
    \NLN_if_record:F {
      \cs_set_eq:NN \NLN_process_record: \prg_do_nothing:
    }
    \NLN_if_use_minted:F {
      \NLN_if_show_lineno:T {
        \NLN_if_use_margin:TF {
          \tl_set:Nn \l_NLN_info_tl {
            \hbox_overlap_left:n {
              {
                \l_NLN_name_tl
                \NLN_item:n { format/name }
                \NLN_item:n { format/lineno }
                \int_use:N \g_NLN_int
                \int_gincr:N \g_NLN_int
              }
              \hspace*{1ex}
            }
          }
        } {
          \tl_set:Nn \l_NLN_info_tl {
            {
              \NLN_item:n { format/name }
              \NLN_item:n { format/lineno }
              \hspace*{3ex}
              \hbox_overlap_left:n {
                \int_use:N \g_NLN_int
                \int_gincr:N \g_NLN_int
              }
            }
            \hspace*{1ex}
          }
        }
      }
      \cs_set:Npn \verbatim@processline {
        \NLN_process_record:
        \hspace*{\dimexpr \linewidth-\columnwidth}%
        \hbox_to_wd:nn { \columnwidth } {
          \l_NLN_info_tl
          \the\verbatim@line
          \color{lightgray}\dotfill
        }
        \tl_clear:N \l_NLN_name_tl
        \par\noindent
      }
    }
  } {
    \@bsphack
  }
  \group_begin:
  \g_NLN_hook_tl
  \let \do \@makeother
  \dospecials \catcode `\^^M \active
  \verbatim@start
} {
  \int_gsub:Nn \g_NLN_int {
    \NLN_int_use:n { \l_NLN_code_name_tl }
  }
  \int_compare:nNnT { \g_NLN_int } > { 0 } {
    \NLN_clist_map_inline:Nnn \l_NLN_clist {
      \NLN_int_gadd:nn { ##1 } { \g_NLN_int }
    } {
      \NLN_int_gadd:nn { } { \g_NLN_int }
    }
    \int_gincr:N \g_NLN_code_int
    \tl_set:Nx \l_tmpb_tl { \int_use:N \g_NLN_code_int }
    \clist_map_inline:Nn \l_NLN_clist {
      \seq_gput_right:cV { g/NLN/chunks/##1 } \l_tmpb_tl
    }
    \prop_gput:NVV \g_NLN_code_prop \l_tmpb_tl \l_NLN_recorded_tl
  }
  \group_end:
  \NLN_if_show_code:T {
  }
  \NLN_if_show_code:TF {
    \NLN_if_use_minted:TF {
      \tl_if_empty:NF \l_NLN_recorded_tl {
        \exp_args:Nnx \setkeys { FV } {
          firstnumber=\NLN_int_use:n { \l_NLN_code_name_tl },
        }
        \iow_open:Nn \minted@code { \jobname.pyg }
        \exp_args:NNV \iow_now:Nn \minted@code \l_NLN_recorded_tl
        \iow_close:N \minted@code
        \vspace* { \dimexpr -\topsep-\parskip }
        \tl_if_empty:NF \l_NLN_info_tl {
          \tl_use:N \l_NLN_info_tl
          \skip_vertical:n { \dimexpr -\topsep-\parskip-\baselineskip }        
          \par\noindent
        }
        \exp_args:Nnx \minted@pygmentize { \jobname.pyg } { \NLN_item:n { lang } }
        %\DeleteFile { \jobname.pyg }
        \skip_vertical:n { -\topsep-\partopsep }        
      }
    } {
      \exp_args:Nx \skip_vertical:n { \NLN_item:n { sep } }
      \noindent
    }
  } {
    \@esphack
  }  
}
%    \end{macrocode}
% \begin{environment}{NLN}
% \begin{syntax}
% \cs{begin}\Arg{NLN} ... \cs{end}\Arg{NLN}
% \end{syntax}
% Private environment.
% \end{environment}
%    \begin{macrocode}
\newenvironment{NLN}{
  \def \verbatim@processline {
    \group_begin:
    \NLN_processline_code_append:
    \group_end:
  }
%  \NLN_if_show_code:T {
%    \NLN_if_use_minted:TF {
%      \Needspace* { 2\baselineskip }
%    } {
%      \frenchspacing\@vobeyspaces
%    }
%  }
} {
  \NLN_get:nNTF { lang } \l_tmpa_tl {
    \tl_if_empty:NT \l_tmpa_tl {
      \clist_map_inline:Nn \l_NLN_clist {
        \NLN_get:nnNT { ##1 } { lang } \l_tmpa_tl {
          \tl_if_empty:NF \l_tmpa_tl {
            \clist_map_break:
          }
        }
      }
      \tl_if_empty:NT \l_tmpa_tl {
        \tl_set:Nn \l_tmpa_tl { tex }
      }
    }
  } {
    \tl_set:Nn \l_tmpa_tl { tex }
  }
  \clist_map_inline:Nn \l_NLN_clist {
    \NLN_gput:nnV { ##1 } { lang } \l_tmpa_tl
  }
}
%    \end{macrocode}
% \begin{environment}{NLN.M}
% \begin{syntax}
% \cs{begin}\Arg{NLN.M} ... \cs{end}\Arg{NLN.N}
% \end{syntax}
% Private environment when \texttt{minted}.
% \end{environment}
%    \begin{macrocode}
\newenvironment{NLN_M}{
  \setkeys { FV } { firstnumber=last, }
  \clist_if_empty:NTF \l_NLN_clist {
    \exp_args:Nnx \setkeys { FV } {
      firstnumber=\NLN_int_use:n { },
  } } {
    \clist_map_inline:Nn \l_NLN_clist {
      \exp_args:Nnx \setkeys { FV } {
        firstnumber=\NLN_int_use:n { ##1 },
      }
      \clist_map_break:
  } }
  \iow_open:Nn \minted@code { \jobname.pyg }
  \tl_set:Nn \l_NLN_line_tl {
    \tl_set:Nx \l_tmpa_tl { \the\verbatim@line }
    \exp_args:NNV \iow_now:Nn \minted@code \l_tmpa_tl
  }
} {
  \NLN_if_show_code:T {
    \NLN_if_use_minted:TF {
      \iow_close:N \minted@code
      \vspace* { \dimexpr -\topsep-\parskip }
      \tl_if_empty:NF \l_NLN_info_tl {
        \tl_use:N \l_NLN_info_tl
        \vspace* { \dimexpr -\topsep-\parskip-\baselineskip }        
        \par\noindent
      }
      \exp_args:NV \minted@pygmentize \l_tmpa_tl
      \DeleteFile { \jobname.pyg }
      \vspace* { \dimexpr -\topsep -\partopsep }
    } {
      \@esphack
    }
  }
}
%    \end{macrocode}
% \begin{environment}{NLN.P}
% \begin{syntax}
% \cs{begin}\Arg{NLN.P} ... \cs{end}\Arg{NLN.P}
% \end{syntax}
% Private pseudo environment.
% This is just a practical way of declaring balanced actions.
% \end{environment}
%    \begin{macrocode}
\newenvironment{NLN_P}{
  \if_mode_vertical:
    \noindent
  \else
    \vspace*{ \topsep }
    \par\noindent
  \fi
  \NLN_gset_chunks:
  \tl_if_empty:NTF \g_NLN_chunks_tl {
    \NLN_if_show_lineno:TF {
      \NLN_if_use_margin:TF {
%    \end{macrocode}
% No chunk name, line numbers in the margin
%    \begin{macrocode}
        \tl_set:Nn \l_NLN_info_tl {
          \hbox_overlap_left:n {
            \NLN_item:n { format/code }
            {
              \NLN_item:n { format/name }
              \NLN_item:n { format/lineno }
              \clist_if_empty:NTF \l_NLN_clist {
                \NLN_int_use:n { }
              } {
                \clist_map_inline:Nn \l_NLN_clist {
                  \NLN_int_use:n { ##1 }
                  \clist_map_break:
                }
              }
            }
            \hspace*{1ex}
          }
        }
      } {
%    \end{macrocode}
% No chunk name, line numbers not in the margin
%    \begin{macrocode}
        \tl_set:Nn \l_NLN_info_tl {
          {
            \NLN_item:n { format/code }
            {
              \NLN_item:n { format/name }
              \NLN_item:n { format/lineno }
              \hspace*{3ex}
              \hbox_overlap_left:n {
                \clist_if_empty:NTF \l_NLN_clist {
                  \NLN_int_use:n { }
                } {
                  \clist_map_inline:Nn \l_NLN_clist {
                    \NLN_int_use:n { ##1 }
                    \clist_map_break:
                  }
                }
              }
              \hspace*{1ex}
            }
          }
        }        
      }
    } {
%    \end{macrocode}
% No chunk name, no line numbers
%    \begin{macrocode}
      \tl_clear:N \l_NLN_info_tl
    }    
  } {
    \NLN_if_show_lineno:TF {
%    \end{macrocode}
% Chunk names, line numbers, in the margin
%    \begin{macrocode}
      \tl_set:Nn \l_NLN_info_tl {
        \hbox_overlap_left:n {
          \NLN_item:n { format/code }
          {
            \NLN_item:n { format/name }
            \g_NLN_chunks_tl :
            \hspace*{1ex}
            \NLN_item:n { format/lineno }
            \clist_map_inline:Nn \l_NLN_clist {
              \NLN_int_use:n { ####1 }
              \clist_map_break:
            }
          }
          \hspace*{1ex}
        }
        \tl_set:Nn \l_NLN_info_tl {
          \hbox_overlap_left:n {
            \NLN_item:n { format/code }
            {
              \NLN_item:n { format/name }
              \NLN_item:n { format/lineno }
              \clist_map_inline:Nn \l_NLN_clist {
                \NLN_int_use:n { ####1 }
                \clist_map_break:
              }
            }
            \hspace*{1ex}
          }
        }
      }
    } {
%    \end{macrocode}
% Chunk names, no line numbers, in the margin
%    \begin{macrocode}
      \tl_set:Nn \l_NLN_info_tl {
        \hbox_overlap_left:n {
          \NLN_item:n { format/code }
          {
            \NLN_item:n { format/name }
            \g_NLN_chunks_tl :
          }
          \hspace*{1ex}
        }
        \tl_clear:N \l_NLN_info_tl
      }
    }
  }
  \NLN_if_use_minted:F {
    \tl_set:Nn \l_NLN_line_tl {
      \noindent
      \hbox_to_wd:nn { \textwidth } {
        \tl_use:N \l_NLN_info_tl
        \NLN_item:n { format/code }
        \the\verbatim@line        
        \hfill
      }
      \par
    }
    \@bsphack
  }
} {
  \vspace*{ \topsep }
  \par
  \@esphack
}
%    \end{macrocode}
% \section{\cs{InlineExport}}
% \begin{function}{\InlineExport}
% \begin{syntax}
% \cs{InlineExport}\marg{key[=value] list}
% \end{syntax}
% The \texttt{\meta{key}[=\meta{value}]} items are defined by
% \end{function}
%
% \subsection{\texttt{NLN/export} key-value controls}
%    \begin{macrocode}
\keys_define:nn { } { NLN/export .inherit:n = NLN/code }
\keys_define:nn { NLN/export } {
%    \end{macrocode}
% \begin{description}
% \item[file] the output file name
%    \begin{macrocode}
  file .tl_set:N = \l_NLN_tl,
  file .value_required:n = true,
%    \end{macrocode}
% \item[\ttfamily preamble] the added preamble.
%    \begin{macrocode}
  preamble .code:n = \prop_put:Nnn \l_NLN_vars { preamble } { #1 },
%    \end{macrocode}
% \item[\ttfamily raw] to remove any additional material, 
%    \begin{macrocode}
  raw .code:n = \prop_put:Nnn \l_NLN_vars { raw } { #1 },
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  unknown .code:n = \PackageWarning
    { NLN/export }
    { Unknown~option~`\l_keys_key_str' },
}
%    \end{macrocode}
% 
% \subsection{Implementation}
%    \begin{macrocode}
\DeclareDocumentCommand \InlineExport { m } {
  \group_begin:
  \clist_clear:N \l_NLN_clist
  \prop_clear:c { g/NLN/code/ }
  \prop_put:cnn { g/NLN/code/ } { lang } { tex }
  \keys_set:nn { NLN/export } { #1 }
  \prop_gput:NVV \g_NLN_export_prop \l_NLN_tl \l_NLN_clist
  \prop_gput:cnV { g/NLN/export/\l_NLN_tl } { chunks } \l_NLN_clist
  \prop_gput:cnx { g/NLN/export/\l_NLN_tl } { preamble }
    { \prop_item:Nn \l_NLN_vars { preamble } }
  \bool_set:Nx \l_tmpa_bool { \prop_item:Nn \l_NLN_vars { raw } }
  \prop_gput:cnV { g/NLN/export/\l_NLN_tl } { preamble } \l_tmpa_bool
  \NLN_get:nNT { lang } \l_tmpa_tl {
    \clist_map_inline:Nn \l_NLN_clist {
      \prop_gconcat:ccc
        { g/NLN/code/##1 }
        { g/NLN/code/##1 }
        { g/NLN/code/ }
    }
  }
  \group_end:
}
%    \end{macrocode}
% Files are created at the end of the typesetting process.
%    \begin{macrocode}
\AddToHook { enddocument / end } {
  \group_begin:
  \prop_map_inline:Nn \g_NLN_export_prop {
    \iow_open:Nn \l_NLN_out { #1 }
    \iow_term:x { Exporting~chunks~#2~to~#1 }
    \prop_get:cnNF { g/NLN/export/#1 } { raw } \l_tmpa_bool {
      \bool_set_false:N \l_tmpa_bool
    }
    \bool_if:NF \l_tmpa_bool {
      \prop_get:cnNT { g/NLN/export/#1 } { preamble } \l_tmpa_tl {
        \prop_get:cnNF { g/NLN/export/#1 } { lang } \l_tmpa_str {
          \str_set:Nn \l_tmpa_str { tex }
        }
        \prop_get:NVNTF \c_NLN_comment_prop \l_tmpa_str \l_tmpa_str {
          \tl_set:Nn \l_tmpb_tl {
            \l_tmpa_str\l_tmpa_str\space\space
          }
        } {
          \tl_clear:N \l_tmpb_tl
        }
        \tl_put_right:Nx \l_tmpb_tl {
          This~is~file~`#1'~
          generated~from~`\c_sys_jobname_str.tex'~on~\DTMnow.
        }
        \iow_now:Nx \l_NLN_out { \l_tmpb_tl }
        \iow_now:Nx \l_NLN_out { \l_tmpa_tl }
      }
    }
    \clist_map_inline:nn { #2 } {
      \NLN_get:nnNT { ##1 } { .code } \l_tmpa_tl {
        \exp_args:NNV \iow_now:Nn \l_NLN_out \l_tmpa_tl
      }
    }
    \iow_close:N \l_NLN_out
  }
  \group_end:
}
%    \end{macrocode}
%
%
% \section{Management}
% \begin{variable}{\g_NLN_in_impl_bool}
% Whether we are currently in the implementation section.
%    \begin{macrocode}
\bool_new:N \g_NLN_in_impl_bool
%    \end{macrocode}
% \end{variable}
% \begin{function}[TF]
%   {\NLN_if_show_code:}
%   \begin{syntax}
%     \cs{NLN_if_show_code:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when code should be printed, \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_if_show_code: { T, F, TF } {
  \bool_if:nTF {
    \g_NLN_in_impl_bool && !\g_NLN_with_impl_bool
  } {
    \prg_return_false:
  } {
    \prg_return_true:
  }
}
%    \end{macrocode}
% \end{function}
%
% \begin{variable}{\g_NLN_with_impl_bool}
%    \begin{macrocode}
\bool_new:N \g_NLN_with_impl_bool
%    \end{macrocode}
% \end{variable}
%
% \section{All purpose messaging}
%    \begin{macrocode}
%    \end{macrocode}
%
% \section{\texttt{minted} and \texttt{pygment}}
% \begin{variable}{\g_NLN_minted_on_bool}
% Whether minted is available, initially set to \texttt{false}.
%    \begin{macrocode}
\bool_new:N \g_NLN_minted_on_bool
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLN_use_minted_bool}
% Whether minted is used, initially set to \texttt{false}.
%    \begin{macrocode}
\bool_new:N \g_NLN_use_minted_bool
%    \end{macrocode}
% \end{variable}
% \begin{function}[TF]
%   {\NLN_if_use_minted:}
%   \begin{syntax}
%     \cs{NLN_if_use_minted:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when using |minted|, \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_if_use_minted: { T, F, TF } {
  \bool_if:NTF \g_NLN_use_minted_bool
    { \prg_return_true:  }
    { \prg_return_false: }
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}[TF]
%   {\_NLN_if_pygmentize:}
%   \begin{syntax}
%     \cs{NLN_if_pygmentize:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when \texttt{pygmentize} is available,
% \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn\_NLN_if_pygmentize: { T, F, TF } {
  \group_begin:
  \sys_get_shell:nnN {which~pygmentize} {} \l_tmpa_tl
  \tl_if_empty:NTF \l_tmpa_tl {
    \tl_set:Nn \l_tmpa_tl { \prg_return_false: }
  } {
    \tl_set:Nn \l_tmpa_tl { \prg_return_true: }
  }
  \exp_last_unbraced:NV
  \group_end: \l_tmpa_tl
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\_NLN_minted_on:}
% \begin{syntax}
% \cs{_NLN_minted_on:}
% \end{syntax}
% Private function. During the preamble, loads \pkg{minted},
% sets \cs{g_NLN_minted_on_bool} to \texttt{true} and prepares \texttt{pygment} processing.
% \end{function}
%    \begin{macrocode}
\cs_set:Npn \_NLN_minted_on: {
  \directlua{NLN.make_directory("_pygmented")}
  \bool_gset_true:N \g_NLN_minted_on_bool
  \RequirePackage{minted}
  \setkeys{ minted@opt@g } { linenos=false }
  \minted@def@opt{post~processor}
  \minted@def@opt{post~processor~args}
  \pretocmd\minted@inputpyg{
    \NLN@postprocesspyg {\minted@outputdir\minted@infile}
  }{}{\fail}  
%    \end{macrocode}
% In the execution context of \cs{minted@inputpyg},
% \begin{description}
% \item[\texttt{\#1}] is the name of the python script, e.g., ``\texttt{process.py}''
% \item[\texttt{\#2}] is the input ``.pygtex'' file ``\cs{minted@outputdir}\cs{minted@infile}''
% \item[\texttt{\#3}] are more args passed to the python script, possibly empty
% \end{description}
%    \begin{macrocode}
  \newcommand{\NLN@postprocesspyg}[1]{%
    \group_begin:
    \tl_set:Nx \l_tmpa_tl {\NLN_item:n { post_processor } }
    \tl_if_empty:NF \l_tmpa_tl {
%    \end{macrocode}
% Execute \texttt{`python3 <script.py> <file.pygtex> <more_args>`}
%    \begin{macrocode}
      \tl_set:Nx \l_tmpb_tl {\NLN_item:n { post_processor_args } }
      \exp_args:Nx
      \sys_shell_now:n {
        python3\space
        \l_tmpa_tl\space
        ##1\space
        \l_tmpb_tl
      }  
    }
    \group_end:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
%\AddToHook { begindocument / end } {
%  \cs_set_eq:NN \_NLN_minted_on: \prg_do_nothing:
%}
%    \end{macrocode}
% Utilities to setup |pygment| post processing.
% The |pygment| post processor marks some code with \cs{InlineEmph}.
%    \begin{macrocode}
\ProvideDocumentCommand{\InlineEmph}{m}{\textcolor{red}{#1}}
%    \end{macrocode}
%
% \begin{function}{\InlineStorePreamble}
% \begin{syntax}
% \cs{InlineStorePreamble} \marg{variable} \marg{file name}
% \end{syntax}
% Store the content of \meta{file name} into the variable \meta{variable}.
% \end{function}
%
% \section{Separators}
% \begin{function}{\InlineImplementation}
% \begin{syntax}
% \cs{InlineImplementation}
% \end{syntax}
% Start an implementation part where all the sectioning commands do nothing.
% \end{function}
% \begin{function}{\InlineFinale}
% \begin{syntax}
% \cs{InlineFinale}
% \end{syntax}
% Stop an implementation part.
% \end{function}
% \section{Finale}
%    \begin{macrocode}
\DeclareDocumentCommand \InlineStorePreamble { m m } {
  \group_begin:
  \msg_info:nnn
    { inline }
    { :n }
    { Reading~preamble~from~file~"#2". }
  \tl_clear:N \g_tmpa_tl
  \tl_clear:N \g_tmpb_tl
  \ior_open:Nn \l_NLN_in { #2 }
  \bool_until_do:nn { \ior_if_eof_p:N \l_NLN_in } {
    \ior_str_get:NN \l_NLN_in \l_tmpa_tl
    \tl_if_empty:NTF \l_tmpa_tl {
      \tl_put_right:Nn \g_tmpb_tl { \iow_newline: }
    } {
      \tl_put_right:Nx \g_tmpa_tl { \g_tmpb_tl }
      \tl_set:Nn \g_tmpb_tl { \iow_newline: }
      \tl_put_right:NV \g_tmpa_tl \l_tmpa_tl
    }
  }
  \ior_close:N \l_NLN_in
  \exp_args:NNNx
  \group_end:
  \tl_set:Nn #1 { \tl_to_str:N \g_tmpa_tl }
}
\newcounter{NLN@impl@page}
\DeclareDocumentCommand \InlineImplementation {} {
  \bool_if:NF \g_NLN_with_impl_bool {
    \clearpage
    \bool_gset_true:N \g_NLN_in_impl_bool
    \let\NLN@old@part\part
    \DeclareDocumentCommand\part{som}{}
    \let\NLN@old@section\section
    \DeclareDocumentCommand\section{som}{}
    \let\NLN@old@subsection\subsection
    \DeclareDocumentCommand\subsection{som}{}
    \let\NLN@old@subsubsection\subsubsection
    \DeclareDocumentCommand\subsubsection{som}{}
    \let\NLN@old@paragraph\paragraph
    \DeclareDocumentCommand\paragraph{som}{}
    \let\NLN@old@subparagraph\subparagraph
    \DeclareDocumentCommand\subparagraph{som}{}
    \cs_if_exist:NT \refsection{ \refsection }
    \setcounter{ NLN@impl@page }{ \value{page} }
  }
}
\DeclareDocumentCommand\InlineFinale {} {
  \bool_if:NF \g_NLN_with_impl_bool {
    \clearpage
    \bool_gset_false:N \g_NLN_in_impl_bool
    \let\part\NLN@old@part
    \let\section\NLN@old@section
    \let\subsection\NLN@old@subsection
    \let\subsubsection\NLN@old@subsubsection
    \let\paragraph\NLN@old@paragraph
    \let\subparagraph\NLN@old@subparagraph
    \setcounter { page } { \value{ NLN@impl@page } }
  }
}
\cs_set_eq:NN \NLN_line_number: \prg_do_nothing:
%    \end{macrocode}
% \section{Finale}
%    \begin{macrocode}
\AddToHook { cmd/FancyVerbFormatLine/before } {
  \NLN_line_number:
}
\AddToHook { shipout/before } {
  \tl_gclear:N \g_NLN_chunks_tl
}
\InlineSet {}
%    \end{macrocode}
%    \begin{macrocode}
%</package>
%    \end{macrocode}
% \end{implementation}
%\Finale
%
% % ^^A \PrintIndex
