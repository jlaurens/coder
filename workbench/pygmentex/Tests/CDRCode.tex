% !TeX program=lualatex
% !TeX root=../coder_test.tex
\noindent

\newfontfamily\CDRVerbatimFont{TeX Gyre Cursor}[NFSSFamily=CDRVerbatimFont]
\newfontfamily\CDRMenloFont{Menlo}[NFSSFamily=Menlo]

\ExplSyntaxOn
\cs_new:Npn \CDR_process_line_code_append: { CDR_processline_code_append: }
\ExplSyntaxOff

\subsection{Fancyvrb basics}

\ExplSyntaxOn
\group_begin:

\cs_new:Npn \CDRVerbA #1 {
  \DefineShortVerb{#1}
  \SaveVerb[aftersave={\UndefineShortVerb{#1}},]{Verb}#1
}


\CDRVerbA!ABCD!



ABCDE
\UseVerb{Verb}

\group_end:
\ExplSyntaxOff

\begin{Verbatim}[
%  fontshape=b,
  fontfamily=CDRVerbatimFont,%tt,%helvetica, courier
  fontseries=b,
  fontsize=\large,
  showspaces=true,
  showtabs=true,
  tabsize=4,
  reflabel=verb0
]
First verba	tim line.
Second verbatim line.
\end{Verbatim}
See the verbatim on page~\pageref{verb0}
\\
\DefineShortVerb{\?}%
YYY%
\SaveVerb{ABC}?XXX?%
\UndefineShortVerb{\?}
\fvset{
fontfamily=Menlo,
fontshape=it,
fontseries=auto,
fontsize=\Large,
}%
\UseVerb{ABC}%
YYY
\CDRSet{pygments=false}

\subsection{Coder}

\ExplSyntaxOn
\group_begin:

\CDRCode!<ABC DEF>!\\
1\\
\CDRCode[fontfamily=Menlo]!<fontfamily=Menlo>!\\
2\\
\CDRCode[showspaces=true]!<showspaces = true>!\\
3\\
\CDRCode[fontsize=\Large]|<fontsize=\Large>|\\
4\\
\group_begin:
\cs_set:Npn \PackageError #1 #2 #3 {
\tl_to_str:n{\PackageError} #1\\
\exp_args:Ne \tl_to_str:n{#2}\\
\exp_args:Ne \tl_to_str:n{#3}\\
}
Expecting\space ERROR:\\
\CDRCode[engine=flower]|<engine=flower>|\\
\group_end:
5\\
\CDRNewCodeEngine{wave}{wavy(#2)}
\CDRCode[engine=wave]|<engine=wave>|\\
LAST\\
\CDRCode|<THIS IS THE LAST!!!>|\\
%
%\CDRCode|ABC DEF GHI|

\group_end:
\cs_set:Npn \CDR_apply_code_engine:n {
  \str_set:Nx \l_CDR_str { \CDR_tag_get:c { engine } }
  \CDR_if_code_engine:VF \l_CDR_str {
    \PackageError
      { coder }
      { \l_CDR_str\space code~engine~unknown,~replaced~by~'default' }
      {See~\CDRNewCodeEngine~in~the~coder~manual}
    \str_set:Nn \l_CDR_str { default }
  }
  \exp_args:Nnx
  \use:c { \CDR_code_engine:V \l_CDR_str }
    { \CDR_tag_get:c { \l_CDR_str~engine~options } }
}

\cs_set:Npn \CDR_code:n #1 {
  \CDR_tag_inherit:cx { __local } {
    \tl_if_empty:NF \l_CDR_tag_tl { \l_CDR_tag_tl, }
    __code, default.code, default, __pygments, __fancyvrb,
  }
  \clist_clear:N \l_CDR_options_clist
  \CDR_feed_options_clist:N \l_CDR_options_clist
  \CDR_if_truthy:eTF { \CDR_tag_get:c {pygments} } {
    \PackageWarning
      { coder }
      { pygments~unsuported }
    \DefineShortVerb { #1 }
    \SaveVerb [
      aftersave = {
        \UndefineShortVerb { #1 }
        %\lua_now:n {CDR:hilight_code('FV@SV@CDR@Code')}
        \CDR_code_fvset:
        \CDR_apply_code_engine:n { \UseVerb { CDR@Code } }
        \group_end:
      }
    ] { CDR@Code } #1
  } {
    \DefineShortVerb { #1 }
    \SaveVerb [
      aftersave = {
        \UndefineShortVerb { #1 }
        \CDR_code_fvset:
        \CDR_apply_code_engine:n { \UseVerb { CDR@Code } }
        \group_end:
      }
    ] { CDR@Code } #1
  }
}
\RenewDocumentCommand \CDRCode { O{} } {
  \group_begin:
  \prg_set_conditional:Nnn \CDR_if_block: { p, T, F, TF } {
    \prg_return_false:
  }  
  \CDR_keys_inherit:Vnn \c_CDR_tag { __local } {
    __pygments, default.code, default, __fancyvrb, __fancyvrb.all
  }
  \CDR_tag_keys_set_known:nnN { __local } { #1 } \l_CDR_keyval_tl
  \CDR_tag_provide_from_keyval:V \l_CDR_keyval_tl
  \exp_args:NnV
  \CDR_tag_keys_set:nn { __local } \l_CDR_keyval_tl
  \CDR_code:n
}
\ExplSyntaxOff


\subsection{With pygments}

\begin{luacode}

tex.print('python=='..CDR.PYTHON_PATH)

local json = _ENV.utilities.json
local lfs   = _ENV.lfs


function CDR:hilight_set(key, var)
  local args = self['.arguments']
  local t = args
  if t[key] == nil then
    t = args.pygopts
    assert(t[key] ~= nil)
  end
  t[key] = assert(token.get_macro(var or 'l_CDR_tl'))
end

function CDR:hilight_prepare()
  self['.arguments'] = {
    __cls__ = 'Arguments',
    code = '',
    pygopts = {
      __cls__ = 'PygOpts',
      lang = 'tex',
      style = 'default'
    }
  }
end

CDR.hilight_code = function(self)
  local args = self['.arguments']
  print(self.json_p)
  print("json=="..json.tostring(args, true))
  local json_p = self.json_p
  local f = assert(io.open(json_p, 'w'))
  local ok, err = f:write(json.tostring(args, true))
  f:close()
  if ok == nil then
    print('File error('..json_p..'): '..err)
  end
  print(self.CDR_PY_PATH)
  print(self.PYTHON_PATH)
  local cmd = ('%s %s %q'):format(
    self.PYTHON_PATH,
    self.CDR_PY_PATH,
    json_p
  )
  print(cmd)
  local o = io.popen(cmd):read('a')
  print(o)
  self:load_exec_output(o)
end

CDR.cache_clean_unused = function (self)
end

function CDR:set_template(name, macro_name)
  local t = self['.templates'] or {}
  self['.templates'] = t
  t[name] = assert(token.get_macro(assert(macro_name)))
  print("TEMPLATE:"..name.."=<<<"..t[name]..">>>")
end

function CDR:get_template(name)
  print([[get template named: ]]..name)
  return self['.templates'][name]
end

\end{luacode}


\CDRSet{python path=/usr/bin/python}
PATH==\directlua{tex.print(CDR.PYTHON_PATH)}\\
\CDRSet{python path=}
PATH==\directlua{tex.print(CDR.PYTHON_PATH)}\\

%  texopts.white_line_template = [[<placeholder:line>]]
%  texopts.black_line_template = [[
%    \CDR@Number{<placeholder:number>}<placeholder:line>]]
%  texopts.single_line_template = [[\CDR@Number{<placeholder:number>}<placeholder:line>]]
%  texopts.first_line_template = [[<placeholder:line>]]
%  texopts.second_line_template = [[<placeholder:line>]]
%  config['texopts'] = texopts
%  local fv_opts = {
%    ['__cls__'] = 'FVOpts'
%  }
%  config['fv_opts'] = fv_opts
%  local pyg_opts = {
%    ['__cls__'] = 'PygOpts'
%  }
%  config['pyg_opts'] = pyg_opts

\ExplSyntaxOn

\CDR_has_pygments:TF {
  PYGMENTS~TEST\\
} {
  NO~PYGMENTS~TEST
  \ExplSyntaxOff
  \endinput
}

\group_begin:
\CDRSet{pygments=true}

\makeatletter

% \begin{function}{\CDR@StyleDefine}
% \begin{syntax}
% \cs{CDR@StyleDefine} \Arg{pygments style name} \Arg{definitions}
% \end{syntax}
% Define the definitions for the given \metatt{pygments style name}.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDR@StyleDefine #1 {
  STYLE~DEFINED: #1\\
  \tl_gset:cn { g_CDR@StyleDefs_#1 }
}
%    \end{MacroCode}
% \begin{function}{\CDR@StyleUse}
% \begin{syntax}
% \cs{CDR@StyleUse} \Arg{pygments style name}
% \end{syntax}
% Use the definitions for the given \metatt{pygments style name}. No safe check is made.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDR@StyleUse #1 {
  \tl_use:c { g_CDR@StyleDefs_#1 }
}
%    \end{MacroCode}

\cs_set:Npn \CDR_code:n #1 {
  \CDR_tag_inherit:cx { __local } {
    \tl_if_empty:NF \l_CDR_tag_tl { \l_CDR_tag_tl, }
    __code, default.code, default, __pygments, __fancyvrb,
  }
  \clist_clear:N \l_CDR_options_clist
  \CDR_feed_options_clist:N \l_CDR_options_clist
  \CDR_if_truthy:eTF { \CDR_tag_get:c {pygments} } {
    \PackageWarning
      { coder }
      { pygments~suport~IN~PROGRESS }
    \DefineShortVerb { #1 }    
    \SaveVerb [
      aftersave = {
        \UndefineShortVerb { #1 }
        \lua_now:n { CDR:hilight_prepare() }
        \CDR_tag_get:cN {style} \l_CDR_tl
        \lua_now:n { CDR:hilight_set('style') }
        \CDR_tag_get:cN {lang} \l_CDR_tl
        \lua_now:n { CDR:hilight_set('lang') }
        \lua_now:n { CDR:hilight_set('code', 'FV@SV@CDR@Code') }
        \lua_now:n { CDR:hilight_code() }
        \CDR_code_fvset:
        \CDR_apply_code_engine:n { PYGMENTS:\UseVerb { CDR@Code } }
        \group_end:
      }
    ] { CDR@Code } #1
  } {
    \DefineShortVerb { #1 }
    \SaveVerb [
      aftersave = {
        \UndefineShortVerb { #1 }
        \CDR_code_fvset:
        \CDR_apply_code_engine:n { FANCYVRB:\UseVerb { CDR@Code } }
        \group_end:
      }
    ] { CDR@Code } #1
  }
}
\makeatother

\CDRSet{pygments=false}
ABCD=\CDRCode|ABCD|\\
\CDRSet{pygments=true}
ABCD=\CDRCode|ABCD|\\

\group_end:
\ExplSyntaxOff
