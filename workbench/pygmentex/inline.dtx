% \iffalse meta-comment
% !TEX program  = lualatex
% !TEX encoding  = utf8
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
inline --- description text
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

Some text about the package: probably the same as the abstract.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\def\fileversion{v0.1a}
\def\filedate{2022/02/06}
\def\MetaPrefix{}
\declarepreamble\PreambleRaw
----------------------------------------------------------------
\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/inline
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\def\MetaPrefix{--}
\declarepreamble\PreambleLua

\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/inline
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt

\endpreamble
{
\catcode`\#=11
\global\def\MetaPrefix{#}
}
\declarepreamble\PreamblePy

\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/inline
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt

\endpreamble

\edef\PreamblePy {%
\MetaPrefix!/usr/bin/env python3^^J\MetaPrefix\space -*- coding: utf-8 -*-^^J\PreamblePy
}

\def\MetaPrefix{\DoubleperCent}
\declarepreamble\PreambleSty
\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later

Copyright (C) 2022 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  \jobname.dtx
and the derived files           \jobname.ins,
                                \jobname.pdf,
                                \jobname-helper.lua,
                                \jobname-helper.py and
                                \jobname.sty.

\endpreamble
\nopostamble
\usedir{tex/latex/inline}
\usepreamble\PreambleSty
\def\MetaPrefix{\DoubleperCent}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{sty}}
}
\usepreamble\PreambleLua
\def\MetaPrefix{--}
\usedir{scripts/inline}
\generate{
  \file{\jobname-helper.x.lua}{\from{\jobname.dtx}{lua}}
}
\generate{
  \file{\jobname-helper.lua}{\from{\jobname.dtx}{lua}}
}
\usepreamble\PreamblePy
{
\catcode`\#=11
\global\def\MetaPrefix{#}
}
\usedir{scripts/inline}
\generate{
  \file{\jobname-helper.x.py}{\from{\jobname.dtx}{py}}
}
\generate{
  \file{\jobname-helper.py}{\from{\jobname.dtx}{py}}
}
\nopreamble\nopostamble
\usedir{doc/latex/inline}
\generate{
  \file{README.md}{\from{\jobname.dtx}{readme}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/inline}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
% \def\fileversion{v1.0}
% \def\filedate{2009/10/06}
%<*sty>
\def\fileversion{v1.0}
\def\filedate{2009/10/06}

\RequirePackage{fancyvrb}
\RequirePackage{color}
\RequirePackage{ifthen}
%\RequirePackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}
%\RequirePackage{caption}
\RequirePackage{pgfkeys}
\RequirePackage{efbox}
\RequirePackage[framemethod=tikz]{mdframed}

%\DeclareCaptionType[within=chapter]{pygcode}[Listagem][Lista de listagens]
%\DeclareCaptionType{pygcode}[Listagem][Lista de listagens]
%\captionsetup[pygcode]{position=top}

\RequirePackage{luacode, needspace, xcolor, verbatim}
\AddToHook { begindocument / before } {
  \RequirePackage{datetime2}
}
\def\NLNFileVersion{1.0a}
\def\NLNFileDate{2022/02/07}
%</sty>
%<*driver>
\def\NLNFileVersion{1.0a}
\def\NLNFileDate{2022/02/07}
%</driver>
%<*sty>
\ProvidesExplPackage{inline}
  {\NLNFileDate}
  {\NLNFileVersion}
  {code inlined in documents}

\NeedsTeXFormat{LaTeX2e}

\msg_new:nnn { inline } { :n } { #1 }
\cs_if_exist:NTF\IfFormatAtLeastTF {
  \IfFormatAtLeastTF{2021/06/01} {} {
    \msg_fatal:nnn { inline } { :n } { Please~update~LaTeX.~Emergency~stop }
  }
} {
  \msg_fatal:nnn { inline } { :n } { Please~update~LaTeX.~Emergency~stop }
}
\ExplSyntaxOff
\directlua{NLN = require("inline.lua")}
\ExplSyntaxOn
%</sty>
%<*driver>
\ExplSyntaxOff
\documentclass{l3doc}\def\NLNFileVersion{1.0a}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\newcommand{\NLNSty}{\texttt{\jobname.sty}}
\newcommand{\NLNLua}{\texttt{\jobname-helper.lua}}
\newcommand{\NLNPy}{\texttt{\jobname-helper.py}}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%\GetFileInfo{\jobname.sty}
%
%\title{^^A
%  \textsf{inline} --- code inlined in a \LaTeX\ document\thanks{^^A
%    This file describes version \NLNFileVersion, last revised \NLNFileDate.^^A
%  }^^A
%}
%\author{^^A
%  Jérôme LAURENS\thanks{E-mail: jerome.laurens@u-bourgogne.fr}^^A
%}
%\date{Released \NLNFileDate}
%
%\maketitle
%
% \begin{documentation}
%
%\changes{v1.0a}{2022/01/20}{First public release}
%
% \begin{abstract}
% Usually, documentation is put inside the code,
% \pkg{inline} allows to work the other way round
% by putting code inside the documentation.
% This is particularly interesting when different code files share some logic
% and should be documented all at once.
%
% The file \texttt{inline-manual} gives different examples. Here is the implementation of the package.
%
% This \LaTeX{} package requires \LuaTeX{} and may use syntax coloring based on \pkg{pygment}.
% \end{abstract}
%
% \section{Package dependencies}
% \pkg{luacode}, \pkg{verbatim}, \pkg{datetime2}, \pkg{xcolor}, \pkg{fancyvrb} and dependencies of these packages.
% \section{Similar technologies}
% \begin{description}
% \item The \pkg{docstrip} utility offers similar features,
% it is somehow more powerful than \pkg{inline} at the cost of
% more technicality and less practicality,
% \item The \pkg{ydoc.cls} and \pkg{skdoc.cls} are
% full document classes with similar features but
% many more that are unrelated.
% \pkg{inline} focuses on code inlining and interfaces well with \pkg{pygment}
% for a smart syntax hilighting.
% \end{description}
%
% \section{Known bugs and limitations}
% \begin{itemize}
% \item
% \pkg{inline} does not play well with \pkg{docstrip}.
% \end{itemize}
%
% \end{documentation}
% 
% \begin{implementation}
%
% \section{Presentation}
% \pkg{\jobname} is a triptych of three components
% \begin{enumerate}
% \item \NLNSty
% \item \NLNLua
% \item \NLNPy
% \end{enumerate}
% \NLNSty{} mainly declares \cs{NLNCode} command and \texttt{NLN/Code} environment.
% The former allows to insert code chunks as running text whereas the latter allows
% to instert code snippets as blocks. Moreover, the blocks can be exported to files.
% 
% The normal code flow is
% \begin{enumerate}
% \item with \NLNSty{}, \LaTeX{} parses a code snippet, store it in \cs{l_NLN_snippet_tl},
% and calls either |NLN:process_run| or |NLN:process_block|,
% \item \NLNLua{} reads the content of some command, and store it in a |json| file,
% together with informations to process this code snippet properly,
% \item \NLNPy{} is asked by \NLNLua{} to read the |json| file and uses \pkg{pygment} to translate
% the code snippet into dedicated \LaTeX{} commands. These are stored in a |.pyg.tex| file
% named after the md5 digest of the original code chunck,
% a |.pyg.tex| \LaTeX{} style file is recorded as well.
% On return, \NLNPy{} gives to \NLNLua{} some \LaTeX{} macros to both input the |.pyg.sty| and
% the |.pyg.tex| file, these are finally executed and the code is displayed with colors.
% \end{enumerate}
%
% \part{\NLNLua{} implementation}
% \section{Usage}
% This \texttt{lua} library is loaded by \NLNSty{}
% with the instruction \texttt{NLN=require("inline-helper")}.
% In the sequel, the syntax to call class methods and instance methods are
% presented with either a \texttt{NLN.} or a \texttt{NLN:} prefix.
% Of course either a \texttt{self.} or a \texttt{self:} prefix would be possible,
% this is what is used in the library for cenveniency.
% \section{Declarations}
%    \begin{macrocode}
%<*lua>
local rep  = string.rep
local lpeg = require("lpeg")
local P, Cg, Cp, V = lpeg.P, lpeg.Cg, lpeg.Cp, lpeg.V
local lfs  = require("lfs")
local tex  = require("tex")
require("lualibs.lua")
local json = _ENV.utilities.json
local jobname = token.get_macro('jobname')
%    \end{macrocode}
% \section{General purpose material}
% \begin{variable}{NLN_PY_PATH}
% Location of the \NLNPy{} utility.
%    \begin{macrocode}
local NLN_PY_PATH = io.popen([[kpsewhich inline-helper.py]]):read('a'):match("^%s*(.-)%s*$")
%    \end{macrocode}
% \end{variable}
% \begin{function}{escape}
% \begin{syntax}
% <variable> = NLN.escape(<string>)
% \end{syntax}
% Escape the given string. NEVER USED?
% \end{function}
%    \begin{macrocode}
local function escape(s)
    s = s:gsub('\\','\\\\')
    s = s:gsub('\r','\\r')
    s = s:gsub('\n','\\n')
    s = s:gsub('"','\\"')
    return s
end
%    \end{macrocode}
% \begin{function}{make_directory}
% \begin{syntax}
% <variable> = NLN.make_directory(<string path>)
% \end{syntax}
% Make a directory at the given path.
% \end{function}
%    \begin{macrocode}
local function make_directory(path)
  local mode,_,__ = lfs.attributes(path,"mode")
  if mode == "directory" then
    return true
  elseif mode ~= nil then
    return nil,path.." exist and is not a directory",1
  end
  if os["type"] == "windows" then
    path = path:gsub("/", "\\")
    _,_,__ = os.execute(
      "if not exist "  .. path .. "\\nul " .. "mkdir " .. path
    )
  else
    _,_,__ = os.execute("mkdir -p " .. path)
  end
  mode = lfs.attributes(path,"mode")
  if mode == "directory" then
    return true
  end
  return nil,path.." exist and is not a directory",1
end
local dir_p, json_p = './'..jobname..'.pygd/'
if make_directory(dir_p) == nil then
  dir_p = './'
  json_p = dir_p..jobname..'.pyg.json'
else
  json_p = dir_p..'input.pyg.json'
end
%    \end{macrocode}
% \begin{function}{load_exec}
% \begin{syntax}
% NLN.load_exec(\meta{code chunk})
% \end{syntax}
% Class method. Loads the given \meta{code chunk} and execute it.
% On error, messages are printed.
% \end{function}
%    \begin{macrocode}
local function load_exec(chunk)
  local func, err = load(chunk)
  if func then
    local ok, err = pcall(func)
    if not ok then
      print("inline-helper.lua Execution error:", err)
      print('chunk:', chunk)
    end
  else
    print("inline-helper.lua Compilation error:", err)
    print('chunk:', chunk)
  end
end
%    \end{macrocode}
% \begin{function}{safe_equals}
% \begin{syntax}
% <variable> = NLN.safe_equals(<string>)
% \end{syntax}
% Class method.
% Returns an \meta{=...=} string exactly composed of sufficently many \texttt{=} signs
% such that \meta{string} contains neither sequence \texttt{[\meta{=...=}[}
% nor \texttt{]\meta{ans}]}.
% \end{function}
%    \begin{macrocode}
local eq_pattern = P({ Cp() * P('=')^1 * Cp() + 1 * V(1) })
local function safe_equals(s)
  local i, j = 0
  local max = 0
  while true
    j, i = eq_pattern:match(s, i)
    if j == nil then
      return rep('=', max + 1)
    end
    j = i - j
    if j > max then
      max = j
    end
  end
end
%    \end{macrocode}
% \begin{function}{options_reset,option_add}
% \begin{syntax}
% NLN:options_reset()
% NLN:option_add(\meta{string key},\meta{json value})
% \end{syntax}
% Instance method. The extra options used for formatting are collected, then forwarded to
% \NLNPy{} utility through its JSON input, with key |options|.
% First we have to clear the option list with |options_reset| before any call to |option_add|.
% \end{function}
%    \begin{macrocode}
local function options_reset(self)
  self.options = {}
end
local function option_add(self,k,v)
  self.options[k] = v
end
%    \end{macrocode}
% \begin{function}{start_recording}
% \begin{syntax}
% NLN:start_recording()
% \end{syntax}
% Instance method. In progress.
% \end{function}
%    \begin{macrocode}
local function start_recording(self)
  self.records = {}
  function self.records.append (t,v)
    t[#t+1]=v
    return t
  end
end
%    \end{macrocode}
% \begin{function}{load_exec_output}
% \begin{syntax}
% NLN:load_exec_output(\meta{code chunk})
% \end{syntax}
% Instance method to parse the \meta{code chunk} sring for commands and execute them.
% The patterns being searched are enclosed within opening |<<<<<| and closing |>>>>>|,
% each containing 5 characters,
% \begin{description}
% \item[\texttt{?TEX}:\meta{TeX instructions}] the \meta{TeX instructions} are executed
% asynchronously once the control comes back to \TeX{}.
% \item[\texttt{!LUA}:\meta{!Lua instructions}] the \meta{!Lua instructions} are executed
% synchronously. When not properly designed, these instruction may cause a
% forever loop on execution, for example, they must not use \texttt{NLN:process_run}.
% \item[\texttt{?LUA}:\meta{?Lua instructions}] these \meta{?Lua instructions} are executed
% asynchronously once the control comes back to \TeX{} through a call to \cs{directlua},
% which means that they will wait until any previous asynchronous \meta{?TeX instructions}
% or \meta{?Lua instructions} completes.
% \end{description}
% \end{function}
%    \begin{macrocode}
local parse_pattern
do
  local tag = P('?TEX') + '!LUA' + '?LUA'
  local end = '>>>>>'
  local cmd = P(1)^0 - end
  parse_pattern = P({
    '<<<<<' * Cg(tag - ':') * ':' * Cg(cmd) * end * Cp() + 1 * V(1)
  })
end
local function load_exec_output(self, s)
  local i, tag, cmd = 0
  while true do
    tag, cmd, i = parse_pattern:match(s, i)
    if tag == '?TEX' then
      tex.print(cmd)
    elseif tag == '!LUA' then
      self.load_exec(cmd)
    elseif tag == '?LUA' then
      local eqs = self.safe_equals(cmd)
      tex.print([[%
\directlua{self.load_exec([=]]..eqs..[[]..cmd..[[]=]]..eqs..[[])}%
]])
    else
      return
    end
  end
end
%    \end{macrocode}
% \begin{function}{process_run}
% \begin{syntax}
% NLN:process_run(\meta{cs name})
% \end{syntax}
% Instance method. This is called by function \cs{NLNCode}.
% First, we get the content of the \meta{cs name} as code to be colored.
% Then we build a JSON string, save it in a file at |json_p| location.
% Next we call the \NLNPy{}, parse its output and execute
% commands with |load_exec_output|.
% \end{function}
%    \begin{macrocode}
local function process_run(self, name)
  if lfs.attributes(json_p,"mode") ~= nil then
    os.remove(json_p)
  end
  local t = {
    ['code']    = token.get_macro(name),
    ['jobname'] = self.jobname,
    ['options'] = self.options or {},
    ['already'] = self.already and 'true' or 'false'
  }
  local s = json.tostring(t,true)
  local fh = assert(io.open(json_p,'w'))
  fh:write(s, '\n')
  fh:close()
  local cmd = "python3 "..NLN_PY_PATH..' "'..\lua_escape:n {json_p}..'"'
  fh = assert(io.popen(cmd))
  self.already = true
  s = fh:read('a')
  self:load_exec_output(s)
end
%    \end{macrocode}
% \section{Caching}
% We save some computation time by pygmentizing files only when necessary.
% The \NLNPy{} is expected to create a |.pyg.sty| file for a style and a |.pyg.tex| file for
% colored code. These files are cached during one whole \LaTeX{} run and possibly between
% different \LaTeX{} runs. Lua keeps track of both the style files created and colored code files created.
% These tables are populated by a commands in the output of \NLNPy{}
% executed synchronously.
% \begin{function}{cache_clean_all, cache_record, cache_clean_unused}
% \begin{syntax}
% NLN:cache_clean_all()
% NLN:cache_record(\meta{style name.pyg.sty}, \meta{digest.pyg.tex})
% NLN:cache_clean_unused()
% \end{syntax}
% Instance methods.
% |cache_clean_all| removes any file in the cache directory \texttt{\jobname.pygd}.
% This is executed at the beginning of the document processing when there is no aux file.
% This can be executed on demand with |\directlua{NLN:cache_clean_all()}|.
% |cache_record| stores both \meta{style name.pyg.sty} and \meta{digest.pyg.tex}.
% These are file names relative to the \texttt{\meta{jobname}.pygd} directory.
% |cache_clean_unused| removes any file in the cache directory \texttt{\meta{jobname}.pygd}
% except the ones that were previously recorded. This is executed at the end of the
% document processing.
% \end{function}
%    \begin{macrocode}
local function cache_clean(self)
  local to_remove = {}
  for f in lfs.dir(dir_p) do
    to_remove[f] = true
  end
  for k,_ in pairs(to_remove) do
    os.remove(d .. k)
  end
end
local function cache_record(self, style, colored)
  self.style_set[style] = true
  self.colored_set[colored] = true
end
local function cache_clean_unused(self)
  local to_remove = {}
  for f in lfs.dir(dir_p) do
    if self.style_set[f] or self.colored_set[f] then
      continue
    end 
    to_remove[f] = true
  end
  for k,_ in pairs(to_remove) do
    os.remove(d .. k)
  end
end
%    \end{macrocode}
%    \begin{macrocode}
local _DESCRIPTION = [[Global inline helper on the lua side]]
%    \end{macrocode}
% \section{Return the module}
% Known fields are
% \begin{description}
% \item[\texttt{jobname}] to store \meta{jobname},
% \item[\texttt{date}] to store \meta{date string},
% \item[\texttt{_VERSION}] to store \meta{version string},
% \item[\texttt{dir_p}] is the path to the directory where all 
% \end{description}
% Known methods are
% \begin{description}
% \item[escape]
% \item[make_directory]
% \item[load_exec]
% \item[options_reset]
% \item[option_add]
% \item[start_recording]
% \item[process_run]
% \item[cache_clean_all]
% \item[cache_record]
% \item[cache_clean_unused]
% \end{description}
% \texttt{pygment} related material is stored,
% \begin{description}
% \item[\texttt{json_p}] is the path to the JSON file used by \NLNPy{} utility.
% \item[\texttt{style_set}] the set of style names used
% \item[\texttt{colored_set}] the set of ``colored'' names used
% \item[\texttt{already}] false at the beginning,
% true after the first call of \NLNPy{}
% \end{description}
%    \begin{macrocode}
return {
  _DESCRIPTION       = _DESCRIPTION,
  _VERSION           = token.get_macro('NLNFileVersion'),
  jobname            = jobname,
  date               = token.get_macro('NLNFileDate'),
  NLN_PY_PATH        = NLN_PY_PATH,
  escape             = escape,
  make_directory     = make_directory,
  load_exec          = load_exec,
  options_reset      = options_reset,
  option_add         = option_add,
  start_recording    = start_recording,
  process_run        = process_run,
  cache_clean_all    = cache_clean_all,
  cache_record       = cache_record,
  cache_clean_unused = cache_clean_unused,
  style_set          = {},
  colored_set        = {},
  already            = false,
}
%</lua>
%    \end{macrocode}
%
% \part{\texttt{inline-helper.py} implementation}
%
% The standard header is managed specially because of the way \pkg{docstrip} automatically 
% adds some header when extracting stuff from an archive.
% The next two lines are added by \pkg{docstrip} at the top of the preamble.
% 
%    \begin{macrocode}
%<*pyx>
#! /usr/bin/env python3
# -*- coding: utf-8 -*-
%</pyx>
%    \end{macrocode}
%
% \section{Header and global declarations}
% 
%    \begin{macrocode}
%<*py>
__version__ = '0.10'
__YEAR__  = '2022'
__docformat__ = 'restructuredtext'

from posixpath import split
import sys
import argparse
import re
from pathlib import Path
from io import StringIO
import hashlib
import json
import pygments as P
import pygments.formatters.latex as L
from pygments.token import Token as PyToken
%    \end{macrocode}
%
% \section{\texttt{NLNLatexFormatter} class}
% Based on \texttt{pygments} version 2.x.
% Enhanced formatter.
%    \begin{macrocode}
class NLNLatexFormatter(L.LatexFormatter):
  name = 'NLNLaTeX'
  aliases = []
  def __init__(self, *args, **kvargs):
    super().__init__(self, *args, **kvargs)
    self.escapeinside = kvargs.get('escapeinside', '')
    if len(self.escapeinside) == 2:
      self.left = self.escapeinside[0]
      self.right = self.escapeinside[1]
    else:
      self.escapeinside = ''
  def format_unencoded(self, tokensource, outfile):
    # TODO: add support for background colors
    t2n = self.ttype2name
    cp = self.commandprefix
    if self.full:
      realoutfile = outfile
      outfile = StringIO()
    outfile.write(r'\begin{Verbatim}[commandchars=\\\{\}')
    if self.linenos:
      start, step = self.linenostart, self.linenostep
      outfile.write(',numbers=left' +
            (start and ',firstnumber=%d' % start or '') +
            (step and ',stepnumber=%d' % step or ''))
    if self.mathescape or self.texcomments or self.escapeinside:
      outfile.write(r',codes={\catcode`\$=3\catcode`\^=7\catcode`\_=8}')
    if self.verboptions:
      outfile.write(',' + self.verboptions)
    outfile.write(']\n')
    for ttype, value in tokensource:
      if ttype in PyToken.Comment:
        if self.texcomments:
          # Try to guess comment starting lexeme and escape it ...
          start = value[0:1]
          for i in range(1, len(value)):
            if start[0] != value[i]:
              break
            start += value[i]

          value = value[len(start):]
          start = L.escape_tex(start, self.commandprefix)

          # ... but do not escape inside comment.
          value = start + value
        elif self.mathescape:
          # Only escape parts not inside a math environment.
          parts = value.split('$')
          in_math = False
          for i, part in enumerate(parts):
            if not in_math:
              parts[i] = L.escape_tex(part, self.commandprefix)
            in_math = not in_math
          value = '$'.join(parts)
        elif self.escapeinside:
          text = value
          value = ''
          while len(text) > 0:
            a,sep1,text = text.partition(self.left)
            if len(sep1) > 0:
              b,sep2,text = text.partition(self.right)
              if len(sep2) > 0:
                value += L.escape_tex(a, self.commandprefix) + b
              else:
                value += L.escape_tex(a + sep1 + b, self.commandprefix)
            else:
              value = value + L.escape_tex(a, self.commandprefix)
        else:
          value = L.escape_tex(value, self.commandprefix)
      elif ttype not in PyToken.Escape:
        value = L.escape_tex(value, self.commandprefix)
      styles = []
      while ttype is not PyToken:
        try:
          styles.append(t2n[ttype])
        except KeyError:
          # not in current style
          styles.append(L._get_ttype_name(ttype))
        ttype = ttype.parent
      styleval = '+'.join(reversed(styles))
      if styleval:
        spl = value.split('\n')
        for line in spl[:-1]:
          if line:
            outfile.write("\\%s{%s}{%s}" % (cp, styleval, line))
          outfile.write('\n')
        if spl[-1]:
          outfile.write("\\%s{%s}{%s}" % (cp, styleval, spl[-1]))
      else:
        outfile.write(value)

    outfile.write('\\end{Verbatim}\n')

    if self.full:
      realoutfile.write(DOC_TEMPLATE % dict(
        docclass  = self.docclass,
        preamble  = self.preamble,
        title     = self.title,
        encoding  = self.encoding or 'latin1',
        style_defs = self.get_style_defs(),
        code      = outfile.getvalue()
      ) )

%    \end{macrocode}
%
% \section{\texttt{Lexer} class}
%
% \begin{function}{Lexer}
% This lexer takes one other lexer as argument, the lexer for the language
% being formatted, and the left and right delimiters for escaped text.
%
% First everything is scanned using the language lexer to obtain
% strings and comments. All other consecutive tokens are merged and
% the resulting text is scanned for escaped segments, which are given
% the PyToken.Escape type. Finally text that is not escaped is scanned
% again with the language lexer.
% \end{function}
%    \begin{macrocode}
class Lexer(P.lexer.Lexer):

  def __init__(self, left, right, lang, *args, **kvargs):
    self.left = left
    self.right = right
    self.lang = lang
    super().__init__(self, *args, **kvargs)

  def get_tokens_unprocessed(self, text):
    buf = ''
    for i, t, v in self.lang.get_tokens_unprocessed(text):
      if t in P.token.Comment or t in P.token.String:
        if buf:
          for x in self.get_tokens_aux(idx, buf):
            yield x
          buf = ''
        yield i, t, v
      else:
        if not buf:
          idx = i
        buf += v
    if buf:
      for x in self.get_tokens_aux(idx, buf):
        yield x

  def get_tokens_aux(self, index, text):
    while text:
      a, sep1, text = text.partition(self.left)
      if a:
        for i, t, v in self.lang.get_tokens_unprocessed(a):
          yield index + i, t, v
          index += len(a)
      if sep1:
        b, sep2, text = text.partition(self.right)
        if sep2:
          yield index + len(sep1), P.token.Escape, b
          index += len(sep1) + len(b) + len(sep2)
        else:
          yield index, P.token.Error, sep1
          index += len(sep1)
          text = b
%    \end{macrocode}
%
% \section{\texttt{Controller} main class}
% The first class variables are string formats.
% They are used to let \NLNPy{} talk back to \TeX{}
% through \NLNLua{}.
%    \begin{macrocode}
class Controller:
  STY_FORMAT = r'''%%
\NLN_put:nn {style/%(name)s}{%%
%(defs)s%%
}%%
'''
  TEX_CALLBACK_FORMAT = r'''%%
\NLN_remove:n {colored:}%%
\NLN_style:nn {\tl_to_str:n {%(sty_p)s}}{\tl_to_str:n{%(name)s}}%%
\input {\tl_to_str:n {%(out_p)s}}%%
\NLN:n {colored:}%%
'''
  LUA_CALLBACK_FORMAT = r'''
NLN:cache_record(%(style)s),%(digest)s)
'''
  SNIPPET_FORMAT = r'''%%
\NLN_put:nn {colored} {%%
\group_begin:
\NLN:n {linenos:n} {%(line_numbers)s}%%
\begin{NLN/colored/%(mode)s/%(method)s}%%
%(body)s%%
\end{NLN/colored/%(mode)s/%(method)s}%%
\group_end:
}
'''
  PREAMBLE = r'''% -*- mode: latex -*-
\makeatletter
'''
  POSTAMBLE = r'''\makeatother
'''
%    \end{macrocode}
%
% \subsection{\texttt{Object} nested class}
%
%    \begin{macrocode}
  class Object(object):
    def __new__(cls, d={}, *args, **kvargs):
      if d.get('__cls__', 'arguments') == 'options':
        return super(Controller.Object, cls).__new__(
          Controller.Options, *args, **kvargs
        )
      else:
        return super(Controller.Object, cls).__new__(
          Controller.Arguments, *args, **kvargs
        )
    def __init__(self, d={}):
      for k, v in d.items():
        if type(v) == str:
          if v.lower() == 'true':
            setattr(self, k, True)
            continue
          elif v.lower() == 'false':
            setattr(self, k, False)
            continue
        setattr(self, k, v)
    def __repr__(self):
      return f"{object.__repr__(self)}: {self.__dict__}"
%    \end{macrocode}
%
% \subsection{\texttt{Options} nested class}
%
%    \begin{macrocode}
  class Options(Object):
    lang = "tex"
    escapeinside = ""
    gobble = 0
    tabsize = 4
    style = 'default'
    texcomments = False
    mathescape =  False
    linenos = False
    linenostart = 1
    linenostep = 1
    linenosep = '0pt'
    encoding = 'guess'
%    \end{macrocode}
%
% \subsection{\texttt{Arguments} nested class}
%
%    \begin{macrocode}
  class Arguments(Object):
    cache = False
    debug = False
    code = ""
    json = ""
    options = None
    directory = ""
%    \end{macrocode}
%
% \subsection{Computed properties}
%
% \begin{variable}{self.json_p}
% The full path to the \texttt{json} file containing all the data used for the processing.
% \end{variable}
%    \begin{macrocode}
  _json_p = None
  @property
  def json_p(self):
    p = self._json_p
    if p:
      return p
    else:
      p = self.arguments.json
      if p:
        p = Path(p).resolve()
    self._json_p = p
    return p
%    \end{macrocode}
%
% \begin{variable}{self.directory_p}
% The full path to the directory containing the various output files related
% to \pkg{pygment}. When not given in the \texttt{json} file,
% this is the directory of this file. The directory is created if necessary.
% \end{variable}
%    \begin{macrocode}
  _directory_p = None
  @property
  def directory_p(self):
    p = self._directory_p
    if p:
      return p
    p = self.arguments.directory
    if p:
      p = Path(p)
    else:
      p = self.json_p
      if p:
        p = p.parent / p.stem
      else:
        p = Path('SHARED')
    if p:
      p = p.resolve().with_suffix(".pygd")
      p.mkdir(exist_ok=True)
    self._directory_p = p
    return p
%    \end{macrocode}
%
% \begin{variable}{self.colored_p}
% The full path to the file where colored commands created by \pkg{pygment} should be stored.
% \end{variable}
%    \begin{macrocode}
  _colored_p = None
  @property
  def colored_p(self):
    p = self._colored_p
    if p:
      return p
    p = self.arguments.output
    if p:
      p = Path(p).resolve()
    else:
      p = self.json_p
      if p:
        p = p.with_suffix(".pyg.tex")
    self._colored_p = p
    return p
%    \end{macrocode}
%
% \begin{variable}{self.sty_p}
% The full path to the style file with definition created by \pkg{pygment}.
% \end{variable}
%    \begin{macrocode}
  @property
  def sty_p(self):
    return (self.directory_p / self.options.style).with_suffix(".pyg.sty")
%    \end{macrocode}
%
% \begin{variable}{self.parser}
% The correctly set up \texttt{argarse} instance. 
% \end{variable}
%    \begin{macrocode}
  @property
  def parser(self):
    parser = argparse.ArgumentParser(
      prog=sys.argv[0],
      description='''
Writes to the output file a set of LaTeX macros describing
the syntax highlighting of the input file as given by pygments.
'''
    )
    parser.add_argument(
      "-v", "--version",
      help="Print the version and exit",
      action='version',
      version=f'inline-helper version {__version__},'
      ' (c) {__YEAR__} by Jérôme LAURENS.'
    )
    parser.add_argument(
      "--debug",
      default=None,
      help="display informations useful for debugging"
    )
    parser.add_argument(
      "json",
      metavar="json data file",
      help="""
file name with extension of information to specify which processing is required
"""
    )
    return parser

%    \end{macrocode}
%
% \subsection{Static methods}
%
% \begin{function}{Controller.tex_command,Controller.lua_command,Controller.lua_command_now}
% \begin{syntax}
% self.tex_command(\meta{asynchronous tex command})
% self.lua_command(\meta{asynchronous lua command})
% self.lua_command_now(\meta{synchronous lua command})
% \end{syntax}
% Wraps the given command between markers. It will be in the output of the
% \NLNPy{}, further captured by \NLNLua{}
% and either forwarded to \TeX{} ot executed synchronously.
% \end{function}
%    \begin{macrocode}
  @staticmethod
  def tex_command(cmd):
    print(f'<<<<<?TEX:{cmd}>>>>>')
  @staticmethod
  def lua_command(cmd):
    print(f'<<<<<?LUA:{cmd}>>>>>')
  @staticmethod
  def lua_command_new(cmd):
    print(f'<<<<<!LUA:{cmd}>>>>>')
%    \end{macrocode}
%
% \subsection{Methods}
%
% \subsubsection{\texttt{__init__}}
%
% \begin{function}{__init__}
% Constructor. Reads the command line arguments.
% \end{function}
%    \begin{macrocode}
  def __init__(self, argv = sys.argv):
    argv = argv[1:] if re.match(".*inline-helper\.py$", argv[0]) else argv
    ns = self.parser.parse_args(
      argv if len(argv) else ['-h']
    )
    with open(ns.json, 'r') as f:
      self.arguments = json.load(
        f,
        object_hook=Controller.Object
      )
    self.options = self.arguments.options
    print("INPUT", self.json_p)
    print("OUTPUT DIR", self.directory_p)
    print("OUTPUT", self.colored_p)
%    \end{macrocode}
%
% \subsubsection{\texttt{get_tex_p}}
%
% \begin{function}{get_tex_p}
% \begin{syntax}
% \meta{variable} = self.get_tex_p(\meta{digest string})
% \end{syntax}
% The full path of the file where the colored commands created by \texttt{pygment}
% are stored. The digest allow to uniquely identify the code initially colored such that
% caching is easier.
% \end{function}
%    \begin{macrocode}
  def get_tex_p(self, digest):
    return (self.directory_p / digest).with_suffix(".pyg.tex")
%    \end{macrocode}
%
% \subsubsection{\texttt{read_input}}
%
%    \begin{macrocode}
  def read_input(self, filename, encoding):
    with open(filename, 'rb') as infp:
      code = infp.read()
    if not encoding or encoding == 'guess':
      code, encoding = P.util.guess_decode(code)
    else:
      code = code.decode(encoding)
    return code, encoding
%    \end{macrocode}
%
% \subsubsection{\texttt{process}}
%
% \begin{function}{self.process}
% \begin{syntax}
% self.process()
% \end{syntax}
% Main entry point.
% \end{function}
%    \begin{macrocode}
  def process(self):
    if self.convert_code():
      print('Done')
      return 0
    try:
      arguments = self.arguments
      with open(self.arguments.output, 'w') as outfile:
        try:
          code, encoding = self.read_input(self.arguments.input, "guess")
        except Exception as err:
          print('Error: cannot read input file: ', err, file=sys.stderr)
          return 1
        self.convert(code, outfile, encoding)
    except Exception as err:
      print('Error: cannot open output file: ', err, file=sys.stderr)
      return 1
    print("Done")
    return 0
%    \end{macrocode}
%
% \subsubsection{\texttt{prepare}}
% \begin{function}{self.prepare}
% \begin{syntax}
% self.prepare()
% \end{syntax}
% Set up \pkg{pygment} related objects.
% \end{function}
%    \begin{macrocode}
  def prepare(self):
    try:
      lexer = self.lexer = P.lexers.get_lexer_by_name(self.lang)
    except P.util.ClassNotFound as err:
      sys.stderr.write('Error: ')
      sys.stderr.write(str(err))

    self.style = P.styles.get_style_by_name(self.style)

    formatter = self.formatter = NLNLatexFormatter()
    formatter.NLN_controller = self

    gobble = abs(int(self.gobble))
    if gobble:
      lexer.add_filter('gobble', n=gobble)
    tabsize = abs(int(self.tabsize))
    if tabsize:
      lexer.tabsize = tabsize
    lexer.encoding = ''
    
    escapeinside = self.escapeinside
    if len(escapeinside) == 2:
      left = escapeinside[0]
      right = escapeinside[1]
      self.left = left
      self.right = right
      self.lexer = Lexer(left, right, lexer)
    else:
      self.escapeinside = ''
 
    formatter.texcomments = self.texcomments
    formatter.mathescape = self.mathescape
    
%    \end{macrocode}
%
% \subsubsection{\texttt{pygmentize}}
% \begin{function}{self.pygmentize}
% \begin{syntax}
% \meta{code variable}, \meta{style variable} = self.pygmentize(\meta{code}, \meta{inline\_delim})
% \end{syntax}
% Where the \meta{code} is pygmentized.
% \end{function}
%    \begin{macrocode}
  def pygmentize(self, code, inline_delim=True):
    options = self.options


    formatter._create_stylesheet()
    style_defs = formatter.get_style_defs() \
      .replace(r'\makeatletter', '') \
      .replace(r'\makeatother', '') \
      .replace('\n', '%\n')
    ans_style  = self.STY_FORMAT % dict(
      name = options.style,
      defs = style_defs,
    )
    ans_code = []
    m = re.match(
      r'\\begin\{Verbatim}(.*)\n([\s\S]*?)\n\\end\{Verbatim}(\s*)\Z',
      P.highlight(code, options.lexer, formatter)
    )
    if m:
      linenos = options.linenos
      linenostart = abs(int(options.linenostart))
      linenostep = abs(int(options.linenostep))
      lines0 = m.group(2).split('\n')
      numbers = []
      lines = []
      counter = linenostart
      for line in lines0:
        line = re.sub(r'^ ', r'\vphantom{Xy}~', line)
        line = re.sub(r' ', '~', line)
        if linenos:
          if (counter - linenostart) % linenostep == 0:
            line = rf'\NLN:n {{lineno:}}{{{counter}}}' + line
            numbers.append(str(counter))
          counter += 1
        lines.append(line)
      ans_code.append(self.SNIPPET_FORMAT % dict(
        mode         = 'inline' if inline_delim else 'display',
        method       = self.arguments.method or 'default',
        line_numbers = ','.join(numbers),
        body         = '\\newline\n'.join(lines)
      ) )
    ans_code = "".join(ans_code)
    ans_code = re.sub(
      r"\expandafter\def\csname\s*(.*?)\endcsname",
      r'\cs_new:cpn{\1}',
      ans_code,
      flags=re.M
    )
    ans_code = re.sub(
      r"\csname\s*(.*?)\endcsname",
      r'\use:c{\1}',
      ans_code,
      flags=re.M
    )
    return ans_style, ans_code
%    \end{macrocode}
%
% \subsubsection{\texttt{convert_code}}
% \begin{function}{self.convert_code}
% \begin{syntax}
% self.convert_code()
% \end{syntax}
% Call \texttt{self.pygmentize} and save the resulting style definitions
% and pygmented code in their respective locations.
% \end{function}
%    \begin{macrocode}
  def convert_code(self):
    code = self.arguments.code
    if not code:
      return False
    style, code = self.pygmentize(code,True)
    sty_p = self.sty_p
    if self.arguments.cache and sty_p.exists():
      print("Already available:", sty_p)
    else:
      with sty_p.open(mode='w',encoding='utf-8') as f:  
        f.write(style)
    h = hashlib.md5(str(code).encode('utf-8'))
    out_p = self.get_tex_p(h.hexdigest())
    if self.arguments.cache and out_p.exists():
      print("Already available:", out_p)
    else:
      with out_p.open(mode='w',encoding='utf-8') as f:
        f.write(self.PREAMBLE)
        print(f'DEBUG:{self.options}')
        f.write(code)
        f.write(self.POSTAMBLE)
    self.tex_command( self.TEX_CALLBACK_FORMAT % dict(
      sty_p = sty_p,
      out_p = out_p,
      name  = self.style,
    ) )
    if sty_p.parent.stem != 'SHARED':
      self.lua_command_now( self.LUA_CALLBACK_FORMAT % dict(
        style  = sty_p.name,
        digest = out_p.name,
      ) )
    print("PREMATURE EXIT")
    exit(1)
%    \end{macrocode}
%
% \subsection{Main entry}
%
%    \begin{macrocode}
if __name__ == '__main__':
  try:
    ctrl = Controller()
    sys.exit(ctrl.process())
  except KeyboardInterrupt:
    sys.exit(1)
%</py>
%    \end{macrocode}
%
% \part{\NLNSty{} implementation}
%    \begin{macrocode}
%<*sty>
\makeatletter
%    \end{macrocode}
% \section{Cache management}
%    \begin{macrocode}
\AddToHook { begindocument/before } {
  \IfFileExists{./\jobname.aux}{}{
   \directlua{NLN:cache_clean()}
  }
}
\AddToHook { enddocument/end } {
  \directlua{NLN:cache_clean_unused()}
}
%    \end{macrocode}
% \section{Constants}
% \begin{variable}{\c_NLN_comment_prop}
% One line comment marker per language.
%    \begin{macrocode}
\prop_const_from_keyval:Nn \c_NLN_comment_prop {
  tex=\c_percent_str,
  lua=--,
  python=\c_hash_str,
  c=//,
  c++=//,
  javascript=//,
}
%    \end{macrocode}
% \end{variable}
% \section{Global properties}
% \begin{variable}{\g/NLN/code/ }
% \begin{variable}{\g/NLN/code/<name>}
% Tree storage for global generic code properties or named code properties.
% These are overriden locally in environments using
% key-value actions. \cs{l_NLN_code_name_tl} is used as \meta{name}.
%    \begin{macrocode}
\prop_new:c {g/NLN/code/}
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \begin{variable}{\l_NLN_code_name_tl}
% Locally used as \meta{name} in \cs{g/NLN/code/<name>/}
% \cs{g/NLN/int/<name>} and similar.
%    \begin{macrocode}
\tl_new:N \l_NLN_code_name_tl
%    \end{macrocode}
% \end{variable}
% \subsection{Management}
% \begin{function}{\NLN:n,\NLN:nn}
% \begin{syntax}
% \cs{NLN:n} \marg{key}
% \cs{NLN:nn} \marg{name} \marg{key}
% \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \NLN:n #1 {
  \prop_item:cn {g/NLN/code/} { #1 }
}
\cs_new:Npn \NLN:nn #1 #2 {
  \prop_item:cn {g/NLN/code/#1/} { #2 }
}
%    \end{macrocode}
% \end{function}
% \begin{function} [TF,EXP] {\NLN_if_in:n, \NLN_if_in:nn}
%   \begin{syntax}
%     \cs{NLN_if_in:nTF} \marg{key} \Arg{true code} \Arg{false code}
%     \cs{NLN_if_in:nnTF} \marg{name} \marg{key} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when \cs{g/NLN/code/} prop's
% contains \texttt{\meta{key}},
% \meta{false code} otherwise.
% Execute \meta{true code} when \cs{g/NLN/code/\meta{name}/} prop's
% contains \texttt{\meta{key}},
% \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_if_in:n { T, F, TF } {
  \prop_if_in:cnTF {g/NLN/code/} { #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \NLN_if_in:nn { T, F, TF } {
  \prop_if_in:cnTF {g/NLN/code/#1/} { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{function}
% \begin{function} [TF,EXP] {\NLN:nN}
%   \begin{syntax}
%     \cs{NLN:nNTF} \marg{key} \meta{tl var} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when \cs{g/NLN/code/} prop's
% \texttt{\meta{key}} is retrieved in \meta{tl var},
% \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN:nN { T, F, TF } {
  \prop_get:cnNTF {g/NLN/code/} { #1 } #2 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_put:nn,\NLN_put:nV,\NLN_gput:nn,\NLN_gput:nV,\NLN_put:nnn, \NLN_put:nnV, \NLN_gput:nnn, \NLN_gput:nnV}
% \begin{syntax}
% \cs{NLN_put:nn} \marg{key} \marg{value}
% \cs{NLN_gput:nn} \marg{key} \marg{value}
% \cs{NLN_put:nnn} \marg{name} \marg{key} \marg{value}
% \cs{NLN_gput:nnn} \marg{name} \marg{key} \marg{value}
% \end{syntax}
% \meta{name} is a code name.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \NLN_put:nn #1 #2 {
  \prop_put:cnn {g/NLN/code/} { #1 } { #2 }
}
\cs_new:Npn \NLN_gput:nn #1 #2 {
  \prop_gput:cnn {g/NLN/code/} { #1 } { #2 }
}
\cs_generate_variant:Nn \NLN_put:nn { nV }
\cs_generate_variant:Nn \NLN_gput:nn { nV }
\cs_new:Npn \NLN_put:nnn #1 #2 #3 {
  \prop_put:cnn {g/NLN/code/#1/} { #2 } { #3 }
}
\cs_new:Npn \NLN_gput:nnn #1 #2 #3 {
  \prop_gput:cnn {g/NLN/code/#1/} { #2 } { #3 }
}
\cs_generate_variant:Nn \NLN_put:nnn { nnV }
\cs_generate_variant:Nn \NLN_gput:nnn { nnV }
%    \end{macrocode}
% \begin{function}{\NLN_remove:n,\NLN_gremove:n,\NLN_remove:nn,\NLN_gremove:nn}
% \begin{syntax}
% \cs{NLN_remove:n} \marg{value}
% \cs{NLN_remove:nn} \marg{key} \marg{value}
% \cs{NLN_gremove:n} \marg{value}
% \cs{NLN_gremove:nn} \marg{key} \marg{value}
% \end{syntax}
%    \begin{macrocode}
\cs_new:Npn \NLN_remove:n #1 {
  \prop_remove:cn {g/NLN/code/} { #1 }
}
\cs_new:Npn \NLN_remove:nn #1 #2 {
  \prop_remove:cn {g/NLN/code/#1/} { #2 }
}
\cs_new:Npn \NLN_gremove:n #1 {
  \prop_gremove:cn {g/NLN/code/} { #1 }
}
\cs_new:Npn \NLN_gremove:nn #1 #2 {
  \prop_gremove:cn {g/NLN/code/#1/} { #2 }
}
%    \end{macrocode}
% \end{function}
% \subsection{Known keys and conditionals}
% \begin{function}{\NLN_new_conditional:n}
%   \begin{syntax}
%     \cs{NLN_new_conditional:n} \marg{key}
%   \end{syntax}
% Create new conditionals for the given key.
% Does nothing out of this package..
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \NLN_new_conditional:n #1 {
  \exp_last_unbraced:Nx
  \prg_new_conditional:Nnn { \use:c {NLN_if_#1:} } { T, F, TF } {
    \group_begin:
    \NLN:nNTF { #1 } \l_tmpa_tl {
      \exp_args:NnV
      \regex_match:nnTF { ^\s*[tTyY] } \l_tmpa_tl
      { \group_end: \prg_return_true:  }
      { \group_end: \prg_return_false: }
    } { \group_end: \prg_return_false: }
  }
}
%    \end{macrocode}
%\begin{description}
% \item[\ttfamily format/code] Font/size/color specifier for inline code.
%    \begin{macrocode}
\NLN_gput:nn { format/code } {
  \ttfamily
}
%    \end{macrocode}
% \item[\ttfamily format/name] Font/size/color specifier for chunk name.
%    \begin{macrocode}
\NLN_gput:nn { format/name } {
  \sffamily
  \scriptsize
  \color{gray}
}
%    \end{macrocode}
% \item[\ttfamily format/lineno] Font/size/color specifier for line numbers.
%    \begin{macrocode}
\NLN_gput:nn { format/lineno } {
  \sffamily
  \tiny
  \color{gray}
}
%    \end{macrocode}
% \item[\ttfamily lang] the langage, defaults to \texttt{tex}
%    \begin{macrocode}
\NLN_gput:nn { lang } { tex }
%    \end{macrocode}
% \item[\ttfamily lineno] show line numbers, defaults to \texttt{true}
%    \begin{macrocode}
\NLN_gput:nn { show_lineno } { T }
%    \end{macrocode}
% \begin{function}[EXP,TF]
%   {\NLN_if_show_lineno:}
%   \begin{syntax}
%     \cs{NLN_if_show_lineno:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{show_lineo} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { show_lineno }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily name] show chunk names, defaults to \texttt{true}
%    \begin{macrocode}
\NLN_gput:nn { show_name } { T }
%    \end{macrocode}
% \begin{function}[EXP,TF]
%   {\NLN_if_show_name:}
%   \begin{syntax}
%     \cs{NLN_if_show_name:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{show_name} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { show_name }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily only top] show names only on top, defaults to \texttt{true}
%    \begin{macrocode}
\NLN_gput:nn { only_top } { T }
%    \end{macrocode}
% \begin{function}[EXP,TF]
%   {\NLN_if_only_top:}
%   \begin{syntax}
%     \cs{NLN_if_only_top:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{only_top} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { only_top }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily margin] use the margin to display line numbers and chunk names, defaults to \texttt{true}
%    \begin{macrocode}
\NLN_gput:nn { use_margin } { T }
%    \end{macrocode}
% \begin{function}[EXP,TF]
%   {\NLN_if_use_margin:}
%   \begin{syntax}
%     \cs{NLN_if_use_margin:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{use_margin} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { use_margin }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily ignore] ignore that chunk or that export, defaults to \texttt{false}
%    \begin{macrocode}
\NLN_gput:nn { ignore } { F }
%    \end{macrocode}
% \begin{function}[EXP,TF]
%   {\NLN_if_ignore:}
%   \begin{syntax}
%     \cs{NLN_if_ignore:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{ignore} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { ignore }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily reset] reset line numbering, defaults to \texttt{false}
%    \begin{macrocode}
\NLN_gput:nn { reset } { F }
%    \end{macrocode}
% \begin{function}[EXP,TF]
%   {\NLN_if_reset:}
%   \begin{syntax}
%     \cs{NLN_if_reset:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{reset} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { reset }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily export] whether the code should be exported, defaults to \texttt{true}
%    \begin{macrocode}
\NLN_gput:nn { export } { T }
%    \end{macrocode}
% \begin{function}[EXP,TF]
%   {\NLN_if_export:}
%   \begin{syntax}
%     \cs{NLN_if_export:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when
% code property \texttt{export} is truthy,
% \meta{false code} otherwise.
%    \begin{macrocode}
\NLN_new_conditional:n { export }
%    \end{macrocode}
% \end{function}
% \item[\ttfamily parskip] the parskip used to separate lines of code
%    \begin{macrocode}
\AddToHook { begindocument/end } {
  \NLN_if_in:nF { parskip } {
    \exp_args:Nnx
    \NLN_gput:nn { parskip } { \the\parskip }
  }
}
%    \end{macrocode}
% \item[\ttfamily baselinestretch] the baselinestretch used to separate lines of code
%    \begin{macrocode}
\AddToHook { begindocument/end } {
  \NLN_if_in:nF { baselinestretch } {
    \exp_args:NnV
    \NLN_gput:nn { baselinestretch } \baselinestretch
  }
}
%    \end{macrocode}
% \item[\ttfamily sep] the separation between inline code blocks
% and surrounding text.
%    \begin{macrocode}
\NLN_gput:nn { sep } { 4pt plus 2pt minus 2pt }
%    \end{macrocode}
% \item[\ttfamily code] the cumulated inline code
%    \begin{macrocode}
\NLN_gput:nn { .code } {}
%    \end{macrocode}
% \end{description}
% Clean memory.
%    \begin{macrocode}
\cs_undefine:N \NLN_new_conditional:n
%    \end{macrocode}
% \section{Counters}
% \begin{function}{\NLN_int_new:nn}
% \begin{syntax}
% \cs{NLN_int_new:n} \marg{name} \marg{value}
% \end{syntax}
% Create an integer after \meta{name} and
% set it globally to \meta{value}.
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_int_new:nn #1 #2 {
  \int_new:c {g/NLN/int/#1}
  \int_gset:cn {g/NLN/int/#1} { #2 }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_int_set:nn,\NLN_int_gset:nn}
% \begin{syntax}
% \cs{NLN_int_set:n} \marg{name} \marg{value}
% \end{syntax}
% Set the integer named after \meta{name} to the \meta{value}. \cs{NLN_int_gset:n} makes a global change.
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_int_set:nn #1 #2 {
  \int_set:cn {g/NLN/int/#1} { #2 }
}
\cs_new:Npn \NLN_int_gset:nn #1 #2 {
  \int_gset:cn {g/NLN/int/#1} { #2 }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_int_add:nn,\NLN_int_gadd:nn}
% \begin{syntax}
% \cs{NLN_int_add:n} \marg{name} \marg{value}
% \end{syntax}
% Add the \meta{value} to the integer named after \meta{name}. \cs{NLN_int_gadd:n} makes a global change.
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_int_add:nn #1 #2 {
  \int_add:cn {g/NLN/int/#1} { #2 }
}
\cs_new:Npn \NLN_int_gadd:nn #1 #2 {
  \int_gadd:cn {g/NLN/int/#1} { #2 }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_int_sub:nn,\NLN_int_gsub:nn}
% \begin{syntax}
% \cs{NLN_int_sub:n} \marg{name} \marg{value}
% \end{syntax}
% Substract the \meta{value} from the integer named after \meta{name}. \cs{NLN_int_gsub:n} makes a global change.
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_int_sub:nn #1 #2 {
  \int_sub:cn {g/NLN/int/#1} { #2 }
}
\cs_new:Npn \NLN_int_gsub:nn #1 #2 {
  \int_gsub:cn {g/NLN/int/#1} { #2 }
}
%    \end{macrocode}
% \end{function}
% \begin{function}[TF]
%   {\NLN_int_if_exist:n}
%   \begin{syntax}
%     \cs{NLN_int_if_exist:nTF} \marg{name} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when
% an integer named after \meta{name} exist,
% \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_int_if_exist:n { T, F, TF } {
  \int_if_exist:cTF {g/NLN/int/#1} {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{macrocode}
% \end{function}
% \begin{variable}{\g/NLN/int/}
% \begin{variable}{\g/NLN/int/<name>}
% Generic and named line number counter.
% \cs{l_NLN_code_name_t} is used as \meta{name}.
%    \begin{macrocode}
\NLN_int_new:nn {} { 1 }
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \begin{function}[EXP]{\NLN_int_use:n}
% \begin{syntax}
% \cs{NLN_int_use:n} \marg{name}
% \end{syntax}
% \meta{name} is a code name.
%    \begin{macrocode}
\cs_new:Npn \NLN_int_use:n #1 {
  \int_use:c {g/NLN/int/#1}
}
%    \end{macrocode}
% \end{function}
% \section{Variables}
% Line number counter for the code chunks.
% \begin{variable}{\g_NLN_code_int}
% Chunk number counter.
%    \begin{macrocode}
\int_new:N \g_NLN_code_int
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLN_code_prop}
% Global code property list.
%    \begin{macrocode}
\prop_new:N \g_NLN_code_prop
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLN_export_prop}
% Global storage for \texttt{\meta{file name}=\meta{comma separated chunk name}}
%    \begin{macrocode}
\prop_new:N \g_NLN_export_prop
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_prop}
% Local scratch variable.
%    \begin{macrocode}
\prop_new:N \l_NLN_prop
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLN_chunks_tl}
% \begin{variable}{\l_NLN_chunks_tl}
% The comma separated list of current chunks.
% If the next list of chunks is the same as the current one,
% then it might not display. 
%    \begin{macrocode}
\tl_new:N \g_NLN_chunks_tl
\tl_new:N \l_NLN_chunks_tl
%    \end{macrocode}
% \end{variable}
% \end{variable}
% \begin{variable}{\g_NLN_vars}
% Tree storage for global variables.
%    \begin{macrocode}
\prop_new:N \g_NLN_vars
%    \end{macrocode}
% \begin{description}
% \item[\ttfamily WHAT]
% \end{description}
% \end{variable}
% \begin{variable}{\g_NLN_vars}
% Tree storage for global variables.
%    \begin{macrocode}
\tl_new:N \g_NLN_hook_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g/NLN/Chunks/<name>}
% List of chunk keys for given named code.
% \end{variable}
%
% \subsection{Local variables}
% \begin{variable}{\l_NLN_recorded_tl}
% Full verbatim body of the \texttt{Inline} environment.
%    \begin{macrocode}
\tl_new:N \l_NLN_recorded_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLN_int}
% Global integer to store linenos locally in time.
%    \begin{macrocode}
\int_new:N \g_NLN_int
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_NLN_line_tl}
% Token list for one line.
%    \begin{macrocode}
\tl_new:N \l_NLN_line_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_lineno_tl}
% Token list for lineno display.
%    \begin{macrocode}
\tl_new:N \l_NLN_lineno_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_name_tl}
% Token list for chunk name display.
%    \begin{macrocode}
\tl_new:N \l_NLN_name_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_info_tl}
% Token list for the info of line.
%    \begin{macrocode}
\tl_new:N \l_NLN_info_tl
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_clist}
% The comma separated list of current chunks.
%    \begin{macrocode}
\clist_new:N \l_NLN_clist
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_NLN_in}
% Input file identifier
%    \begin{macrocode}
\ior_new:N \l_NLN_in
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\l_NLN_out}
% Output file identifier
%    \begin{macrocode}
\iow_new:N \l_NLN_out
%    \end{macrocode}
% \end{variable}
% \section{Utilities}
% Utilities
% \begin{function}{\NLN_clist_map_inline:Nnn}
% \begin{syntax}
% \cs{NLN_clist_map_inline:Nnn} \meta{clist var}
% \marg {non empty code} \marg {empty code}
% \end{syntax}
% Call \texttt{\cs{clist_map_inline:Nnn} \meta{clist var}
% \marg {non empty code}} when the list is not empty,
% execute meta{empty code} otherwise.
%    \begin{macrocode}
\cs_new:Npn \NLN_clist_map_inline:Nnn #1 #2 #3 {
  \clist_if_empty:NTF #1 { #3 } {
    \clist_map_inline:Nn #1 { #2 }
  }
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\NLN_process_record:}
% Record the current line or not.
%    \begin{macrocode}
\cs_new:Npn \NLN_process_record: {}
%    \end{macrocode}
% \end{function}
% \section{Shared key-value controls}
% Each action is meant to store the values in a code property, for the almost eponym key.
%    \begin{macrocode}
\keys_define:nn { NLN } {
%    \end{macrocode}
% Keys are:
% \begin{description}
% \item[\ttfamily lineno{[=true/false]}] to display the line numbers, or not,
%    \begin{macrocode}
  lineno .code:n = \NLN_put:nn { show_lineno } { #1 },
  lineno .default:n = true,
%    \end{macrocode}
% \item[\ttfamily name{[=true/false]}] to display the chunk names
%    \begin{macrocode}
  name .code:n = \NLN_put:nn { show_name } { #1 },
  name .default:n = true,
%    \end{macrocode}
% \item[\ttfamily only top] to avoid chunk names repetitions, if on the same page,
% two consecutive code chunks have the same chunk names, the second names are not displayed.
%    \begin{macrocode}
  only~top .code:n = \NLN_put:nn { only_top } { #1 },
  only~top .default:n = true,
%    \end{macrocode}
% \item[\ttfamily ignore] to ignore chunks.
%    \begin{macrocode}
  ignore .code:n = \NLN_put:nn { ignore } { #1 },
  ignore .default:n = true,
%    \end{macrocode}
% \item[\ttfamily margin{[=true/false]}] to use the magin to display line numbers, or not,
%    \begin{macrocode}
  margin .code:n = \NLN_put:nn { use_margin } { #1 },
  margin .default:n = true,
%    \end{macrocode}
% \item[\ttfamily lang=\meta{language name}], where \meta{language name} is recognized by \texttt{pygment},
%    \begin{macrocode}
  lang .code:n = \NLN_put:nn { lang } { #1 },
%    \end{macrocode}
% \item[\ttfamily code format=\meta{format}], where \meta{format} is used to display the code (mainly font, size and color),
%    \begin{macrocode}
  code~format .code:n = \NLN_put:nn { format/code } { #1 },
%    \end{macrocode}
% \item[\ttfamily lineno format=\meta{format}], where \meta{format} is used to display the line numbers (mainly font, size and color),
%    \begin{macrocode}
  name~format .code:n = \NLN_put:nn { format/name } { #1 },
%    \end{macrocode}
% \item[\ttfamily name format=\meta{format}], where \meta{name format} is used to display the chunk names (mainly font, size and color),
%    \begin{macrocode}
  lineno~format .code:n = \NLN_put:nn { format/lineno } { #1 },
%    \end{macrocode}
% \item[\ttfamily post processor] the name of the pygment post processor,
%    \begin{macrocode}
  post~processor .code:n = \NLN_put:nn { post_processor } { #1 },
%    \end{macrocode}
% \item[\ttfamily post processor args] the arguments of the pygment post processor,
%    \begin{macrocode}
  post~processor~args .code:n = \NLN_put:nn { post_processor_args } { #1 },
%    \end{macrocode}
% \item[\ttfamily sep] the separation with the surrounding text,
%    \begin{macrocode}
  sep .code:n = \NLN_put:nn { sep } { #1 },
%    \end{macrocode}
% \item[\ttfamily parskip] the value of the \cs{parskip} in inline code blocks,
%    \begin{macrocode}
  parskip .code:n = \NLN_put:nn { parskip } { #1 },
%    \end{macrocode}
% \item[\ttfamily test] whether the chunk is a test,
%    \begin{macrocode}
  test .code:n = \NLN_put:nn { test } { #1 },
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  unknown .code:n = \PackageWarning
    { inline }
    { Unknown~option~`\l_keys_key_str' },
}
%    \end{macrocode}
% \section{\cs{InlineSet}}
% \begin{function}{\InlineSet}
% \begin{syntax}
% \cs{InlineSet} \marg{key[=value] list}
% \end{syntax}
% To set up the package. This is executed at least once at the end of the preamble.
% The unique mandatory argument of \cs{InlineSet} is a
% list of \texttt{\meta{key}[=\meta{value}]} items defined by 
% \end{function}
% \subsection{\texttt{NLN/set} key-value controls.}
%    \begin{macrocode}
\keys_define:nn { } { NLN/set .inherit:n = NLN }
\keys_define:nn { NLN/set } {
%    \end{macrocode}
% \begin{description}
% \item[\ttfamily minted] to activate syntax coloring with \texttt{pygment},
% calls \cs{_NLN_minted_on:} and forwards the argument as \texttt{minted} option,
%    \begin{macrocode}
  minted .code:n = {
    \_NLN_minted_on:
    \setkeys { minted@opt@g } { #1 }
  },
%    \end{macrocode}
% \item[\ttfamily minted style=\meta{name}]
% to select a predefined minted style, forwarded to \cs{usemintedstyle},
%    \begin{macrocode}
  minted~style .code:n = {
    \RemoveFromHook { begindocument/before } [NLN/Minted]
    \AddToHook { begindocument/before } [NLN/Minted] {
      \usemintedstyle { #1 }
    }
  },
%    \end{macrocode}
% \item[\ttfamily only description] to typeset only the description
% section and ignore the implementation section.
%    \begin{macrocode}
  only~description .code:n = \prop_put:Nnn \l_NLN_vars
    { only_description } { #1 },
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  unknown .code:n = \PackageWarning
    { NLN/set }
    { Unknown~option~`\l_keys_key_str' },
}
%    \end{macrocode}
%
% \subsection{Implementation}
%    \begin{macrocode}
\NewDocumentCommand \InlineSet { m } {
  \keys_set:nn { NLN/set } {#1}
  \NLN_if_use_minted:F {
    \bool_if:NT \g_NLN_minted_on_bool {
      \sys_if_shell:TF {
        \_NLN_if_pygmentize:TF {
          \bool_gset_true:N \g_NLN_use_minted_bool
        } {
          \msg_warning:nnn
            { inline }
            { :n }
            { No~"pygmentize"~found. }
        }
      } {
        \msg_warning:nnn
          { inline }
          { :n }
          { No~unrestricted~shell~escape~for~"pygmentize".}
      }
    }
  }
}
%    \end{macrocode}
%
% \section{\texttt{InlineSplit} environment}
% 
% \section{\texttt{Inline} environment}
% \begin{environment}{Inline}
% \begin{syntax}
% \cs{begin}\Arg{Inline}\marg{key[=value] list} ... \cs{end}\Arg{Inline}
% \end{syntax}
% \end{environment}
% The \texttt{\meta{key}[=\meta{value}]} items are defined by the
% \subsection{\texttt{NLN/code} key-value controls}
%    \begin{macrocode}
\keys_define:nn { } { NLN/code .inherit:n = NLN }
\keys_define:nn { NLN/code } {
%    \end{macrocode}
% \begin{description}
% \item[\ttfamily chunks=\meta{comma separated list of chunk names}]
% When declaring an exported file,
% this is the list of chunks that will appear in that file.
% When declaring a code chunk, this the list of chunks where it will be stored.
% Chunks are collected unordered and ordered for comparison.
%    \begin{macrocode}
  chunks .clist_set:N = \l_NLN_clist,
%    \end{macrocode}
% \item[\ttfamily reset[=<boolean string>]
% When declaring an exported file,
% this is the list of chunks that will appear in that file.
% When declaring a code chunk, this the list of chunks where it will be stored.
% Chunks are collected unordered and ordered for comparison.
%    \begin{macrocode}
  reset .code:n = \NLN_put:nn { reset } { #1 },
  reset .default:n = true,
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  unknown .code:n = \PackageWarning
    { NLN/code }
    { Unknown~option~`\l_keys_key_str' },
}
%    \end{macrocode}
%
% \subsection{Implementation}
% \begin{function}[TF]
%   {\NLN_if_record:}
%   \begin{syntax}
%     \cs{NLN_if_record:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when code should be recorded, \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_if_record: { T, F, TF } {
  \NLN_if_export:TF {
    \prg_return_true:
  } {
    \NLN_if_use_minted:TF {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{function}
%    \begin{macrocode}
\cs_set:Npn \NLN_process_record: {
  \tl_put_right:Nx \l_NLN_recorded_tl { \the\verbatim@line \iow_newline: }
  \group_begin:
  \tl_set:Nx \l_tmpa_tl { \the\verbatim@line }
  \exp_args:Nx \directlua {NLN.records.append([===[\l_tmpa_tl]===])}
  \group_end:
}
%    \end{macrocode}
%    \begin{macrocode}
\DeclareDocumentEnvironment { Inline } { m } {
  \directlua{NLN:start_recording()}
  \clist_clear:N \l_NLN_clist
  \keys_set:nn { NLN/code } { #1 }
  \clist_map_inline:Nn \l_NLN_clist {
    \NLN_int_if_exist:nF { ##1 } {
      \NLN_int_new:nn { ##1 } { 1 }
      \seq_new:c { g/NLN/chunks/##1 }
    }
  }
  \NLN_if_reset:T {
    \NLN_clist_map_inline:Nnn \l_NLN_clist {
      \NLN_int_gset:nn { ##1 } 1
    } {
      \NLN_int_gset:nn { } 1
    }
  }
  \tl_clear:N \l_NLN_code_name_tl
  \clist_map_inline:Nn \l_NLN_clist {
    \prop_concat:ccc
      {g/NLN/code/}
      {g/NLN/code/##1/}
      {g/NLN/code/}
    \tl_set:Nn \l_NLN_code_name_tl { ##1 }
    \clist_map_break:
  }
  \int_gset:Nn \g_NLN_int
    { \NLN_int_use:n { \l_NLN_code_name_tl } }
  \tl_clear:N \l_NLN_info_tl
  \tl_clear:N \l_NLN_name_tl
  \tl_clear:N \l_NLN_recorded_tl
  \tl_clear:N \l_NLN_chunks_tl
  \cs_set:Npn \verbatim@processline {
    \NLN_process_record:
  }
  \NLN_if_show_code:TF {
    \exp_args:NNx
    \skip_set:Nn \parskip { \NLN:n { parskip } }
    \clist_if_empty:NTF \l_NLN_clist {
      \tl_gclear:N \g_NLN_chunks_tl
    } {
      \clist_set_eq:NN \l_tmpa_clist \l_NLN_clist
      \clist_sort:Nn \l_tmpa_clist {
        \str_compare:nNnTF { ##1 } > { ##2 } {
          \sort_return_swapped:
        } {
          \sort_return_same:
        }
      }
      \tl_set:Nx \l_tmpa_tl { \clist_use:Nn \l_tmpa_clist , }
      \NLN_if_show_name:T {
        \NLN_if_use_margin:T {
          \NLN_if_only_top:T {
            \tl_if_eq:NNT \l_tmpa_tl \g_NLN_chunks_tl {
              \tl_gset_eq:NN \g_NLN_chunks_tl \l_tmpa_tl
              \tl_clear:N \l_tmpa_tl
            }
          }
          \tl_if_empty:NF \l_tmpa_tl {
            \tl_set:Nx \l_NLN_chunks_tl {
              \clist_use:Nn \l_NLN_clist ,
            }
            \tl_set:Nn \l_NLN_name_tl {
              {
                \NLN:n { format/name }
                \l_NLN_chunks_tl :
                \hspace*{1ex}
              }
            }
          }
        }
        \tl_if_empty:NF \l_tmpa_tl {
          \tl_gset_eq:NN \g_NLN_chunks_tl \l_tmpa_tl          
        }
      }
    }
    \if_mode_vertical:
    \else:
    \par
    \fi:
    \vspace{ \NLN:n { sep } }
    \noindent
    \frenchspacing
    \@vobeyspaces
    \normalfont\ttfamily
    \NLN:n { format/code }
    \hyphenchar\font\m@ne
    \@noligs
    \NLN_if_record:F {
      \cs_set_eq:NN \NLN_process_record: \prg_do_nothing:
    }
    \NLN_if_use_minted:F {
      \NLN_if_show_lineno:T {
        \NLN_if_use_margin:TF {
          \tl_set:Nn \l_NLN_info_tl {
            \hbox_overlap_left:n {
              {
                \l_NLN_name_tl
                \NLN:n { format/name }
                \NLN:n { format/lineno }
                \int_use:N \g_NLN_int
                \int_gincr:N \g_NLN_int
              }
              \hspace*{1ex}
            }
          }
        } {
          \tl_set:Nn \l_NLN_info_tl {
            {
              \NLN:n { format/name }
              \NLN:n { format/lineno }
              \hspace*{3ex}
              \hbox_overlap_left:n {
                \int_use:N \g_NLN_int
                \int_gincr:N \g_NLN_int
              }
            }
            \hspace*{1ex}
          }
        }
      }
      \cs_set:Npn \verbatim@processline {
        \NLN_process_record:
        \hspace*{\dimexpr \linewidth-\columnwidth}%
        \hbox_to_wd:nn { \columnwidth } {
          \l_NLN_info_tl
          \the\verbatim@line
          \color{lightgray}\dotfill
        }
        \tl_clear:N \l_NLN_name_tl
        \par\noindent
      }
    }
  } {
    \@bsphack
  }
  \group_begin:
  \g_NLN_hook_tl
  \let \do \@makeother
  \dospecials \catcode `\^^M \active
  \verbatim@start
} {
  \int_gsub:Nn \g_NLN_int {
    \NLN_int_use:n { \l_NLN_code_name_tl }
  }
  \int_compare:nNnT { \g_NLN_int } > { 0 } {
    \NLN_clist_map_inline:Nnn \l_NLN_clist {
      \NLN_int_gadd:nn { ##1 } { \g_NLN_int }
    } {
      \NLN_int_gadd:nn { } { \g_NLN_int }
    }
    \int_gincr:N \g_NLN_code_int
    \tl_set:Nx \l_tmpb_tl { \int_use:N \g_NLN_code_int }
    \clist_map_inline:Nn \l_NLN_clist {
      \seq_gput_right:cV { g/NLN/chunks/##1 } \l_tmpb_tl
    }
    \prop_gput:NVV \g_NLN_code_prop \l_tmpb_tl \l_NLN_recorded_tl
  }
  \group_end:
  \NLN_if_show_code:T {
  }
  \NLN_if_show_code:TF {
    \NLN_if_use_minted:TF {
      \tl_if_empty:NF \l_NLN_recorded_tl {
        \exp_args:Nnx \setkeys { FV } {
          firstnumber=\NLN_int_use:n { \l_NLN_code_name_tl },
        }
        \iow_open:Nn \minted@code { \jobname.pyg }
        \exp_args:NNV \iow_now:Nn \minted@code \l_NLN_recorded_tl
        \iow_close:N \minted@code
        \vspace* { \dimexpr -\topsep-\parskip }
        \tl_if_empty:NF \l_NLN_info_tl {
          \tl_use:N \l_NLN_info_tl
          \skip_vertical:n { \dimexpr -\topsep-\parskip-\baselineskip }        
          \par\noindent
        }
        \exp_args:Nnx \minted@pygmentize { \jobname.pyg } { \NLN:n { lang } }
        %\DeleteFile { \jobname.pyg }
        \skip_vertical:n { -\topsep-\partopsep }        
      }
    } {
      \exp_args:Nx \skip_vertical:n { \NLN:n { sep } }
      \noindent
    }
  } {
    \@esphack
  }  
}
%    \end{macrocode}
% \begin{environment}{NLN}
% \begin{syntax}
% \cs{begin}\Arg{NLN} ... \cs{end}\Arg{NLN}
% \end{syntax}
% Private environment.
% \end{environment}
%    \begin{macrocode}
\newenvironment{NLN}{
  \def \verbatim@processline {
    \group_begin:
    \NLN_processline_code_append:
    \group_end:
  }
%  \NLN_if_show_code:T {
%    \NLN_if_use_minted:TF {
%      \Needspace* { 2\baselineskip }
%    } {
%      \frenchspacing\@vobeyspaces
%    }
%  }
} {
  \NLN:nNTF { lang } \l_tmpa_tl {
    \tl_if_empty:NT \l_tmpa_tl {
      \clist_map_inline:Nn \l_NLN_clist {
        \NLN:nnNT { ##1 } { lang } \l_tmpa_tl {
          \tl_if_empty:NF \l_tmpa_tl {
            \clist_map_break:
          }
        }
      }
      \tl_if_empty:NT \l_tmpa_tl {
        \tl_set:Nn \l_tmpa_tl { tex }
      }
    }
  } {
    \tl_set:Nn \l_tmpa_tl { tex }
  }
  \clist_map_inline:Nn \l_NLN_clist {
    \NLN_gput:nnV { ##1 } { lang } \l_tmpa_tl
  }
}
%    \end{macrocode}
% \begin{environment}{NLN.M}
% \begin{syntax}
% \cs{begin}\Arg{NLN.M} ... \cs{end}\Arg{NLN.N}
% \end{syntax}
% Private environment when \texttt{minted}.
% \end{environment}
%    \begin{macrocode}
\newenvironment{NLN_M}{
  \setkeys { FV } { firstnumber=last, }
  \clist_if_empty:NTF \l_NLN_clist {
    \exp_args:Nnx \setkeys { FV } {
      firstnumber=\NLN_int_use:n { },
  } } {
    \clist_map_inline:Nn \l_NLN_clist {
      \exp_args:Nnx \setkeys { FV } {
        firstnumber=\NLN_int_use:n { ##1 },
      }
      \clist_map_break:
  } }
  \iow_open:Nn \minted@code { \jobname.pyg }
  \tl_set:Nn \l_NLN_line_tl {
    \tl_set:Nx \l_tmpa_tl { \the\verbatim@line }
    \exp_args:NNV \iow_now:Nn \minted@code \l_tmpa_tl
  }
} {
  \NLN_if_show_code:T {
    \NLN_if_use_minted:TF {
      \iow_close:N \minted@code
      \vspace* { \dimexpr -\topsep-\parskip }
      \tl_if_empty:NF \l_NLN_info_tl {
        \tl_use:N \l_NLN_info_tl
        \vspace* { \dimexpr -\topsep-\parskip-\baselineskip }        
        \par\noindent
      }
      \exp_args:NV \minted@pygmentize \l_tmpa_tl
      \DeleteFile { \jobname.pyg }
      \vspace* { \dimexpr -\topsep -\partopsep }
    } {
      \@esphack
    }
  }
}
%    \end{macrocode}
% \begin{environment}{NLN.P}
% \begin{syntax}
% \cs{begin}\Arg{NLN.P} ... \cs{end}\Arg{NLN.P}
% \end{syntax}
% Private pseudo environment.
% This is just a practical way of declaring balanced actions.
% \end{environment}
%    \begin{macrocode}
\newenvironment{NLN_P}{
  \if_mode_vertical:
    \noindent
  \else
    \vspace*{ \topsep }
    \par\noindent
  \fi
  \NLN_gset_chunks:
  \tl_if_empty:NTF \g_NLN_chunks_tl {
    \NLN_if_show_lineno:TF {
      \NLN_if_use_margin:TF {
%    \end{macrocode}
% No chunk name, line numbers in the margin
%    \begin{macrocode}
        \tl_set:Nn \l_NLN_info_tl {
          \hbox_overlap_left:n {
            \NLN:n { format/code }
            {
              \NLN:n { format/name }
              \NLN:n { format/lineno }
              \clist_if_empty:NTF \l_NLN_clist {
                \NLN_int_use:n { }
              } {
                \clist_map_inline:Nn \l_NLN_clist {
                  \NLN_int_use:n { ##1 }
                  \clist_map_break:
                }
              }
            }
            \hspace*{1ex}
          }
        }
      } {
%    \end{macrocode}
% No chunk name, line numbers not in the margin
%    \begin{macrocode}
        \tl_set:Nn \l_NLN_info_tl {
          {
            \NLN:n { format/code }
            {
              \NLN:n { format/name }
              \NLN:n { format/lineno }
              \hspace*{3ex}
              \hbox_overlap_left:n {
                \clist_if_empty:NTF \l_NLN_clist {
                  \NLN_int_use:n { }
                } {
                  \clist_map_inline:Nn \l_NLN_clist {
                    \NLN_int_use:n { ##1 }
                    \clist_map_break:
                  }
                }
              }
              \hspace*{1ex}
            }
          }
        }        
      }
    } {
%    \end{macrocode}
% No chunk name, no line numbers
%    \begin{macrocode}
      \tl_clear:N \l_NLN_info_tl
    }    
  } {
    \NLN_if_show_lineno:TF {
%    \end{macrocode}
% Chunk names, line numbers, in the margin
%    \begin{macrocode}
      \tl_set:Nn \l_NLN_info_tl {
        \hbox_overlap_left:n {
          \NLN:n { format/code }
          {
            \NLN:n { format/name }
            \g_NLN_chunks_tl :
            \hspace*{1ex}
            \NLN:n { format/lineno }
            \clist_map_inline:Nn \l_NLN_clist {
              \NLN_int_use:n { ####1 }
              \clist_map_break:
            }
          }
          \hspace*{1ex}
        }
        \tl_set:Nn \l_NLN_info_tl {
          \hbox_overlap_left:n {
            \NLN:n { format/code }
            {
              \NLN:n { format/name }
              \NLN:n { format/lineno }
              \clist_map_inline:Nn \l_NLN_clist {
                \NLN_int_use:n { ####1 }
                \clist_map_break:
              }
            }
            \hspace*{1ex}
          }
        }
      }
    } {
%    \end{macrocode}
% Chunk names, no line numbers, in the margin
%    \begin{macrocode}
      \tl_set:Nn \l_NLN_info_tl {
        \hbox_overlap_left:n {
          \NLN:n { format/code }
          {
            \NLN:n { format/name }
            \g_NLN_chunks_tl :
          }
          \hspace*{1ex}
        }
        \tl_clear:N \l_NLN_info_tl
      }
    }
  }
  \NLN_if_use_minted:F {
    \tl_set:Nn \l_NLN_line_tl {
      \noindent
      \hbox_to_wd:nn { \textwidth } {
        \tl_use:N \l_NLN_info_tl
        \NLN:n { format/code }
        \the\verbatim@line        
        \hfill
      }
      \par
    }
    \@bsphack
  }
} {
  \vspace*{ \topsep }
  \par
  \@esphack
}
%    \end{macrocode}
% \section{\cs{InlineExport}}
% \begin{function}{\InlineExport}
% \begin{syntax}
% \cs{InlineExport}\marg{key[=value] list}
% \end{syntax}
% The \texttt{\meta{key}[=\meta{value}]} items are defined by
% \end{function}
%
% \subsection{\texttt{NLN/export} key-value controls}
%    \begin{macrocode}
\keys_define:nn { } { NLN/export .inherit:n = NLN/code }
\keys_define:nn { NLN/export } {
%    \end{macrocode}
% \begin{description}
% \item[file] the output file name
%    \begin{macrocode}
  file .tl_set:N = \l_NLN_tl,
  file .value_required:n = true,
%    \end{macrocode}
% \item[\ttfamily preamble] the added preamble.
%    \begin{macrocode}
  preamble .code:n = \prop_put:Nnn \l_NLN_vars { preamble } { #1 },
%    \end{macrocode}
% \item[\ttfamily raw] to remove any additional material, 
%    \begin{macrocode}
  raw .code:n = \prop_put:Nnn \l_NLN_vars { raw } { #1 },
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
  unknown .code:n = \PackageWarning
    { NLN/export }
    { Unknown~option~`\l_keys_key_str' },
}
%    \end{macrocode}
% 
% \subsection{Implementation}
%    \begin{macrocode}
\DeclareDocumentCommand \InlineExport { m } {
  \group_begin:
  \clist_clear:N \l_NLN_clist
  \prop_clear:c {g/NLN/code/}
  \prop_put:cnn {g/NLN/code/} { lang } { tex }
  \keys_set:nn { NLN/export } { #1 }
  \prop_gput:NVV \g_NLN_export_prop \l_NLN_tl \l_NLN_clist
  \prop_gput:cnV { g/NLN/export/\l_NLN_tl } { chunks } \l_NLN_clist
  \prop_gput:cnx { g/NLN/export/\l_NLN_tl } { preamble }
    { \prop_item:Nn \l_NLN_vars { preamble } }
  \bool_set:Nx \l_tmpa_bool { \prop_item:Nn \l_NLN_vars { raw } }
  \prop_gput:cnV { g/NLN/export/\l_NLN_tl } { preamble } \l_tmpa_bool
  \NLN:nNT { lang } \l_tmpa_tl {
    \clist_map_inline:Nn \l_NLN_clist {
      \prop_gconcat:ccc
        {g/NLN/code/##1/}
        {g/NLN/code/##1/}
        {g/NLN/code/}
    }
  }
  \group_end:
}
%    \end{macrocode}
% Files are created at the end of the typesetting process.
%    \begin{macrocode}
\AddToHook { enddocument / end } {
  \group_begin:
  \prop_map_inline:Nn \g_NLN_export_prop {
    \iow_open:Nn \l_NLN_out { #1 }
    \iow_term:x { Exporting~chunks~#2~to~#1 }
    \prop_get:cnNF { g/NLN/export/#1 } { raw } \l_tmpa_bool {
      \bool_set_false:N \l_tmpa_bool
    }
    \bool_if:NF \l_tmpa_bool {
      \prop_get:cnNT { g/NLN/export/#1 } { preamble } \l_tmpa_tl {
        \prop_get:cnNF { g/NLN/export/#1 } { lang } \l_tmpa_str {
          \str_set:Nn \l_tmpa_str { tex }
        }
        \prop_get:NVNTF \c_NLN_comment_prop \l_tmpa_str \l_tmpa_str {
          \tl_set:Nn \l_tmpb_tl {
            \l_tmpa_str\l_tmpa_str\space\space
          }
        } {
          \tl_clear:N \l_tmpb_tl
        }
        \tl_put_right:Nx \l_tmpb_tl {
          This~is~file~`#1'~
          generated~from~`\c_sys_jobname_str.tex'~on~\DTMnow.
        }
        \iow_now:Nx \l_NLN_out { \l_tmpb_tl }
        \iow_now:Nx \l_NLN_out { \l_tmpa_tl }
      }
    }
    \clist_map_inline:nn { #2 } {
      \NLN:nnNT { ##1 } { .code } \l_tmpa_tl {
        \exp_args:NNV \iow_now:Nn \l_NLN_out \l_tmpa_tl
      }
    }
    \iow_close:N \l_NLN_out
  }
  \group_end:
}
%    \end{macrocode}
%
%
% \section{Management}
% \begin{variable}{\g_NLN_in_impl_bool}
% Whether we are currently in the implementation section.
%    \begin{macrocode}
\bool_new:N \g_NLN_in_impl_bool
%    \end{macrocode}
% \end{variable}
% \begin{function}[TF]
%   {\NLN_if_show_code:}
%   \begin{syntax}
%     \cs{NLN_if_show_code:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when code should be printed, \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_if_show_code: { T, F, TF } {
  \bool_if:nTF {
    \g_NLN_in_impl_bool && !\g_NLN_with_impl_bool
  } {
    \prg_return_false:
  } {
    \prg_return_true:
  }
}
%    \end{macrocode}
% \end{function}
%
% \begin{variable}{\g_NLN_with_impl_bool}
%    \begin{macrocode}
\bool_new:N \g_NLN_with_impl_bool
%    \end{macrocode}
% \end{variable}
%
% \section{All purpose messaging}
%    \begin{macrocode}
%    \end{macrocode}
%
% \section{\texttt{minted} and \texttt{pygment}}
% \begin{variable}{\g_NLN_minted_on_bool}
% Whether minted is available, initially set to \texttt{false}.
%    \begin{macrocode}
\bool_new:N \g_NLN_minted_on_bool
%    \end{macrocode}
% \end{variable}
% \begin{variable}{\g_NLN_use_minted_bool}
% Whether minted is used, initially set to \texttt{false}.
%    \begin{macrocode}
\bool_new:N \g_NLN_use_minted_bool
%    \end{macrocode}
% \end{variable}
% \begin{function}[TF]
%   {\NLN_if_use_minted:}
%   \begin{syntax}
%     \cs{NLN_if_use_minted:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when using |minted|, \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn \NLN_if_use_minted: { T, F, TF } {
  \bool_if:NTF \g_NLN_use_minted_bool
    { \prg_return_true:  }
    { \prg_return_false: }
}
%    \end{macrocode}
% \end{function}
%
% \begin{function}[TF]
%   {\_NLN_if_pygmentize:}
%   \begin{syntax}
%     \cs{NLN_if_pygmentize:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when \texttt{pygmentize} is available,
% \meta{false code} otherwise.
%    \begin{macrocode}
\prg_new_conditional:Nnn\_NLN_if_pygmentize: { T, F, TF } {
  \group_begin:
  \sys_get_shell:nnN {which~pygmentize} {} \l_tmpa_tl
  \tl_if_empty:NTF \l_tmpa_tl {
    \tl_set:Nn \l_tmpa_tl { \prg_return_false: }
  } {
    \tl_set:Nn \l_tmpa_tl { \prg_return_true: }
  }
  \exp_last_unbraced:NV
  \group_end: \l_tmpa_tl
}
%    \end{macrocode}
% \end{function}
% \begin{function}{\_NLN_minted_on:}
% \begin{syntax}
% \cs{_NLN_minted_on:}
% \end{syntax}
% Private function. During the preamble, loads \pkg{minted},
% sets \cs{g_NLN_minted_on_bool} to \texttt{true} and prepares \texttt{pygment} processing.
% \end{function}
%    \begin{macrocode}
\cs_set:Npn \_NLN_minted_on: {
  \bool_gset_true:N \g_NLN_minted_on_bool
  \RequirePackage{minted}
  \setkeys{ minted@opt@g } { linenos=false }
  \minted@def@opt{post~processor}
  \minted@def@opt{post~processor~args}
  \pretocmd\minted@inputpyg{
    \NLN@postprocesspyg {\minted@outputdir\minted@infile}
  }{}{\fail}  
%    \end{macrocode}
% In the execution context of \cs{minted@inputpyg},
% \begin{description}
% \item[\texttt{\#1}] is the name of the python script, e.g., ``\texttt{process.py}''
% \item[\texttt{\#2}] is the input ``.pygtex'' file ``\cs{minted@outputdir}\cs{minted@infile}''
% \item[\texttt{\#3}] are more args passed to the python script, possibly empty
% \end{description}
%    \begin{macrocode}
  \newcommand{\NLN@postprocesspyg}[1]{%
    \group_begin:
    \tl_set:Nx \l_tmpa_tl {\NLN:n { post_processor } }
    \tl_if_empty:NF \l_tmpa_tl {
%    \end{macrocode}
% Execute \texttt{`python3 <script.py> <file.pygtex> <more_args>`}
%    \begin{macrocode}
      \tl_set:Nx \l_tmpb_tl {\NLN:n { post_processor_args } }
      \exp_args:Nx
      \sys_shell_now:n {
        python3\space
        \l_tmpa_tl\space
        ##1\space
        \l_tmpb_tl
      }  
    }
    \group_end:
  }
}
%    \end{macrocode}
%    \begin{macrocode}
%\AddToHook { begindocument / end } {
%  \cs_set_eq:NN \_NLN_minted_on: \prg_do_nothing:
%}
%    \end{macrocode}
% Utilities to setup |pygment| post processing.
% The |pygment| post processor marks some code with \cs{InlineEmph}.
%    \begin{macrocode}
\ProvideDocumentCommand{\InlineEmph}{m}{\textcolor{red}{#1}}
%    \end{macrocode}
%
% \begin{function}{\InlineStorePreamble}
% \begin{syntax}
% \cs{InlineStorePreamble} \marg{variable} \marg{file name}
% \end{syntax}
% Store the content of \meta{file name} into the variable \meta{variable}.
% \end{function}
%
% \section{Separators}
% \begin{function}{\InlineImplementation}
% \begin{syntax}
% \cs{InlineImplementation}
% \end{syntax}
% Start an implementation part where all the sectioning commands do nothing.
% \end{function}
% \begin{function}{\InlineFinale}
% \begin{syntax}
% \cs{InlineFinale}
% \end{syntax}
% Stop an implementation part.
% \end{function}
% \section{Finale}
%    \begin{macrocode}
\DeclareDocumentCommand \InlineStorePreamble { m m } {
  \group_begin:
  \msg_info:nnn
    { inline }
    { :n }
    { Reading~preamble~from~file~"#2". }
  \tl_clear:N \g_tmpa_tl
  \tl_clear:N \g_tmpb_tl
  \ior_open:Nn \l_NLN_in { #2 }
  \bool_until_do:nn { \ior_if_eof_p:N \l_NLN_in } {
    \ior_str_get:NN \l_NLN_in \l_tmpa_tl
    \tl_if_empty:NTF \l_tmpa_tl {
      \tl_put_right:Nn \g_tmpb_tl { \iow_newline: }
    } {
      \tl_put_right:Nx \g_tmpa_tl { \g_tmpb_tl }
      \tl_set:Nn \g_tmpb_tl { \iow_newline: }
      \tl_put_right:NV \g_tmpa_tl \l_tmpa_tl
    }
  }
  \ior_close:N \l_NLN_in
  \exp_args:NNNx
  \group_end:
  \tl_set:Nn #1 { \tl_to_str:N \g_tmpa_tl }
}
\newcounter{NLN@impl@page}
\DeclareDocumentCommand \InlineImplementation {} {
  \bool_if:NF \g_NLN_with_impl_bool {
    \clearpage
    \bool_gset_true:N \g_NLN_in_impl_bool
    \let\NLN@old@part\part
    \DeclareDocumentCommand\part{som}{}
    \let\NLN@old@section\section
    \DeclareDocumentCommand\section{som}{}
    \let\NLN@old@subsection\subsection
    \DeclareDocumentCommand\subsection{som}{}
    \let\NLN@old@subsubsection\subsubsection
    \DeclareDocumentCommand\subsubsection{som}{}
    \let\NLN@old@paragraph\paragraph
    \DeclareDocumentCommand\paragraph{som}{}
    \let\NLN@old@subparagraph\subparagraph
    \DeclareDocumentCommand\subparagraph{som}{}
    \cs_if_exist:NT \refsection{ \refsection }
    \setcounter{ NLN@impl@page }{ \value{page} }
  }
}
\DeclareDocumentCommand\InlineFinale {} {
  \bool_if:NF \g_NLN_with_impl_bool {
    \clearpage
    \bool_gset_false:N \g_NLN_in_impl_bool
    \let\part\NLN@old@part
    \let\section\NLN@old@section
    \let\subsection\NLN@old@subsection
    \let\subsubsection\NLN@old@subsubsection
    \let\paragraph\NLN@old@paragraph
    \let\subparagraph\NLN@old@subparagraph
    \setcounter { page } { \value{ NLN@impl@page } }
  }
}
\cs_set_eq:NN \NLN_line_number: \prg_do_nothing:
%    \end{macrocode}
% \section{Finale}
%    \begin{macrocode}
\AddToHook { cmd/FancyVerbFormatLine/before } {
  \NLN_line_number:
}
\AddToHook { shipout/before } {
  \tl_gclear:N \g_NLN_chunks_tl
}
\InlineSet {}
%    \end{macrocode}
%    \begin{macrocode}
% =========================================================
% Auxiliary:
%   finding the widest string in a comma
%   separated list of strings delimited by parenthesis
% =========================================================

% arguments:
% #1) text: a comma separeted list of strings
% #2) formatter: a macro to format each string
% #3) dimension: will hold the result

\cs_new:Npn \NLNWidest (#1) #2 #3 {
  \group_begin:
  \dim_set:Nn #3 { 0pt }
  \clist_map_inline:nn { #1 } {
    \hbox_set:Nn \l_tmpa_box { #2{##1} }
    \dim_set:Nn \l_tmpa_dim { \dim_eval:n { \box_wd:N \l_tmpa_box } }
    \dim_compare:nNnT { #3 } < { \l_tmpa_dim } {
      \dim_set_eq:NN #3 \l_tmpa_dim
    }
  }
  \exp_args:NNNV
  \group_end:
  \dim_set_eq:NN #3 #3
}
\ExplSyntaxOff

%    \end{macrocode}
% \section{\pkg{pygmentex} implementation}
%    \begin{macrocode}
% =========================================================
% fancyvrb new commands to append to a file
% =========================================================

% See http://tex.stackexchange.com/questions/47462/inputenc-error-with-unicode-chars-and-verbatim

\ExplSyntaxOn

\seq_new:N \l_NLN_records_seq

\long\def\unexpanded@write#1#2{\write#1{\unexpanded{#2}}}

\def\VerbatimOutAppend{\FV@Environment{}{VerbatimOutAppend}}

\def\FVB@VerbatimOutAppend#1{%
  \@bsphack
  \begingroup
    \seq_clear:N \l_NLN_records_seq
    \FV@UseKeyValues
    \FV@DefineWhiteSpace
    \def\FV@Space{\space}%
    \FV@DefineTabOut
    \def\FV@ProcessLine{%##1
%      \seq_put_right:Nn \l_NLN_records_seq { ##1 }%
      \immediate\unexpanded@write#1%{##1}
    }%
    \let\FV@FontScanPrep\relax
    \let\@noligs\relax
    \FV@Scan
}

\def\FVE@VerbatimOutAppend{
  \seq_use:Nn \l_NLN_records_seq /
  \endgroup
  \@esphack
}

\DefineVerbatimEnvironment{VerbatimOutAppend}{VerbatimOutAppend}{}
% =========================================================
% Main options
% =========================================================

\newif\ifNLN@left
\newif\ifNLN@right


%    \end{macrocode}
% \section{Display technology}
% Inserting code snippets follows one of two modes: run or block.
% The former is displayed as running text and used by the \cs{NLNCode} command
% whereas the latter is displayed as a separate block and used
% by the |NLN/Code| environment. Both have one single required argument,
% which is a \meta{key-value} configuration list named \texttt{NLN_code}.
% The contents is then colorized with the aid of \NLNPy{}
% which will return some code enclosed within an environment created
% by one of \cs{NLNNewRunMethod}, \cs{NLNRenewRunMethod}, \cs{NLNNewBlockMethod},
% \cs{NLNRenewBlockMethod} functions.
% \subsection{\cs{NLNCode} run function}
% Only the body of the {NLN/Code} environment may be exported.
% \begin{function}{\NLNCode}
% \begin{syntax}
% \cs{NLNCode}\marg{configuration}\meta{delimiter}\meta{code}\meta{same delimiter}
% \end{syntax}
% \end{function}
%    \begin{macrocode}
\NewDocumentCommand \NLNCode { mm } {
  \group_begin:
    \prop_concat:ccc {l_NLN_prop} {c_empty_prop} {g/NLN/prop} % NO \prop_set_eq:Nc
    \cs_set:Npn \NLN_put:nn ##1 ##2 {
      \prop_put:Nnn \l_NLN_prop { ##1 } { ##2 }% expand the value?
    }
    \keys_set:nn { NLN } { #1 }
    \directlua{NLN:options_reset()}
    \prop_map_inline:Nn \l_NLN_prop {
      \lua_now:e {NLN:option_add('\lua_escape:n {##1}', '\lua_escape:n {##2}')}
    }
    VERB:#2
    \DefineShortVerb{#2}%
    \SaveVerb
      [aftersave={%
       \UndefineShortVerb{#2}%
       \lua_now:e {NLN:process_run('FV@SV@NLN')}
       \group_end:
      }]%
      {NLN}#2%
}
%    \end{macrocode}
%
% \subsection{\texttt{NLN/Code} environment}
% \subsection{Creating display methods}
% \begin{function}{\NLNNewRunMethod, \NLNRenewRunMethod, \NLNNewBlockMethod, \NLNRenewBlockMethod}
% \begin{syntax}
% \cs{NLNNewRunMethod}\marg{method name}\marg{method body}
% \cs{NLNRenewRunMethod}\marg{method name}\marg{method body}
% \cs{NLNNewBlockMethod}\marg{method name}\marg{begin instructions}\marg{end instructions}
% \cs{NLNRenewBlockMethod}\marg{method name}\marg{begin instructions}\marg{end instructions}
% \end{syntax}
% \marg{method name} is a non void string.
% The run methods create a command with a unique argument which the colored code.
% The block methods create an environent.
% The body of the environment is available in the \cs{NLNBody} variable.
% The options passed with the \texttt{options} key are available in the \cs{NLNOptions} variable.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \NLNNewRunMethod #1 #2 {
  \cs_new:cpn { NLN/colored/run/#1: } ##1 {
    #2
  }
  \ignorespaces
}
\cs_new:Npn \NLNRenewRunMethod #1 #2 {
  \tl_if_empty:nTF { #1 } {
    \PackageWarning
    { NLN/method }
    { The~method~cannot~be~void. }
  } {
    \cs_if_exist:cTF { NLN/colored/run/#1: } {
      \cs_set:cpn { NLN/colored/run/#1: } ##1 {
        #2
      }
    } {
      \PackageWarning
      { NLN/method }
      { No~run~method~#1.}
    }
  \ignorespaces
  }
}
\cs_new:Npn \NLNNewBlockMethod #1 #2 #3 {
  \NewDocumentEnvironment { NLN/colored/block/#1 } { +b } {
    \exp_args:NNx \tl_set:Nn \NLNOptions { \NLN:n { options } }
    \tl_set:Nn \NLNBody { #1 }
    #2
  } { #3 }
}
\cs_new:Npn \NLNRenewBlockMethod #1 #2 #3 {
  \tl_if_empty:nTF { #1 } {
    \PackageWarning
    { NLN/method }
    { The~method~cannot~be~void. }
    \use_none:nn
  } {
    \RenewDocumentEnvironment { NLN/colored/block/#1 } { +b } {
      \exp_args:NNx \tl_set:Nn \NLNOptions { \NLN:n { options } }
      \def \NLNBody { #1 }
      #2
    } { #3 }
  }
}
%    \end{macrocode}
% \subsection{Run mode default method}
%    \begin{macrocode}
\NLNNewRunMethod {} {
} {
}
%    \end{macrocode}
% \subsection{Run mode \texttt{efbox} method}
% \begin{function}[EXP]{NLNCallWithOptions}
% \begin{syntax}
% \cs{NLNCallWithOptions}\meta{cs}
% \end{syntax}
% Call \meta{cs}, assuming it has a first optional argument.
% It will receive the arguments passed to \cs{NLNCode} with the \texttt{options} key.
% \end{function}
%    \begin{macrocode}
\cs_new:Npn \NLNCallWithOptions #1 {
  \exp_last_unbraced:NNx
  #1[\NLN:n { options }]
}
\NLNNewRunMethod {efbox} {
  \NLNCallWithOptions\efbox{#1}%
}
%    \end{macrocode}
% \subsection{Block mode default method}
%    \begin{macrocode}
\NLNNewBlockMethod {} {
} {
}
%    \end{macrocode}
%
% \subsection{key-value action}
% \begin{description}
% \item[\ttfamily method=\meta{method name}], where \meta{method name} is recognized by \pkg{\jobname}
% \end{description}
%    \begin{macrocode}
\keys_define:nn { NLN/.method } {
  method .code:n = \NLN_put:nn { method } { #1 },
}
%    \end{macrocode}

% \section{Shared key-value controls}
% These declare the interface of the various commands and environments.
% \subsection{\pkg{\jobname} key-value controls}
% Each action is meant to store the values in a code property, for the almost eponym key.
% The setter is \cs{NLN_put:nn} except for options which is \cs{NLN_option_put:nn}.
% These are defined just before reading the options.
% Keys are:
%    \begin{macrocode}
\tl_new:N \l_NLN_options_tl
\keys_define:nn { NLN } {
%    \end{macrocode}
% \begin{description}
% \item[\ttfamily lang=\meta{language name}], where \meta{language name} is recognized by \texttt{pygment},
% \item[\ttfamily method=\meta{method name}], switcher for different methods,
% \item[\ttfamily lineno{[=true/false]}] to display the line numbers, or not,
%    \begin{macrocode}
  lineno .code:n = \NLN_put:nn { show_lineno } { #1 },
  lineno .default:n = true,
%    \end{macrocode}
% \item[\ttfamily name{[=true/false]}] to display the chunk names
%    \begin{macrocode}
  name .code:n = \NLN_put:nn { show_name } { #1 },
  name .default:n = true,
%    \end{macrocode}
% \item[\ttfamily only top] to avoid chunk names repetitions, if on the same page,
% two consecutive code chunks have the same chunk names, the second names are not displayed.
%    \begin{macrocode}
  only~top .code:n = \NLN_put:nn { only_top } { #1 },
  only~top .default:n = true,
%    \end{macrocode}
% \item[\ttfamily ignore] to ignore chunks.
%    \begin{macrocode}
  ignore .code:n = \NLN_put:nn { ignore } { #1 },
  ignore .default:n = true,
%    \end{macrocode}
% \item[\ttfamily margin{[=true/false]}] to use the magin to display line numbers, or not,
%    \begin{macrocode}
  margin .code:n = \NLN_put:nn { use_margin } { #1 },
  margin .default:n = true,
%    \end{macrocode}
% \item[\ttfamily format=\meta{kv format items}], where \meta{kv format items} are detailed below,
% \item[\ttfamily format/code=\meta{format}], where \meta{format} is used to display the code (mainly font, size and color),
% \item[\ttfamily format/lineno=\meta{format}], where \meta{format} is used to display the line numbers (mainly font, size and color),
% \item[\ttfamily name format=\meta{format}], where \meta{name format} is used to display the chunk names (mainly font, size and color),
%    \begin{macrocode}
  format .code:n = \keys_set:nn {NLN/format} { #1 },
%    \end{macrocode}
% \item[\ttfamily sep] the separation with the surrounding text,
% \item[\ttfamily parskip] the value of the \cs{parskip} in inline code blocks,
% \item[\ttfamily baselinestretch] the value of the \cs{baselinestretch} in inline code blocks,
% \item[\ttfamily test] whether the chunk is a test,
%    \begin{macrocode}
  test .code:n = \NLN_put:nn { is_test } { #1 },
  test .default:n = true,
%    \end{macrocode}
% \item[\ttfamily anything] forwards to,
%    \begin{macrocode}
  unknown .code:n = {
    \group_begin:
    \exp_args:NnV
    \regex_extract_once:nnNTF { ^options/(.*) } \l_keys_key_str \l_tmpa_seq {
      \tl_set:Nx \l_tmpa_tl { \seq_item:Nn \l_tmpa_seq { 1 } }
      \tl_put_right:Nn \l_tmpa_tl { = #1 }
      \exp_args:NNnV
      \group_end:
      \keys_set:nn { NLN/options } \l_tmpa_tl
    } {
    		\group_end:
    }
  },
%    \end{macrocode}
% \end{description}
%    \begin{macrocode}
}
%    \end{macrocode}
% \subsection{\texttt{options} key-value controls}
% We accept any value because we do not know in advance the real target.
% Everything is collected in \cs{l_NLN_options_clist}.
% \begin{variable}{\l_NLN_options_clist}
% All the \meta{key[=value] items} passed as options are collected here.
% This hould be cleared before arguments are parsed.
% \end{variable}
%    \begin{macrocode}
\clist_new:N \l_NLN_options_clist
%    \end{macrocode}
% There are 2 ways to collect options:
%    \begin{macrocode}
\keys_define:nn { NLN/options } {
  unknown .code:n = {
    \group_begin:
    \tl_set_eq:NN \l_tmpa_tl \l_keys_key_str
    \tl_put_right:Nn \l_tmpa_tl { = #1 }
    \exp_args:NNNV
    \group_end:
    \clist_put_right:Nn \l_NLN_options_clist \l_tmpa_tl
  }
}
%    \end{macrocode}
% \begin{description}
% \item[\ttfamily options=\meta{options key value items}], where \meta{options key value items} are
% display options forwarded to other packages.
%    \begin{macrocode}
  options .code:n = {
    \clist_put_right:Nn \l_NLN_options_clist { #1 }
  },
%    \end{macrocode}
% \end{description}
% \section{Something else}
% some settings used by fancyvrb:
% * for line numbering:
%     numbers, numbersep, firstnumber, stepnumber, numberblanklines
% * for selection of lines to print:
%     firstline, lastline,
%    \begin{macrocode}
\pgfkeys{%
  /NLN/.cd,
  % 
  % 
  lang/.code           = \NLN_put:nn {lang} { #1 },
  sty/.code            = \NLN_put:nn {sty} { #1 },
  escapeinside/.code   = \NLN_put:nn {escapeinside} { #1 },
  texcomments/.code    = \NLN_put:nn {texcomments} { #1 },% boolean
  mathescape/.code     = \NLN_put:nn {mathescape} { #1 },% boolean
  % 
  label/.code          = \NLN_put:nn {label} { #1 },
  caption/.code        = \NLN_put:nn {caption} { #1 },
  % 
  gobble/.code         = \NLN_put:nn {gobble} { #1 },
  tabsize/.code        = \NLN_put:nn {tabsize} { #1 },
  % 
  linenos/.code        = \NLN_put:nn {linenos} { #1 },% boolean
  linenostart/.code    = \NLN_put:nn {linenostart} { #1 },
  linenostep/.code     = \NLN_put:nn {linenostep} { #1 },
  linenosep/.code      = \NLN_put:nn {linenosep} { #1 },
  %
  colback/.code        = \NLN_put:nn {colback} { #1 },
  font/.code           = \NLN_put:nn {font} { #1 },
  % 
  texcomments/.default = true,
  mathescape/.default  = true,
  linenos/.default     = true,
}

\pgfqkeys{/NLN}{
  boxing~method = mdframed,
  inline~method = efbox,
  sty           = default,
  linenos       = false,
  linenosep     = 2pt,
  font          = \ttfamily,
  tabsize       = 0,
}

% =========================================================
% pygmented commands and environments
% =========================================================

\newwrite\NLN@outfile

\newcount\NLN@counter

\newcommand\NLN@process@options[1]{%
  \pgfkeys{%
    /pgf/key~filters/defined/.install~key~filter,%
    /pgf/key~filter~handlers/append~filtered~to/.install~key~filter~handler=\NLNRemainingGlobalOptions
  }%
  \def\NLNRemainingGlobalOptions{}%
  \pgfkeysalsofilteredfrom{\NLN@global@options}%
  \pgfkeysalso{%
    /pgf/key~filter~handlers/append~filtered~to/.install~key~filter~handler=\NLNRemainingUserOptions
  }%
  \def\NLNRemainingUserOptions{}%
  \pgfqkeysfiltered{/NLN}{#1}%
  % %%%%%%% DEBUGING
  % \typeout{}%
  % \typeout{\string\NLN@global@options:}\typeout{\meaning\NLN@global@options}%
  % \typeout{\string\NLNRemainingGlobalOptions:}\typeout{\meaning\NLNRemainingGlobalOptions}%
  % \typeout{\string\NLNRemainingUserOptions:}\typeout{\meaning\NLNRemainingUserOptions}%
  % 
  \fvset{gobble=0,tabsize=0}%
}

\newcommand\NLN@process@more@options[1]{%
  \pgfkeysalso{%
    /pgf/key~filters/false/.install~key~filter,%
    /pgf/key~filter~handlers/append~filtered~to/.install~key~filter~handler=\NLNRemainingOptions
  }%
  \def\NLNRemainingOptions{}%
  \pgfkeysalsofilteredfrom{\NLNRemainingGlobalOptions}%
  \cs_if_exist:cT {NLN@#1@more@options} {
    \exp_args:Nx
    \pgfkeysalsofilteredfrom { \use:c{NLN@#1@more@options}, }
  }
  \pgfkeysalsofilteredfrom{\NLNRemainingUserOptions}%
  % %%%%%%% DEBUGING
  % \typeout{}%
  % \typeout{\string\NLNRemainingOptions:}%
  % \typeout{\meaning\NLNRemainingOptions}%
}

\newcommand\inputpygmented[2][]{%
  \begingroup
    \NLN@process@options{#1}%
    \immediate\write\NLN@outfile{<@@NLN@input@\the\NLN@counter}%
    \immediate\write\NLN@outfile{\exp_args:NV\detokenize\NLN@global@options,\detokenize{#1}}%
    \immediate\write\NLN@outfile{#2}%
    \immediate\write\NLN@outfile{>@@NLN@input@\the\NLN@counter}%
    %
    \csname NLN@snippet@\the\NLN@counter\endcsname
    \global\advance\NLN@counter by 1\relax
  \endgroup
}

\NewDocumentEnvironment{pygmented}{+O{}m}{%
  \lua_now:e {NLN:start_recording()}
  \NLN@process@options{#1}%
  \immediate\write\NLN@outfile{<@@NLN@display@\the\NLN@counter}%
  \immediate\write\NLN@outfile{
    \exp_args:NV\detokenize\NLN@global@options,\detokenize{#1}
  }%
  \VerbatimEnvironment
  \begin{VerbatimOutAppend}{\NLN@outfile}%
}{%
  \end{VerbatimOutAppend}%
  \immediate\write\NLN@outfile{>@@NLN@display@\the\NLN@counter}%
  \csname NLN@snippet@\the\NLN@counter\endcsname
  \global\advance\NLN@counter by 1\relax
}

\cs_generate_variant:Nn \exp_last_unbraced:NnNo { NxNo }

\newcommand\NLN@snippet@inlined[1]{%
  \group_begin:
  \typeout{DEBUG~PY~STYLE:<\NLN@opt@style>}
  \use_c:n { PYstyledefault }
  \tl_if_empty:NF \NLN@opt@style {
    \use_c:n { PYstyle\NLN@opt@style }
  }
  \cs_if_exist:cTF {PY} {PYOK} {PYKO}
  \NLN@opt@font
  \NLN@process@more@options{ \NLN:n { inline_method} }%
  \exp_last_unbraced:NxNo
  \use:c { \NLN:n { inline_method } } [ \NLNRemainingOptions ]{#1}%
  \group_end:
}

% ERROR: JL undefined \NLN@alllinenos

\ProvideDocumentCommand\captionof{mm}{}
\def\NLN@alllinenos{(0)}
\prg_new_conditional:Nnn \NLN_yorn:n { T, F, TF } {
  \group_begin:
  \prop_get:cnNT {g/NLN/code/} { #1 } \l_tmpa_tl {
    \exp_args:NnV
    \regex_match:nnT {^[tTyY]} \l_tmpa_tl {
      \group_end:
      \prg_return_true:
    }
  }
  \group_end:
  \prg_return_false:
}
\newenvironment{NLN@snippet@framed}{%
  \group_begin:
  \NLN@leftmargin\z@
  \NLN_yorn:nT {linenos} {
    \expandafter \NLNWidest\NLN@alllinenos{\FormatLineNumber}{\NLN@leftmargin}%
    \exp_args:NNx
    \advance\NLN@leftmargin { \NLN:n {linenosep} }
  }
  %
  \tl_clear:N \l_NLN_tl
  \NLN:nNTF {label} \l_tmpa_tl {
    \tl_set:N \l_NLN_tl {%
      \captionof{pygcode}{\label{\NLN:n {label}} \NLN:n {caption}}%
      % \nopagebreak
      \vskip -0.7\baselineskip
    }%
  } {
    \NLN:nNT {caption} \l_tmpa_tl {
      \tl_set:N \l_NLN_tl {%
        \captionof {pygcode} {\l_tmpa_tl}%
        % \nopagebreak
        \vskip -0.7\baselineskip
      }%
    }
  }
  \l_NLN_tl
  %
  \exp_args:Nx \tl_if_empty:nF { \NLN:n {boxing_method} } {
    \exp_args:Nx
    \NLN@process@more@options { \NLN:n {boxing_method} }%
    \exp_last_unbraced:NxNo
    \begin { \NLN:n {boxing_method} } [ \NLNRemainingOptions ]
  }
  \csname PYstyle\NLN@opt@style\endcsname
  \NLN@opt@font
  \noindent
} {
  \exp_args:Nx \tl_if_empty:nF { \NLN:n {boxing_method} } {
    \exp_args:Nx
    \end { \NLN:n {boxing_method} }
  }
  \group_end:
}


\def\FormatLineNumber#1{{\rmfamily\tiny#1}}


\newdimen\NLN@leftmargin
\newdimen\NLN@linenosep

\def\NLN@lineno@do#1{%
  \NLN@linenosep 0pt%
  \use:c { NLN@ \NLN:n {boxing_method} @margin }
  \exp_args:NNx
  \advance \NLN@linenosep { \NLN:n {linenosep} }
  \hbox_overlap_left:n {%
    \FormatLineNumber{#1}%
    \hspace*{\NLN@linenosep}}%
}

\newcommand\NLN@tcbox@more@options{%
  nobeforeafter,%
  tcbox~raise~base,%
  left=0mm,%
  right=0mm,%
  top=0mm,%
  bottom=0mm,%
  boxsep=2pt,%
  arc=1pt,%
  boxrule=0pt,%
  \NLN_options_if_in:nT {colback} {
    colback=\NLN:n {colback}
  }
}

\newcommand\NLN@mdframed@more@options{%
  leftmargin=\NLN@leftmargin,%
  frametitlerule=true,%
  \NLN_if_in:nT {colback} {
    backgroundcolor=\NLN:n {colback}
  }
}

\newcommand\NLN@tcolorbox@more@options{%
  grow~to~left~by=-\NLN@leftmargin,%
  \NLN_if_in:nNT {colback} {
    colback=\NLN:n {colback}
  }
}

\newcommand\NLN@boite@more@options{%
  leftmargin=\NLN@leftmargin,%
  \ifcsname NLN@opt@colback\endcsname
    colback=\NLN@opt@colback,%
  \fi
}

\newcommand\NLN@mdframed@margin{%
  \advance \NLN@linenosep \mdflength{outerlinewidth}%
  \advance \NLN@linenosep \mdflength{middlelinewidth}%
  \advance \NLN@linenosep \mdflength{innerlinewidth}%
  \advance \NLN@linenosep \mdflength{innerleftmargin}%
}

\newcommand\NLN@tcolorbox@margin{%
  \advance \NLN@linenosep \kvtcb@left@rule
  \advance \NLN@linenosep \kvtcb@leftupper
  \advance \NLN@linenosep \kvtcb@boxsep
}

\newcommand\NLN@boite@margin{%
  \advance \NLN@linenosep \boite@leftrule
  \advance \NLN@linenosep \boite@boxsep
}

\def\NLN@global@options{}

\newcommand\setpygmented[1]{%
  \def\NLN@global@options{/NLN/.cd,#1}%
}


% =========================================================
% final actions
% =========================================================

\AtEndOfPackage{%
  \IfFileExists{\jobname.pygmented}{%
    \input{\jobname.pygmented}%
  }{%
    \PackageWarning{inline}{File `\jobname.pygmented' not found.}%
  }%
  \immediate\openout\NLN@outfile\jobname.snippets%
}

\AtEndDocument{%
  \closeout\NLN@outfile%
}
\ExplSyntaxOff
%    \end{macrocode}
%    \begin{macrocode}
%</sty>
%    \end{macrocode}
% \end{implementation}
%\Finale
%
% % ^^A \PrintIndex
