% \iffalse meta-comment
% !TEX program  = lualatex
% !TEX encoding  = utf8
%<*internal>
\iffalse
%</internal>
%<*readme>
# The coder package

Usually, documentation is put inside the code,
the coder package allows to work the other way round
by putting code inside the documentation.
This is particularly interesting when different code files share some logic
and should be documented all at once.

The file coder-manual.pdf gives different examples.

The file coder-beamer.pdf gives a demo of what can be achieved with beamer.

This LaTeX package requires LuaTeX and may use syntax coloring based on the pygments package.

----------------------------------------------------------------
coder --- description text
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\def\MetaPrefix{}
\declarepreamble\PreambleRaw
----------------------------------------------------------------
\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/coder
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\def\MetaPrefix{--}
\declarepreamble\PreambleLua

\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/coder
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt

\endpreamble
{
\catcode`\#=11
\global\def\MetaPrefix{#}
}
\declarepreamble\PreamblePy

\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/coder
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt

\endpreamble

\edef\PreamblePy {%
\MetaPrefix!/usr/bin/env python3^^J\MetaPrefix\space -*- coding: utf-8 -*-^^J\PreamblePy
}

\def\MetaPrefix{\DoubleperCent}
\declarepreamble\PreambleSty
\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later

Copyright (C) 2022 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  \jobname.dtx
and the derived files           \jobname.ins,
                                \jobname.pdf,
                                \jobname-util.lua,
                                \jobname-tool.py and
                                \jobname.sty.

\endpreamble
\nopostamble
\usedir{tex/latex/coder}
\usepreamble\PreambleSty
\def\MetaPrefix{\DoubleperCent}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{sty}}
}
\usepreamble\PreambleLua
\def\MetaPrefix{--}
\usedir{scripts/coder}
\generate{
  \file{\jobname-util.x.lua}{\from{\jobname.dtx}{lua}}
}
\generate{
  \file{\jobname-util.lua}{\from{\jobname.dtx}{lua}}
}
\usepreamble\PreamblePy
{
\catcode`\#=11
\global\def\MetaPrefix{#}
}
\usedir{scripts/coder}
\generate{
  \file{\jobname-tool.x.py}{\from{\jobname.dtx}{py}}
}
\generate{
  \file{\jobname-tool.py}{\from{\jobname.dtx}{py}}
}
\nopreamble\nopostamble
\usedir{doc/latex/coder}
\generate{
  \file{README.md}{\from{\jobname.dtx}{readme}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/coder}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver,sty>
\def\CDRFileDate{2022/02/07}
\def\CDRFileVersion{1.0a}
%</driver,sty>
%<*sty>
\ProvidesExplPackage{coder}
  {\CDRFileDate}
  {\CDRFileVersion}
  {code inlined in documents}

\NeedsTeXFormat{LaTeX2e}
\ExplSyntaxOff

\RequirePackage{fontspec, xcolor, fancyvrb}
\RequirePackage{ifthen}
\AddToHook { begindocument / before } {
  \RequirePackage{datetime2}
}
\ExplSyntaxOn
\msg_new:nnn { coder } { :n } { #1 }
\cs_if_exist:NTF\IfFormatAtLeastTF {
  \IfFormatAtLeastTF{2021/06/01} {} {
    \msg_fatal:nnn { coder } { :n } { Please~update~LaTeX.~Emergency~stop }
  }
} {
  \msg_fatal:nnn { coder } { :n } { Please~update~LaTeX.~Emergency~stop }
}
%</sty>
%<*driver>
\ExplSyntaxOff
\documentclass{l3doc}
\RequirePackage{fancyvrb}
\RequirePackage{emoji}
%\RequirePackage{unicode-math}
%\setmathfont{Latin Modern Math}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\newcommand{\lua} {\pkg{lua}}
\newcommand{\CDRSty}{\pkg{\jobname.sty}}
\newcommand{\CDRLua}{\pkg{\jobname-util.lua}}
\newcommand{\CDRPy} {\pkg{\jobname-tool.py}}
\newcommand{\metatt} [1] {\texttt{\meta{#1}}}
\ExplSyntaxOn
\NewDocumentCommand\CDRCheckGreen{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{check-mark-button}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckRed{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{stop-sign}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckOrange{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{white-question-mark}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckProhibited{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{prohibited}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckInternal{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{gear}}
  \ttfamily\hspace{#1}\vphantom{.}
}}

\makeatletter
\@addtoreset{FancyVerbLine}{part}
\ExplSyntaxOn
\define@booleankey{FV}{OK}
  {\def\DCR@possibly@in@progress{\color{gray}}}
  {\def\DCR@possibly@in@progress{\color{red}}}
\define@booleankey{FV}{construction}
  {\def\DCR@possibly@in@progress{\color{red}}}
  {\def\DCR@possibly@in@progress{\color{gray}}}
\fvset{construction}
\def\FVB@MacroCode{
  \@bsphack
  \FV@VerbatimBegin
  \renewcommand{\theFancyVerbLine}{{
    \DCR@possibly@in@progress
    \scriptsize
    \arabic{FancyVerbLine}
  }}
  \FV@Scan
}
\def\FVE@MacroCode{
  \FV@VerbatimEnd
  \@esphack
}
\ExplSyntaxOff
\DefineVerbatimEnvironment{MacroCode}{MacroCode}{
  numbers=left,
  resetmargins=true,
  firstnumber=last,
  gobble=0,
  numbersep=1ex,
  fontsize=\small,
}

\newcommand{\CDRPygVerbatim} {CDR@Pyg@Verbatim}
\makeatother
\NewDocumentCommand \itemtt { o }{^^A
  \IfNoValueTF { #1 } {
    \item
  } {
    \item[\ttfamily#1]
  }
}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%\title{^^A
%  \textsf{\jobname}\\
% code inlined in a \LaTeX\ document\\
% \LaTeX\ inlined in a code source%}
%\author{^^A
%  Jérôme LAURENS\thanks{E-mail: jerome.laurens@u-bourgogne.fr}^^A
%}
%\date{Released \CDRFileDate\thanks{This file describes version \CDRFileVersion.}}
%
%\maketitle
%
% \begin{documentation}
%
%\changes{v1.0a}{2022/01/20}{First public release}
%
% \begin{abstract}
% Usually, documentation is put inside the code,
% \pkg{\jobname} allows to work the other way round
% by putting code inside the documentation.
% This is particularly interesting when different code files share some logic
% and should be documented all at once.
%
% The file \url{coder-manual.pdf} gives different examples. Here is the implementation of the package.
%
% This \LaTeX{} package requires \LuaTeX{} and may use syntax coloring based on the \pkg{pygments}\footnote{The \pkg{\jobname} package has been tested with \pkg{pygments} version 2.11.2} package.
% \end{abstract}
%
% \section{Package dependencies}
% \pkg{datetime2}, \pkg{xcolor}, \pkg{fancyvrb} and dependencies of these packages.
%
% \section{Similar technologies}
% \begin{description}
% \item The \pkg{docstrip} utility offers similar features,
% it is on some respect more powerful than \pkg{\jobname} at the cost of
% more technicality and less practicality,
% \item The \pkg{ydoc.cls} and \pkg{skdoc.cls} are
% full document classes with similar features but
% many more that are unrelated.
% \pkg{\jobname} focuses on code inlining and interfaces very well with \pkg{pygments}
% for a smart and efficient syntax hilighting.
% \item The \pkg{pygmentex} and \pkg{minted} packages were somehow a source of inspiration.
% \end{description}
%
% \section{Known bugs and limitations}
% \begin{itemize}
% \item
% \pkg{\jobname} does not play well with \pkg{docstrip}.
% \item
% \pkg{\jobname} exportation does not play well with \pkg{beamer}.
% \end{itemize}
%
% \end{documentation}
% 
% \begin{implementation}
%
% \section{Presentation}
% \pkg{\jobname} is a triptych of three complementary components
% \begin{enumerate}
% \item \CDRSty, on the \LaTeX{} side,
% \item \CDRLua, to manage some data and call \CDRPy,
% \item \CDRPy, to color code with the help of \pkg{pygments}.
% \end{enumerate}
% \CDRSty{} mainly declares the \cs{CDRCode} command and the |CDRBlock| environment.
% The former allows to insert code chunks as running text whereas the latter allows
% to instert code snippets as blocks.
% Moreover, block code chunks can be exported to files, once declared with \cs{CDRExport} command.
% The \cs{CDRSet} command is used to set various parameters,
% including display engines declared with either \cs{CDRCodeEngineNew} or \cs{CDRBlockEngineNew}\footnote{Work in progress}.
%
% \subsection{Code flow}
% The normal code flow is
% \begin{enumerate}
% \item from \CDRSty{}, \LaTeX{} parses a code snippet as |\CDRCode| argument
% of |CDRBlock| environment body, somehow stores it,
% and calls |CDR:hilight_source|,
% \item \CDRLua{} reads the content of some command, and stores it in a |json| file,
% together with informations to process this code snippet properly,
% \item \CDRPy{} is then asked by \CDRLua{} to read the |json| file and eventually uses \pkg{pygments} to translate
% the code snippet into dedicated \LaTeX{} coloring commands. These are stored in a |*.pyg.tex| file
% named after the md5 digest of the original code chunck,
% a |*.pyg.sty| \LaTeX{} style file is recorded as well.
% On return, \CDRSty{} is able to input both the |*.pyg.sty| and
% the |*.pyg.tex| file, which are finally executed and the code is displayed with colors.
% \CDRPy{} is also partially responsible of code line numbering
% in conjunction with \CDRSty{}.
% \end{enumerate}
%
% The package \CDRSty{} only exchanges with \CDRLua{} using |\directlua|, |tex.print| and |token.get_macro|.
% \CDRPy{} in turn only exchanges with \CDRLua{}:
% we put in \CDRPy{} as few \LaTeX{} logic as possible.
% It receives instructions from \CDRSty{} as command line arguments,
% \LaTeX{} options, \pkg{pygments} options and \pkg{fancyvrb} options.
%
% \subsection{File exportation}
% \begin{enumerate}
% \item
% The \cs{CDRExport} command declares a file path, a list of tags and other
% usefull informations like a coding language. These data are saved as export records
% by \CDRLua.
% \item
% When some |tags={...}| have been given to the |CDRBlock| environment,
% the \CDRLua{} records the corresponding code chunk and its associate tags for
% later save. 
% \item
% Once the typesetting process is complete, \CDRLua{}'s |CDR_export_...| methods
% are called to save all the files externally. For each export record,
% \CDRLua{} collects all the chunks with the same tag and save them
% at the proper location.
% \end{enumerate}
%
% \subsection{Display engine}
% The display management is partly delegated to other packages.
% \CDRSty{} provides default engines for running code and code blocks,
% and new engines can be declared with \cs{CDRCodeEngineNew}
% and \cs{CDRBlockEngineNew}.
% 
% \subsection{\LaTeX{} user interface}
% The first required argument of both commands and environment
% is a \metatt{key[=value] controls} list managed by \pkg{l3keys}.
% Each command requires its own \pkg{l3keys} module but some
% \metatt{key[=value] controls} are shared between modules.

% \subsection{Properties and inheritance}
% Properties cover various informations, from the language of the code,
% to the color and font. They are uniquely identified by a path component,
% the \emph{tag}, which is used for inheritance. All tags starting with
% two leading underscore characters are reserved by the package.
% Other tags are at the user disposal.
%
% Each processed code chunk has a list of associate tags.
% Most tag inherits from default ones.
%
% \section{Namespace and conventions}
% \LaTeX{} identifiers related to \pkg{\jobname} start with |CDR|,
% including both commands and evironment.
% \pkg{expl3} identifiers also start with |CDR|, after and eventual leading |c_|, |l_| or |g_|.
% \pkg{l3keys} module path's first component is either |CDR|
% or starts with |CDR@|.
%
% \lua{} objects (functions and variables) are collected
% in the \texttt{CDR} table automatically created
% while loading \CDRLua{} from \CDRSty{}.
%
% The |c| argument specifier is used here in a more general acception.
% Normaly , it means that the argument is turned to a command sequence name.
% Here, it means that the argument is part of something bigger
% which is turned to a command sequence name.
% As such, there is no need to explictly expand such an argument.
%
% \section{Options}
% Key-value options allow the user, \CDRSty{}, \CDRLua{} and \CDRPy{} to exchange
% data. What the user is allowed to do is illustrated in \url{coder-manual.pdf}.
%
% \subsection{\pkg{fancyvrb}}
% These are \pkg{fancyvrb} options verbatim.
% The \pkg{fancyvrb} manual has more details, only some parts are reproduced hereafter.
% All of these options may not be relevant for all situations.
% Some of them make no sense in |code| mode, whereas others may not be
% compatible with the display engine.
%
% \begin{description}
% \itemtt[\CDRCheckRed formatcom=\meta{command}]^^A
% execute before printing verbatim text.
% Initially empty.
% Ignored in |code| mode.
% \itemtt[\CDRCheckRed fontfamily=\meta{family name}]^^A
% font family to use. |tt|, |courier| and |helvetica| are pre-defined.
% Initially \texttt{tt}.
% \itemtt[\CDRCheckRed fontsize=\meta{font size}]^^A
% size of the font to use. If you use the \pkg{relsize} package as well,
% you can require a change of the size proportional to the current one
% (for instance: |fontsize=\relsize{-2}|).
% Initially \texttt{auto}: the same as the current font.
% \itemtt[\CDRCheckRed fontshape=\meta{font shape}]^^A
% font shape to use. Initially \texttt{auto}: the same as the current font.
% \itemtt[\CDRCheckRed showspaces{[=true$\vert$false]}]^^A
% print a special character representing each space.
% Initially |false|: spaces not shown.
% \itemtt[\CDRCheckRed showtabs=true$\vert$false]^^A
% explicitly show tab characters.
% Initially |false|: tab characters not shown.
% \itemtt[\CDRCheckRed obeytabs=true$\vert$false]^^A
% position characters according to the tabs.
% Initially false: tab characters are added to the current position.
% \itemtt[\CDRCheckRed tabsize=\meta{integer}]^^A
% number of spaces given by a tab character,
% Initially 2 (8 for \pkg{fancyvrb}).
% \itemtt[\CDRCheckRed defineactive=\meta{macro}]^^A
% to define the effect of active characters.
% This allows to do some devious tricks, see the \pkg{fancyvrb} package.
% Initially empty.
% \itemtt[\CDRCheckGreen reflabel=\meta{label}]^^A
% define a label to be used with |\pageref|.
% Initially empty.
% \itemtt[\CDRCheckRed commentchar=\meta{character}]^^A
% lines starting with this character are ignored.
% Initially empty.
% \itemtt[\CDRCheckRed gobble=\meta{integer}]^^A
% number of characters to suppress
% at the beginning of each line (from 0 to 9),
% mainly useful when environments are indented.
% Only |block| mode.
% \itemtt[\CDRCheckRed frame=none$\vert$leftline$\vert$topline$\vert$bottomline$\vert$lines$\vert$single]^^A
% type of frame around the verbatim environment.
% With \texttt{leftline} and \texttt{single} modes, a space of a length given
% by the \LaTeX{} |\fboxsep| macro is added between the left vertical line
% and the text. Initially \texttt{none}: no frame.
% \itemtt[\CDRCheckRed label={\{[\meta{top string}]^^A
%\meta{string}\}}]
% label(s) to print on top, bottom or both, frame lines.
% If the label(s) contains special characters, comma or equal sign,
% it must be placed inside a group.
% If an optional \metatt{top string} is given between square brackets,
% it will be used for the top line and \metatt{string} for the bottom line.
% Otherwise, \metatt{string} is used for both the top or bottom lines.
% Label(s) are printed only if the \texttt{frame} parameter is one of
% \texttt{topline}, \texttt{bottomline}, \texttt{lines} or \texttt{single}.
% Initially empty: no label.
% \itemtt[\CDRCheckRed labelposition=none$\vert$topline$\vert$bottomline$\vert$all]^^A
% position where to print the label(s) when defined.
% When options happen to be contradictory,
% like |frame=topline| and  |labelposition=bottomline|,
% nothing is displayed.
% Initially |none| when no labels are defined,
% |topline| for one label and |all| otherwise.
% \itemtt[\CDRCheckRed numbers=none$\vert$left$\vert$right]^^A
% numbering of the verbatim lines.
% If requested, this numbering is done outside the verbatim environment.
% Initially none: no numbering.
% 
% \itemtt[\CDRCheckRed numbersep=\meta{dimension}]^^A
% gap between numbers and verbatim lines.
% Initially 12pt.
% \itemtt[\CDRCheckRed firstnumber=auto$\vert$last$\vert$\meta{integer}]^^A
% number of the first line.
% |last| means that the numbering is continued from the previous verbatim environment.
% If an integer is given, its value will be used to start the numbering.
% Initially \texttt{auto}: numbering starts from 1.
% \itemtt[\CDRCheckRed stepnumber=\meta{integer}]^^A
% interval at which line numbers are printed.
% Initially 1: all lines are numbered.
% \itemtt[\CDRCheckRed numberblanklines{[=true$\vert$false]}]^^A
% to number or not the white lines (really empty or containing blank characters only).
% Initially |true|: all lines are numbered.
% \itemtt[\CDRCheckRed firstline=\meta{integer}$\vert$\meta{regular expression}]^^A
% first line to print, relative to the block.
% Initially empty: all lines from the first are printed.
% \itemtt[\CDRCheckRed lastline=\meta{integer}$\vert$\meta{regular expression}]^^A
% last line to print, relative to the block.
% Initially empty: all lines until the last one are printed.
% \itemtt[\CDRCheckRed baselinestretch=auto$\vert$\meta{dimension}]^^A
% value to give to the usual \cs{baselinestretch} \LaTeX{} parameter.
% Initially \texttt{auto}: its current value just before the verbatim command.
% \itemtt[\CDRCheckProhibited commandchars=\meta{three characters}]^^A
% characters which define the character which starts a macro and marks the
% beginning and end of a group; thus lets us introduce escape sequences in
% verbatim code. Of course, it is better to choose special characters which
% are not used in the verbatim text.
% Private to \pkg{coder}, unavailable to users.
% \itemtt[\CDRCheckRed xleftmargin=\meta{dimension}]^^A
% indentation to add at the start of each line.
% Initially |0pt|: no left margin.
% \itemtt[\CDRCheckRed xrightmargin=\meta{dimension}]^^A
% right margin to add after each line.
% Initially |0pt|: no right margin.
% \itemtt[\CDRCheckRed resetmargins{[=true$\vert$false]}]^^A
% reset the left margin, which is useful if we are inside other indented environments.
% Initially |true|.
% \itemtt[\CDRCheckRed hfuzz=\meta{dimension}]^^A
% value to give to the \TeX{} |\hfuzz| dimension for text to format.
% This can be used to avoid seeing some unimportant overfull box messages.
% Initially 2pt.
% \itemtt[\CDRCheckRed samepage{[=true$\vert$false]}]^^A
% in very special circumstances, we may want to make sure that a verbatim environment
% is not broken, even if it does not fit on the current page.
% To avoid a page break, we can set the samepage parameter to |true|.
% Initially |false|.
% \end{description}
%
% \subsection{\pkg{pygments} options}
% These are \pkg{pygments}'s |LatexFormatter| options,
% used only by \CDRLua{} to communicate with \CDRPy{}.
%
% \begin{description}
% \itemtt[\CDRCheckRed style=\meta{name}]^^A
% the \pkg{pygments} style to use.
% Initially \texttt{default}.
% \itemtt[\CDRCheckProhibited full]^^A
% Tells the formatter to output a "full" document, i.e. a complete
%        self-contained document (default: |false|).
% Forbidden.
% \itemtt[\CDRCheckProhibited title]^^A
% If |full| is true, the title that should be used to caption the
%         document (default empty).
% Forbidden.
% \itemtt[\CDRCheckProhibited encoding]^^A
% If given, must be an encoding name. This will be used to
%        convert the Unicode token strings to byte strings in the
%        output. If it is "" or None, Unicode strings will be written
%        to the output file, which most file-like objects do not
%        support (default: None).
% \itemtt[\CDRCheckProhibited outencoding]^^A
% Overrides |encoding| if given.
% \itemtt[\CDRCheckProhibited docclass]^^A
% If the |full| option is enabled, this is the document class to use
% (default: |article|).
% Forbidden.
% \itemtt[\CDRCheckProhibited preamble]^^A
% If the |full| option is enabled, this can be further preamble commands,
% e.g. ``|\usepackage|`` (default |empty|).
% Forbidden.
% \itemtt[\CDRCheckProhibited  linenos{[=true$\vert$false]}]^^A
% If set to |true|, output line numbers.
% Initially |false|: no numbering.
% Ignored in |code| mode.
% \itemtt[\CDRCheckProhibited  linenostart=\meta{integer}]^^A
% The line number for the first line.
% Initially 1: numbering starts from 1.
% Ignored in |code| mode.
% \itemtt[\CDRCheckProhibited  linenostep=\meta{integer}]^^A
% If set to a number n > 1, only every nth line number is printed.
% Ignored in |code| mode.
% Additional options given to the Verbatim environment (see the \pkg{fancyvrb}
%         docs for possible values).
% Initially empty.
% \itemtt[\CDRCheckProhibited verboptions]^^A
% Forbidden.
% \itemtt[\CDRCheckRed commandprefix=\meta{text}]^^A
% The LaTeX commands used to produce colored output are constructed
%        using this prefix and some letters.
% Initially |PY|.
% \itemtt[\CDRCheckRed texcomments{[=true$\vert$false]}]^^A
% If set to |true|, enables \LaTeX{} comment lines.  That is, \LaTeX{} markup
%        in comment tokens is not escaped so that \LaTeX{} can render it.
% Initially |false|.
% Ignored in code mode.
% \itemtt[\CDRCheckRed mathescape{[=true$\vert$false]}]^^A
% If set to |true|, enables \LaTeX{} math mode escape in comments. That
%        is, |$...$| inside a comment will trigger math mode.
% Initially |false|.
% \itemtt[\CDRCheckRed escapeinside=\meta{before}\meta{after}]^^A
% If set to a string of length 2, enables escaping to \LaTeX{}. Text
%        delimited by these 2 characters is read as LaTeX code and
%        typeset accordingly. It has no effect in string literals. It has
%        no effect in comments if |texcomments| or |mathescape| is
%        set. The character cannot be a caret |^|.
% Initially empty.
% \itemtt[\CDRCheckInternal envname=\meta{name}]^^A
% Allows you to pick an alternative environment name replacing |Verbatim|.
%        The alternate environment still has to support |Verbatim|'s option syntax.
% Initially |Verbatim|.
% \end{description}
%
% \subsection{\LaTeX{}}
%
% These are options used by \CDRSty{} to pass data to \CDRPy{}.
% All values are required, possibly empty.
% \begin{description}
% \itemtt[\CDRCheckRed tags] |clist| of tag names, used for line numbering.
% \itemtt[\CDRCheckRed inline] |true| when inline code is concerned, false otherwise.
% \itemtt[\CDRCheckRed sty_template] \LaTeX{} source text where |<placeholder:style_defs>| must be replaced by the style definitions provided by \pkg{pygments}.
% It may include the style name.
%
% \end{description}
% All the line templates below are \LaTeX{} source text
%   where |<placeholder:number>| should be replaced by a line number
%   and |<placeholder:line>| should be replaced by the hilighted line code
%   provided by \pkg{pygments}.
%   They should not include a trailing newline char.
%
% \part{\CDRLua{} implementation}
% \section{Usage}
% This \texttt{lua} library is loaded by \CDRSty{}
% with the instruction \texttt{CDR=require("\jobname-util")}.
% In the sequel, the syntax to call class methods and instance methods are
% presented with either a \texttt{CDR.} or a \texttt{CDR:} prefix.
% This is what is used in the library for convenience.
% Of course either a \texttt{self.} or a \texttt{self:} prefix would be possible.
%
% \section{Declarations}
%    \begin{MacroCode}[OK]
%<*lua>
local lfs   = _ENV.lfs
local tex   = _ENV.tex
local token = _ENV.token
local md5   = _ENV.md5
local kpse  = _ENV.kpse
local rep   = string.rep
local lpeg  = require("lpeg")
local P, Cg, Cp, V = lpeg.P, lpeg.Cg, lpeg.Cp, lpeg.V
local json  = require('lualibs-util-jsn')
local ltb = _ENV.luatexbase
%    \end{MacroCode}
% \section{General purpose material}
% \begin{variable}{CDR_PY_PATH}
% Location of the \CDRPy{} utility.
% This will cause an error if |kpsewhich| is not available.
% The |PATH| must be properly set up.
%    \begin{MacroCode}[OK]
local CDR_PY_PATH = kpse.find_file('coder-tool.py')
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{set_python_path}
% \begin{syntax}
% CDR:set_python_path(\meta{path var})
% \end{syntax}
% \CDRCheckRed Manually set the path of the |python| utility with the contents
% of the \metatt{path var}.
% If the given path does not point to a file or a link then an error is raised.
% On return, print |true| or |false| in the \TeX{} stream to indicate whether
% \pkg{pygments} is available.
% \end{function}
%    \begin{MacroCode}[OK]
local function set_python_path(self, path_var)
  local path, mode, _, __
  if path_var then
    path = assert(token.get_macro(path_var))
    mode,_,__ = lfs.attributes(path,'mode')
    print('**** CDR mode', path, mode)
  end
  if not mode then
    path = io.popen([[which python]]):read('a'):match("^%s*(.-)%s*$")
    mode,_,__ = lfs.attributes(path,'mode')
    print('**** CDR mode', path, mode)
  end
  if mode == 'file' or mode == 'link' then
    self.PYTHON_PATH = path
    print('**** CDR python path', self.PYTHON_PATH)
    path = path:match("^(.+/)")..'pygmentize'
    mode,_,__ = lfs.attributes(path,'mode')
    print('**** CDR path, mode', path, mode)
    self.PYGMENTIZE_PATH = path
    if mode == 'file' or mode == 'link' then
      tex.print('true')
    else
      tex.print('false')
    end
  else
    self.PYTHON_PATH = nil    
  end
end
%    \end{MacroCode}
%
% \begin{variable}{JSON_boolean_true, JSON_boolean_false}
% Special marker to encode booleans in |JSON| files.
% These are table which |__cls__| field is either |BooleanTrue| or |BooleanFalse|.
% \end{variable}
%    \begin{MacroCode}
local JSON_boolean_true = {
  __cls__ = 'BooleanTrue',
}
local JSON_boolean_false = {
  __cls__ = 'BooleanFalse',
}
%    \end{MacroCode}
%
% \begin{function}{is_truthy}
% \begin{syntax}
% if is_truthy(\meta{what}) then
%   \meta{true code}
% else
%   \meta{false code}
% end
% \end{syntax}
% Execute \metatt{true code} if \metatt{what} is |JSON_boolean_true| or the string ``true'',
% \metatt{false code} otherwise.
% Upvalue for the clients.
% \end{function}
%    \begin{MacroCode}[OK]
local function is_truthy(s)
  return s == JSON_boolean_true or s == 'true'
end
%    \end{MacroCode}
%
% \begin{function}{escape}
% \begin{syntax}
% <variable> = CDR.escape(<string>)
% \end{syntax}
% \CDRCheckRed Escape the given string to be used by the shell.
% \end{function}
%    \begin{MacroCode}[OK]
local function escape(s)
  s = s:gsub(' ','\\ ')
  s = s:gsub('\\','\\\\')
  s = s:gsub('\r','\\r')
  s = s:gsub('\n','\\n')
  s = s:gsub('"','\\"')
  s = s:gsub("'","\\'")
  return s
end
%    \end{MacroCode}
%
% \begin{function}{make_directory}
% \begin{syntax}
% \meta{variable} = CDR.make_directory(\meta{string path})
% \end{syntax}
% Make a directory at the given path.
% \end{function}
%    \begin{MacroCode}[OK]
local function make_directory(path)
  local mode,_,__ = lfs.attributes(path,"mode")
  if mode == "directory" then
    return true
  elseif mode ~= nil then
    return nil,path.." exist and is not a directory",1
  end
  if os["type"] == "windows" then
    path = path:gsub("/", "\\")
    _,_,__ = os.execute(
      "if not exist "  .. path .. "\\nul " .. "mkdir " .. path
    )
  else
    _,_,__ = os.execute("mkdir -p " .. path)
  end
  mode = lfs.attributes(path,"mode")
  if mode == "directory" then
    return true
  end
  return nil,path.." exist and is not a directory",1
end
%    \end{MacroCode}
% \begin{variable}{dir_p}
% The directory where the auxiliary \pkg{pygments} related files are saved,
% in general \metatt{jobname}|.pygd/|.
% \end{variable}
% \begin{variable}{json_p}
% The path of the JSON file used to communicate with \CDRPy{},
% in general\\\metatt{jobname}|.pygd/|\metatt{jobname}|.pyg.json|.
% \end{variable}
%    \begin{MacroCode}[OK]
local dir_p, json_p
local jobname = tex.jobname
dir_p = './'..jobname..'.pygd/'
if make_directory(dir_p) == nil then
  dir_p = './'
  json_p = dir_p..jobname..'.pyg.json'
else
  json_p = dir_p..'input.pyg.json'
end
%    \end{MacroCode}
% \begin{function}{safe_equals}
% \begin{syntax}
% <variable> = safe_equals(<string>)
% \end{syntax}
% Class method.
% Returns an \meta{=...=} string as \metatt{ans} exactly composed of sufficently many \texttt{=} signs
% such that \meta{string} contains neither sequence \texttt{[\meta{ans}[}
% nor \texttt{]\meta{ans}]}.
% \end{function}
%    \begin{MacroCode}[OK]
local eq_pattern = P({ Cp() * P('=')^1 * Cp() + P(1) * V(1) })
local function safe_equals(s)
  local i, j = 0, 0
  local max = 0
  while true do
    i, j = eq_pattern:match(s, j)
    if i == nil then
      return rep('=', max + 1)
    end
    i = j - i
    if i > max then
      max = i
    end
  end
end
%    \end{MacroCode}
%
% \begin{function}{load_exec}
% \begin{syntax}
% CDR:load_exec(\meta{lua code chunk})
% \end{syntax}
% Class method. Loads the given \metatt{lua code chunk} and execute it.
% On error, messages are printed.
% \end{function}
%    \begin{MacroCode}[OK]
local function load_exec(self, chunk)
  local env = setmetatable({ self = self, tex = tex }, _ENV)
  local func, err = load(chunk, 'coder-tool', 't', env)
  if func then
    local ok
    ok, err = pcall(func)
    if not ok then
      print("coder-util.lua Execution error:", err)
      print('chunk:', chunk)
    end
  else
    print("coder-util.lua Compilation error:", err)
    print('chunk:', chunk)
  end
end
%    \end{MacroCode}
%
% \begin{function}{load_exec_output}
% \begin{syntax}
% CDR:load_exec_output(\meta{lua code chunk})
% \end{syntax}
% Instance method to parse the \metatt{lua code chunk} sring for commands and execute them.
% The patterns being searched are enclosed within opening |<<<<<| and closing |>>>>>|,
% each containing 5 characters,
% \begin{description}
% \item[\texttt{?TEX}:\metatt{TeX instructions}] the \metatt{TeX instructions} are executed
% asynchronously once the control comes back to \TeX{}.
% \item[\texttt{!LUA}:\metatt{!Lua instructions}] the \metatt{!Lua instructions} are executed
% synchronously. When not properly designed, these instruction may cause a
% forever loop on execution, for example, they must not use \texttt{CDR:if_code_ngn}.
% \item[\texttt{?LUA}:\metatt{?Lua instructions}] these \metatt{?Lua instructions} are executed
% asynchronously once the control comes back to \TeX{} through a call to \cs{directlua},
% which means that they will wait until any previous asynchronous \metatt{?TeX instructions}
% or \metatt{?Lua instructions} completes.
% \end{description}
% \end{function}
%    \begin{MacroCode}[OK]
local parse_pattern
do
  local tag = P('!') + '*' + '?'
  local stp = '>>>>>'
  local cmd = (P(1) - stp)^0
  parse_pattern = P({
    P('<<<<<') * Cg(tag) * 'LUA:' * Cg(cmd) * stp * Cp() + 1 * V(1)
  })
end
local function load_exec_output(self, s)
  local i, tag, cmd
  i = 1
  while true do
    tag, cmd, i = parse_pattern:match(s, i)
    if tag == '!' then
      self:load_exec(cmd)
    elseif tag == '*' then
      local eqs = safe_equals(cmd)
      cmd = '['..eqs..'['..cmd..']'..eqs..']'
      tex.print([[%
\directlua{CDR:load_exec(]]..cmd..[[)}%
]])
    elseif tag == '?' then
      print('\nDEBUG/coder: '..cmd)
    else
      return
    end
  end
end
%    \end{MacroCode}
%
% \section{Hiligting}
%
% \subsection{Common}
%
% \begin{function}{hilight_set}
% \begin{syntax}
% CDR:hilight_set(...)
% \end{syntax}
% Hilight the currently entered block.
% Build a configuration table with all data necessary for the processing,
% save it as a |JSON| file and launch \CDRPy{} with the proper arguments.
% \end{function}
%    \begin{MacroCode}
local function hilight_set(self, key, value)
  local args = self['.arguments']
  local t = args
  if t[key] == nil then
    t = args.pygopts
    if t[key] == nil then
      t = args.texopts
      if t[key] == nil then
        t = args.fv_opts
        assert(t[key] ~= nil)
      end
    end
  end
  if t[key] == JSON_boolean_true or t[key] == JSON_boolean_false then
    t[key] = value == 'true' and JSON_boolean_true or JSON_boolean_false
  else
    t[key] = value
  end
end

local function hilight_set_var(self, key, var)
  self:hilight_set(key, assert(token.get_macro(var or 'l_CDR_a_tl')))
end
%    \end{MacroCode}
%
% \begin{function}{hilight_source}
% \begin{syntax}
% CDR:hilight_source(\meta{src}, \meta{sty})
% \end{syntax}
% Hilight the currently entered block if \metatt{src} is |true|,
% build the style definitions if \metatt{sty} is |true|.
% Build a configuration table with all data necessary for the processing,
% save it as a |JSON| file and launch \CDRPy{} with the proper arguments.
% Set the |\l_CDR_pyg_sty_tl| and |\l_CDR_pyg_tex_tl| macros on return,
% depending on \metatt{src} and \metatt{sty}.
% \end{function}
%    \begin{MacroCode}
local function hilight_source(self, sty, src)
  if not self.PYTHON_PATH then
    return
  end
  local args = self['.arguments']
  local texopts = args.texopts
  texopts.synctex_tag  = self.synctex_tag
  texopts.synctex_line = self.synctex_line
  local pygopts = args.pygopts
  local inline = is_truthy(texopts.is_inline)
  local use_cache = is_truthy(args.cache)
  local use_py = false
  local cmd = self.PYTHON_PATH..' '..self.CDR_PY_PATH
  local debug = is_truthy(args.debug)
  if debug then
    cmd = cmd..' --debug'
  end
  local pyg_sty_p
  if sty then
    pyg_sty_p = self.dir_p..pygopts.style..'.pyg.sty'
    token.set_macro('l_CDR_pyg_sty_tl', pyg_sty_p)
    texopts.pyg_sty_p = pyg_sty_p
    local mode,_,__ = lfs.attributes(pyg_sty_p, 'mode')
    if not mode or not use_cache then
      use_py = true
      if debug then
        print('PYTHON STYLE:')
      end
      cmd = cmd..(' --create_style')
    end
    self:cache_record(pyg_sty_p)
  end
  local pyg_tex_p
  if src then
    local source
    if inline then
      source = args.source
    else
      local ll = self['.lines']
      source = table.concat(ll, '\n')
    end
    local hash = md5.sumhexa( ('%s:%s:%s'
      ):format(
        source,
        inline and 'code' or 'block',
        pygopts.style
      )
    )
    local base = self.dir_p..hash
    pyg_tex_p = base..'.pyg.tex'
    token.set_macro('l_CDR_pyg_tex_tl', pyg_tex_p)
    local mode,_,__ = lfs.attributes(pyg_tex_p,'mode')
    if not mode or not use_cache then
      use_py = true
      if debug then
        print('PYTHON SOURCE:', inline)
      end
      if not inline then
        local tex_p = base..'.tex'
        local f = assert(io.open(tex_p, 'w'))
        local ok, err = f:write(source)
        f:close()
        if not ok then
          print('File error('..tex_p..'): '..err)
        end
        if debug then
          print('OUTPUT: '..tex_p)
        end
      end
      cmd = cmd..(' --base=%q'):format(base)
    end
  end
  if use_py then
    local json_p = self.json_p
    local f = assert(io.open(json_p, 'w'))
    local ok, err = f:write(json.tostring(args, true))
    f:close()
    if not ok then
      print('File error('..json_p..'): '..err)
    end
    cmd = cmd..('  %q'):format(json_p)
    if debug then
      print('CDR>'..cmd)
    end
    local o = io.popen(cmd):read('a')
    self:load_exec_output(o)
    if debug then
      print('PYTHON', o)
    end
  elseif debug then
    print('SAVED>'..cmd)
  end  
  self:cache_record(
    sty and pyg_sty_p or nil,
    src and pyg_tex_p or nil
  )
end
%    \end{MacroCode}
%
% \subsection{Code}
%
% \begin{function}{hilight_code_setup}
% \begin{syntax}
% CDR:hilight_code_setup()
% \end{syntax}
% Hilight the code in \pkg{str} variable named \metatt{code var name}.
% Build a configuration table with all data necessary for the processing,
% save it as a |JSON| file and launch \CDRPy{} with the proper arguments.
% \end{function}
%    \begin{MacroCode}
local function hilight_code_setup(self)
  self['.arguments'] = {
    __cls__ = 'Arguments',
    source  = '',
    cache   = JSON_boolean_true,
    debug   = JSON_boolean_false,
    pygopts = {
      __cls__ = 'PygOpts',
      lang    = 'tex',
      style   = 'default',
      mathescape   = JSON_boolean_false,
      escapeinside = '',
    },
    texopts = {
      __cls__ = 'TeXOpts',
      tags    = '',
      is_inline = JSON_boolean_true,
      pyg_sty_p = '',
      synctex_tag  = 0,
      synctex_line = 0,
    },
    fv_opts = {
      __cls__ = 'FVOpts',
    }
  }
  self.hilight_json_written = false
end
%    \end{MacroCode}
%
% \begin{function}{synctex_tag_set}
% \begin{syntax}
% CDR:synctex_tag_set(\meta{new tag})
% \end{syntax}
% Set the Sync\TeX\ tag, does nothing if the argument is not positive.
% \end{function}
%    \begin{MacroCode}
local function synctex_tag_set(self, tag)
  if assert(tag, 'Unexpected nil tag') > 0 then
    self.synctex_tag  = tag
  end
end
%    \end{MacroCode}
%
% \begin{function}{synctex_line_set}
% \begin{syntax}
% CDR:synctex_line_set(\meta{new line})
% \end{syntax}
% Set the Sync\TeX\ line, does nothing if the argument is not positive.
% \end{function}
%    \begin{MacroCode}
local function synctex_line_set(self, line)
  if line >= 0 then
    self.synctex_line  = line
  end
end
%    \end{MacroCode}
%
% \begin{function}{synctex_state_save}
% \begin{syntax}
% CDR:synctex_state_save()
% \end{syntax}
% Save the Sync\TeX\ state.
% \end{function}
%    \begin{MacroCode}
local function synctex_state_save(self, offset)
  self:synctex_tag_set(tex.get_synctex_tag())
  self:synctex_line_set(tex.inputlineno+(offset or 0))
  self.synctex_mode = tex.get_synctex_mode()
  tex.set_synctex_mode(1)
end
%    \end{MacroCode}
%
% \begin{function}{synctex_state_restore}
% \begin{syntax}
% CDR:synctex_state_restore()
% \end{syntax}
% Save the Sync\TeX\ state.
% \end{function}
%    \begin{MacroCode}
local function synctex_state_restore(self)
  tex.force_synctex_tag(self.synctex_tag)
  tex.force_synctex_line(self.synctex_line)
  tex.set_synctex_mode(self.synctex_mode)
  self.synctex_tag = 0
  self.synctex_line = 0
end
%    \end{MacroCode}
%
% \begin{function}{synctex_target_set}
% \begin{syntax}
% CDR:synctex_state_set(\meta{line number})
% \end{syntax}
% Save the Sync\TeX\ state.
% \end{function}
%    \begin{MacroCode}
local function synctex_target_set(self, line_number)
  tex.force_synctex_tag( self.synctex_tag )
  tex.force_synctex_line(self.synctex_line + line_number )
end
%    \end{MacroCode}
%
% \begin{function}{hilight_code_teardown}
% \begin{syntax}
% CDR:hilight_code_teardown()
% \end{syntax}
% Restore the Sync\TeX\ state.
% \end{function}
%    \begin{MacroCode}
local function hilight_code_teardown(self)
  self:synctex_state_restore()
end

%    \end{MacroCode}
%
% \subsection{Block}
%
% \begin{function}{hilight_block_setup}
% \begin{syntax}
% CDR:hilight_block_setup(\meta{tags clist var})
% \end{syntax}
% Records the contents of the \metatt{tags clist var} \LaTeX{} variable
% to prepare block hilighting.
% This is called at the end of the environment when we can know that the current line
% is exactly the first after the last line of code.
% \end{function}
%    \begin{MacroCode}
local function hilight_block_setup(self, tags_clist_var)
  local tags_clist = assert(token.get_macro(assert(tags_clist_var)))
  self['.tags clist'] = tags_clist
  self['.lines'] = {}
  self['.arguments'] = {
    __cls__ = 'Arguments',
    cache   = JSON_boolean_false,
    debug   = JSON_boolean_false,
    source  = nil,
    pygopts = {
      __cls__ = 'PygOpts',
      lang = 'tex',
      style = 'default',
      texcomments  = JSON_boolean_false,
      mathescape   = JSON_boolean_false,
      escapeinside = '',
    },
    texopts = {
      __cls__ = 'TeXOpts',
      tags    = tags_clist,
      is_inline = JSON_boolean_false,
      pyg_sty_p = '',
      synctex_tag  = 0,
      synctex_line = 0,
    },
    fv_opts = {
      __cls__ = 'FVOpts',
      firstnumber = 1,
      stepnumber  = 1,
    }
  }
  self.hilight_json_written = false
end
%    \end{MacroCode}
%
% \begin{function}{record_line}
% \begin{syntax}
% CDR:record_line(\meta{line variable name})
% \end{syntax}
% Store the content of the given named variable.
% It will be used for colorization and exportation.
% For each recorded line the |synctex_line| of the receiver is decremented.
% \end{function}
%    \begin{MacroCode}[OK]
local function record_line(self, line_variable_name)
  local line = assert(token.get_macro(assert(line_variable_name)))
  local ll = assert(self['.lines'])
  ll[#ll+1] = line
end
%    \end{MacroCode}
%
% \begin{function}{escape_inside}
% \begin{syntax}
% escape_inside(\meta{text}, \meta{delimiters})
% \end{syntax}
% Return a copy of \meta{text} where what was escaped is remove, including the delimiters.
% \meta{text} needs not be a line.
% Private function (upvalue)
% \end{function}
%    \begin{MacroCode}[OK]
local function escape_inside (text, delimiters)
  local i = 1
  local t = {}
  local r
  if delimiters:len() == 2 then
    r = '(.-)['..delimiters:sub(1,1)..'].-['
      ..delimiters:sub(2,2)..']()'
    for a, next_i in text:gmatch(r) do
      t[#t+1] = a
      i = next_i
    end
  elseif delimiters:len() == 3 then
    r = '(.-)['..delimiters:sub(1,1)..'].-['
      ..delimiters:sub(2,2)..'](.-)['
      ..delimiters:sub(3,3)..']()'
    for a, b, next_i in text:gmatch(r) do
      t[#t+1] = a
      t[#t+1] = b
      i = next_i
    end
  end
  if i > 1 then
    t[#t+1] = text:sub(i,-1)
    return table.concat(t,'')    
  end
  return text
end
%    \end{MacroCode}
%
% \begin{function}{hilight_block_teardown}
% \begin{syntax}
% CDR:hilight_block_teardown()
% \end{syntax}
% Records the contents of the \metatt{tags clist var} \LaTeX{} variable
% to prepare block hilighting.
% \end{function}
%    \begin{MacroCode}[OK]
local function hilight_block_teardown(self)
  local ll = assert(self['.lines'])
  if #ll > 0 then
    local args = self['.arguments']
    local t, code
    if is_truthy(args.pygopts.texcomments) then
      t = {}
      for _,l in ipairs(ll) do
        t[#t+1] = l:gsub('(.-)%?','%1')
      end
      code = table.concat(t,'\n')
    else
      code = escape_inside(table.concat(ll,'\n'),args.pygopts.escapeinside)
    end
    local records = self['.records'] or {}
    self['.records'] = records
    t = {
      already = {},
      code = code
    }
    for tag in self['.tags clist']:gmatch('([^,]+)') do
      local tt = records[tag] or {}
      records[tag] = tt
      tt[#tt+1] = t
    end
  end
end
%    \end{MacroCode}
%
% \section{Exportation}
%
% For each file to be exported, \CDRSty{} calls |export_file|
% to initialize the exportation. Then it calls |export_file_info| to
% share the |tags|, |raw|, |preamble|, |postamble| data.
% Finally, |export_complete| is called to complete the exportation.
% \begin{function}{export_file}
% \begin{syntax}
% CDR:export_file(\meta{file name var})
% \end{syntax}
% This is called at export time.
% \metatt{file name var} is the name of an \pkg{str} variable
% containing the file name.
% \end{function}
%    \begin{MacroCode}[OK]
local function export_file(self, file_name_var)
  self['.name'] = assert(token.get_macro(assert(file_name_var)))
  self['.export'] = {
    preamble = {},
    postamble = {},
  }
end
%    \end{MacroCode}
% \begin{function}{export_file_info, append_file_info}
% \begin{syntax}
% CDR:export_file_info(\meta{key}, \meta{value name var})
% CDR:append_file_info(\meta{key}, \meta{value name var})
% \end{syntax}
% This is called at export time.
% \metatt{value name var} is the name of an \pkg{str} variable
% containing the value.
% \end{function}
%    \begin{MacroCode}[OK]
local function export_file_info(self, key, value)
  local export = self['.export']
  value = assert(token.get_macro(assert(value)))
  if export[key] == JSON_boolean_true or export[key] == JSON_boolean_false then
    export[key] = (value == 'true') and JSON_boolean_true or JSON_boolean_false
  else
    export[key] = value
  end
end
local function append_file_info(self, key, value)
  local export = self['.export']
  local t = export[key]
  value = assert(token.get_macro(assert(value)))
  t[#t+1] = value
end
%    \end{MacroCode}
% \begin{function}{export_complete}
% \begin{syntax}
% CDR:export_complete()
% \end{syntax}
% This is called at export time.
% \end{function}
%    \begin{MacroCode}[OK]
  function self.export_complete(this)
    local raw  = export.raw  == 'true'
    local once = export.once == 'true'
    local tags = export.tags
    local tt = {}
    local s, _
print('**** CDR', tags, raw, once)
  if not raw then
    s = export.preamble
    for _,t in ipairs(s) do
      tt[#tt+1] = t
    end
    local records = self['.records'] or {}
    for tag in string.gmatch(export.tags, '([^,]+)') do
      local Rs = records[tag]
      if Rs then
        for _,R in ipairs(Rs) do
          if not R.already[name] or not once then
            tt[#tt+1] = R.code
          end
          if once then
            R.already[name] = true
          end
        end
      end
    end
  end
  if not raw then
    s = export.postamble
    for _,t in ipairs(s) do
      tt[#tt+1] = t
    end
  end
print('**** CDR', name, #tt)
  if #tt>0 then
    if #tt[#tt] > 0 then
      tt[#tt+1] = ''
    end
    local fh = assert(io.open(name,'w'))
    fh:write(table.concat(tt, '\n'))
    fh:close()
  end
  self['.name'] = nil
  self['.export'] = nil
end
%    \end{MacroCode}
%
% \section{Caching}
% We save some computation time by pygmentizing files only when necessary.
% The \CDRPy{} is expected to create a |*.pyg.sty| file for a style
% and a |*.pyg.tex| file for hilighted code.
% These files are cached during one whole \LaTeX{} run and possibly between
% different \LaTeX{} runs. Lua keeps track
% of both the style files created and hilighted code files created.
% \begin{function}{cache_clean_all, cache_record, cache_clean_unused}
% \begin{syntax}
% CDR:cache_clean_all()
% CDR:cache_record(\meta{style name.pyg.sty}, \meta{digest.pyg.tex})
% CDR:cache_clean_unused()
% \end{syntax}
% Instance methods.
% |cache_clean_all| removes any file in the cache directory named \texttt{\meta{jobname}.pygd}.
% This is automatically executed at the beginning of the document processing
% when there is no aux file.
% This can also be executed on demand with |\directlua{CDR:cache_clean_all()}|.
% The |cache_record| method stores both \metatt{style name.pyg.sty} and \metatt{digest.pyg.tex}.
% These are file names relative to the \texttt{\meta{jobname}.pygd} directory.
% |cache_clean_unused| removes any file in the cache directory \texttt{\meta{jobname}.pygd}
% except the ones that were previously recorded. This is executed at the end of the
% document processing.
% \end{function}
%    \begin{MacroCode}[OK]
local function cache_clean_all(self)
  local to_remove = {}
  for f in lfs.dir(self.dir_p) do
    to_remove[f] = true
  end
  for k,_ in pairs(to_remove) do
    os.remove(self.dir_p .. k)
  end
end
local function cache_record(self, pyg_sty_p, pyg_tex_p)
  if pyg_sty_p then
    self['.style_set']  [pyg_sty_p] = true
  end
  if pyg_tex_p then
    self['.colored_set'][pyg_tex_p] = true
  end
end
local function cache_clean_unused(self)
  local to_remove = {}
  for f in lfs.dir(self.dir_p) do
    f = self.dir_p .. f
    if not self['.style_set'][f] and not self['.colored_set'][f] then
      to_remove[f] = true
    end 
  end
  for f,_ in pairs(to_remove) do
    os.remove(f)
  end
end
%    \end{MacroCode}
%
% \begin{variable}{_DESCRIPTION}
% Short text description of the module.
%    \begin{MacroCode}[OK]
local _DESCRIPTION = [[Global coder utilities on the lua side]]
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{rescan_begin, rescan_push_line, rescan_end}
% \begin{syntax}
% CDR:rescan_begin()
% CDR:rescan_push_line(\metatt{tl line variable})
% CDR:rescan_end()
% \end{syntax}
% This is a strong replacement to the various rescan functions (including |\scantokens|) assuming that
% what is rescan is a string.
% Initialize the rescan with |CDR:rescan_begin()|,
% then put each line in turn with |CDR:rescan_push_line(...)| and finally
% teminate the process with |CDR:rescan_end()|
% Implementation detail: use a closure.
% \end{function}
%    \begin{MacroCode}[OK]
local function rescan_begin(self)
  local t = {}
  local makeatletter = false
  local ExplSyntaxOn = false
  function self.rescan_makeatletter(this, yorn)
    makeatletter = yorn
    if makeatletter then
      tex.print([[\makeatletter]])
    end
  end
  function self.rescan_ExplSyntaxOn(this, yorn)
    ExplSyntaxOn = yorn
    if ExplSyntaxOn then
      tex.print([[\ExplSyntaxOn]])
    end
  end
  function self.rescan_push_line(this, tl_var)
    table.insert(t, assert(token.get_macro(assert(tl_var))))
  end
  function self.rescan_end(me)
    tex.print(t);
    if ExplSyntaxOn then
      tex.print([[\ExplSyntaxOff]])
    end
    if makeatletter then
      tex.print([[\makeatother]])
    end
    self.rescan_makeatletter = nil
    self.rescan_ExplSyntaxOn = nil
    self.rescan_push_line = nil;
    self.rescan_end = nil;
  end
end
%    \end{MacroCode}
%
% \section{Input}
%
% \begin{function}{input_begin,
%   input_set_boolean,
%   input_end,
% }
% \begin{syntax}
% CDR:input_begin(\metatt{tl source variable}, \metatt{tl driver variable})
% CDR:input_set_boolean(\metatt{key}, \metatt{tl variable})
% CDR:input_end()
% \end{syntax}
% These are the helpers to input a source file.
% The driver, source and various options are stored,
% then the process is launched on the \TeX\ side by
% |CDR:input()| which forwards to |self:input_process|.
% Implementation detail: all functions but the first are
% implemented dynamically.
% The |input_begin| and |input_end| methods must be called
% in separate |\directlua| calls.
% \end{function}
%    \begin{MacroCode}[OK]
local function input_begin(self, source_var, driver_var)
  local args = {
    source = assert(token.get_macro(source_var or 'l_CDR_input_tl')),
    driver = assert(token.get_macro(driver_var or 'l_CDR_a_tl')),
    show_code = true,
    show_doc  = true,
  }
  function self.input_set_boolean(this, key, var)
    args[key] = assert(token.get_macro(var or 'l_CDR_a_tl')) == 'true'
  end
  function self.input(this)
    this:input_process(args)
  end
  function self.input_end(this)
    this.synctex_state_restore = nil
    this:synctex_state_restore()
  end
end
%    \end{MacroCode}
%
% \begin{function}{get_driver}
% \begin{syntax}
% CDR:get_driver(\metatt{name})
% \end{syntax}
% Get the driver with the given name.
% \end{function}
%    \begin{MacroCode}[OK]
local function get_driver(self, name)
  local path
  if name:match('%.lua$') then
    path = kpse.find_file(name)
  else
    path = kpse.find_file('coder-driver-'..name..'.lua')
  end
  local f, err = loadfile(path)
  if not f then
    tex.print([[\PackageError{coder}]]..'{Bad driver '
      ..name..'}{'..err..'}'
    )
    return
  end
  local status, driver = pcall(f)
  if status then
    return driver
  end
  tex.print([[\PackageError{coder}]]..'{Syntax error in '
    ..path..'}{'..driver..'}'
  )
end
%    \end{MacroCode}
%
% \begin{function}{synctex_tag_will_catch, synctex_tag_did_catch}
% \begin{syntax}
% CDR:synctex_tag_will_catch()
% \end{syntax}
% This must be called at the Lua\TeX\ level, followed by an \cs{input}.
% Then, the |synctex_tag_catched| of the receiver
% will contain the Sync\TeX\ tag for that file.
% The file content is simulated to be a single line with only
% a percent character.
% \end{function}
%    \begin{MacroCode}[OK]
local function synctex_tag_will_catch(self)
  ltb.add_to_callback(
    'open_read_file',
    function (file_name)
      return {
        reader = function(this)
          self.synctex_tag_catched = tex.get_synctex_tag()
          this.reader = function (_)
            ltb.remove_from_callback(
              'open_read_file',
              'coder.CDRInput'
            )
            return nil
          end
          return '%'
        end,
      }
    end,
    'coder.CDRInput'
  )
end
%    \end{MacroCode}
%
% \begin{function}{input_process}
% \begin{syntax}
% CDR:input_process(\metatt{args})
% \end{syntax}
% These is the main processor.
% \end{function}
%    \begin{MacroCode}[OK]
local function input_process(self, args)
  self.input_set_boolean = nil
  self:synctex_state_save()
  self.synctex_state_save = function () end
  self.synctex_state_restore = function () end
  local source = kpse.find_file(args.source)
  if not source then
    tex.print([[\PackageError{coder}{No source ]]
    ..args.source..
    [[}{See \CDRInput.}]])
    return
  end
%    \end{MacroCode}
% We must read the file all at once in memory because we must
% the last line.
%    \begin{MacroCode}[OK]  
  local lines = {}
  f = assert(io.open(source))
  for l in f:lines() do
    lines[#lines+1] = l
  end
  f:close()
  local last_line = table.remove(lines)
  local d = self:get_driver(args.driver)
  if d.setup then
    d:setup(args)
  end
  local n = 0
  local function noop() end
  local ans = {}
  local function one_more_line(l)
    ans[#ans+1] = l
  end
  local line_code = args.show_code and one_more_line or noop
  local pending_code, conclude, next_code
  local function prepare_code(l)
    line_code([[\begin{CDRBlock}]]
       ..'[firstnumber='..n..',obey lines]')
    line_code(l)
    pending_code = function ()
      line_code([[\end{CDRBlock}]])
    end
    conclude = function ()
      if #last_line>0 then
        line_code(last_line)
      end
      line_code([[\end{CDRBlock}]])
      line_code('')
      conclude = nil
    end
    next_code = line_code
  end
  self:synctex_tag_set(self.synctex_tag_catched)
  self:synctex_line_set(0)
  local s1 = [[\directlua]]
  ..'{CDR:synctex_target_set('
  local s2 = ')}'
  local line_doc  = args.show_doc and function (l)
    local space, unspace = l:match('^(%s*)(.*)$')
    if #unspace>0 then
      one_more_line(space..s1..n..s2..unspace)
    else
      one_more_line(l)
    end
  end or noop
  pending_code = noop
  next_code = prepare_code
  local body, in_doc, in_code
  in_doc = function (l)
    if d:close(l) then
      body = in_code
      next_code = prepare_code
      conclude = function ()
        if #last_line then
          line_code([[\begin{CDRBlock}]]
            ..'[firstnumber='..(n+1)..',obey lines]')
          line_code(last_line)
          line_code([[\end{CDRBlock}]])
          line_code('')
        end
      end
    else
      line_doc(l)
    end
  end
  in_code = d.open and function (l)
    if d:open(l) then
      pending_code()
      pending_code = noop
      body = in_doc
    else
      next_code(l)
    end
  end or function (l)
    next_code(l)
  end
  body = in_code
  for _,l in ipairs(lines) do
    n = n+1
    body(l)
  end
  if conclude then
    conclude()
  end
  for _,l in ipairs(ans) do
    if self.debug then print('****', _, '====>', l) end
    tex.print(l)
  end  
  if d.teardown then
    d:teardown()
  end
end
%    \end{MacroCode}
%
% \section{Return the module}
%    \begin{MacroCode}
return setmetatable({}, { __index = {
%    \end{MacroCode}
% Known fields are
% \begin{description}
%    \begin{MacroCode}
  _DESCRIPTION       = _DESCRIPTION,
%    \end{MacroCode}
% \item[\texttt{_VERSION}] to store \meta{version string},
%    \begin{MacroCode}
  _VERSION           = token.get_macro('fileversion'),
%    \end{MacroCode}
% \item[\texttt{date}] to store \meta{date string},
%    \begin{MacroCode}
  date               = token.get_macro('filedate'),
%    \end{MacroCode}
% \item[Various paths],
%    \begin{MacroCode}
  CDR_PY_PATH        = CDR_PY_PATH,
  set_python_path    = set_python_path,
%    \end{MacroCode}
% \itemtt[is_truthy]
%    \begin{MacroCode}
  is_truthy          = is_truthy,
%    \end{MacroCode}
% \itemtt[escape]
%    \begin{MacroCode}
  escape             = escape,
%    \end{MacroCode}
% \itemtt[make_directory]
%    \begin{MacroCode}
  make_directory     = make_directory,
%    \end{MacroCode}
% \itemtt[load_exec]
%    \begin{MacroCode}
  load_exec          = load_exec,
%    \end{MacroCode}
%    \begin{MacroCode}
  load_exec_output   = load_exec_output,
%    \end{MacroCode}
% \itemtt[record_line]
%    \begin{MacroCode}
  record_line        = record_line,
%    \end{MacroCode}
% \itemtt[hilight common]
%    \begin{MacroCode}
  hilight_set        = hilight_set,
  hilight_set_var    = hilight_set_var,
  hilight_source     = hilight_source,
%    \end{MacroCode}
% \itemtt[hilight code]
%    \begin{MacroCode}
  hilight_code_setup    = hilight_code_setup,
  hilight_code_teardown = hilight_code_teardown,
%    \end{MacroCode}
% \itemtt[hilight block]
%    \begin{MacroCode}
  hilight_block_setup    = hilight_block_setup,
  hilight_block_teardown = hilight_block_teardown,
%    \end{MacroCode}
% \itemtt[synctex]
%    \begin{MacroCode}
  synctex_state_save     = synctex_state_save,
  synctex_state_restore  = synctex_state_restore,
  synctex_target_set     = synctex_target_set,
  synctex_tag_set        = synctex_tag_set,
  synctex_line_set       = synctex_line_set,
  synctex_tag_will_catch = synctex_tag_will_catch,
%    \end{MacroCode}
% \itemtt[rescan]
%    \begin{MacroCode}
  rescan_begin  = rescan_begin,
%    \end{MacroCode}
% \itemtt[input]
%    \begin{MacroCode}
  input_begin   = input_begin,
  input_process = input_process,
  get_driver    = get_driver,
%    \end{MacroCode}
% \itemtt[cache]
%    \begin{MacroCode}
  cache_clean_all    = cache_clean_all,
  cache_record       = cache_record,
  cache_clean_unused = cache_clean_unused,
%    \end{MacroCode}
% \itemtt[Internals]
%    \begin{MacroCode}
  ['.style_set']   = {},
  ['.colored_set'] = {},
%    \end{MacroCode}
% \itemtt[already] false at the beginning,
% true after the first call of \CDRPy{}
%    \begin{MacroCode}
  already            = false,
%    \end{MacroCode}
% \itemtt[Other]
%    \begin{MacroCode}
  dir_p              = dir_p,
  json_p             = json_p,
%    \end{MacroCode}
% \itemtt[Exportation]
%    \begin{MacroCode}
  export_file        = export_file,
  export_file_info   = export_file_info,
  append_file_info   = append_file_info,
  export_complete    = export_complete,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}
} })
%    \end{MacroCode}
%    \begin{MacroCode}
%</lua>
%    \end{MacroCode}
%
% \part{\CDRPy{} implementation}
%
% The standard header is managed specially because of the way \pkg{docstrip} automatically 
% adds some header when extracting stuff from an archive.
% The next two lines are added by \pkg{docstrip} at the top of the preamble.
% 
%    \begin{MacroCode}[OK]
%<*py>
#! /usr/bin/env python3
# -*- coding: utf-8 -*-
%</py>
%    \end{MacroCode}
%
% \section{Usage}
% Run: \texttt{\CDRPy{} -h}.
%
% \section{Header and global declarations}
% 
%    \begin{MacroCode}[OK]
%<*py>
__version__ = '0.10'
__YEAR__  = '2022'
__docformat__ = 'restructuredtext'

import sys
import os
import argparse
import re
from pathlib import Path
import json
from pygments import highlight as hilight
from pygments.formatters.latex import LatexEmbeddedLexer, LatexFormatter
from pygments.lexers import get_lexer_by_name
from pygments.util import ClassNotFound
%    \end{MacroCode}
%
% \section{\texttt{Options} classes}
% |Object| is used to turn a dictionary into a full fledged object.
% The real class is given by the |__cls__| key.
%  
%    \begin{MacroCode}[OK]
class BaseOpts(object):
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
  def __init__(self, d={}):
    for k, v in d.items():
      setattr(self, k, v)
%    \end{MacroCode}
%
% \subsection{\texttt{TeXOpts} class}
%
%    \begin{MacroCode}
class TeXOpts(BaseOpts):
  tags      = ''
  is_inline  = True
  pyg_sty_p = None
  synctex_tag  = 0
  synctex_line = 0
%    \end{MacroCode}
% The templates are provided by \CDRSty{}.
% The style template wraps the style definitions provided by \pkg{pygments}.
% It may include the style name
%    \begin{MacroCode}
  sty_template=r'''% !TeX root=...
\makeatletter
\CDR@StyleDefine{<placeholder:style_name>} {%
  <placeholder:style_defs>}%
\makeatother'''
  def __init__(self, *args, **kvargs):
    super().__init__(*args, **kvargs)
    self.pyg_sty_p = Path(self.pyg_sty_p or '')
%    \end{MacroCode}
%
% \subsection{\texttt{PygOpts}class}
% \pkg{pygments} |LaTeXFormatter| options.
% Some of them may be deliberately unused.
% In particular, line numbering is governed by \pkg{fancyvrb} options.
% The description of these options is in a forthcoming section.
%    \begin{MacroCode}
class PygOpts(BaseOpts):
  style = 'default'
  nobackground = False
  linenos = False
  linenostart = 1
  linenostep = 1
  commandprefix = 'Py'
  texcomments = False
  mathescape =  False
  escapeinside = ""
  envname = 'Verbatim'
  lang = 'tex'
  def __init__(self, *args, **kvargs):
    super().__init__(*args, **kvargs)
    self.linenostart = abs(int(self.linenostart))
    self.linenostep  = abs(int(self.linenostep))
%    \end{MacroCode}
%
% \subsection{\texttt{FV}class}
% 
%    \begin{MacroCode}
class FVOpts(BaseOpts):
  gobble = 0
  tabsize = 4
  linenosep = '0pt'
  commentchar = ''
  frame = 'none'
  framerule = '0.4pt',
  framesep = r'\fboxsep',
  rulecolor = 'black',
  fillcolor = '',
  label = ''
  labelposition = 'none'
  numbers = 'left'
  numbersep = '1ex'
  firstnumber = 'auto'
  stepnumber = 1
  numberblanklines = True
  firstline = ''
  lastline = ''
  baselinestretch = 'auto'
  resetmargins = True
  xleftmargin = '0pt'
  xrightmargin = '0pt'
  hfuzz = '2pt'
  vspace = r'\topsep'
  samepage = False
  def __init__(self, *args, **kvargs):
    super().__init__(*args, **kvargs)
    self.gobble  = abs(int(self.gobble))
    self.tabsize = abs(int(self.tabsize))
    if self.firstnumber != 'auto':
      self.firstnumber = abs(int(self.firstnumber))
    self.stepnumber = abs(int(self.stepnumber))
%    \end{MacroCode}
%
% \subsection{\texttt{Arguments}class}
%
%    \begin{MacroCode}
class Arguments(BaseOpts):
  cache  = False
  debug  = False
  source = ""
  style  = "default"
  json   = ""
  directory = "."
  texopts = TeXOpts()
  pygopts = PygOpts()
  fv_opts = FVOpts()
%    \end{MacroCode}
% \section{\texttt{Controller} main class}
%    \begin{MacroCode}[OK]
class Controller:
%    \end{MacroCode}
%
% \subsection{Static methods}
%
% \begin{function}{object_hook}
% Helper for json parsing.
% \end{function}
%    \begin{MacroCode}[OK]
  @staticmethod
  def object_hook(d):
    __cls__ = d.get('__cls__', 'Arguments')
    if __cls__ == 'PygOpts':
      return PygOpts(d)
    elif __cls__ == 'FVOpts':
      return FVOpts(d)
    elif __cls__ == 'TeXOpts':
      return TeXOpts(d)
    elif __cls__ == 'BooleanTrue':
      return True
    elif __cls__ == 'BooleanFalse':
      return False
    else:
      return Arguments(d)
%    \end{MacroCode}
%
% \begin{function}{lua_command,lua_command_now,lua_debug}
% \begin{syntax}
% self.lua_command(\meta{asynchronous lua command})
% self.lua_command_now(\meta{synchronous lua command})
% \end{syntax}
% Wraps the given command between markers. It will be in the output of the
% \CDRPy{}, further captured by \CDRLua{}
% and either forwarded to \TeX{} ot executed synchronously.
% \end{function}
%    \begin{MacroCode}[OK]
  @staticmethod
  def lua_command(cmd):
    print(f'<<<<<*LUA:{cmd}>>>>>')
  @staticmethod
  def lua_command_now(cmd):
    print(f'<<<<<!LUA:{cmd}>>>>>')
  @staticmethod
  def lua_debug(msg):
    print(f'<<<<<?LUA:{msg}>>>>>')
%    \end{MacroCode}
%
% \begin{function}{lua_text_escape}
% \begin{syntax}
% self.lua_text_escape(\meta{text})
% \end{syntax}
% Wraps the given command between |[=...=[| and |]=...=]|
% with as many equal signs as necessary to ensure a correct |lua| syntax.
% \end{function}
%    \begin{MacroCode}[OK]
  @staticmethod
  def lua_text_escape(s):
    k = 0
    for m in re.findall('=+', s):
      if len(m) > k: k = len(m)
    k = (k + 1) * "="
    return f'[{k}[{s}]{k}]'
%    \end{MacroCode}
%
% \subsection{Computed properties}
%
% \begin{variable}{self.json_p}
% The full path to the \texttt{json} file containing all the data used for the processing.
% \end{variable}
%    \begin{MacroCode}[OK]
  _json_p = None
  @property
  def json_p(self):
    p = self._json_p
    if p:
      return p
    else:
      p = self.arguments.json
      if p:
        p = Path(p).resolve()
    self._json_p = p
    return p
%    \end{MacroCode}
%
% \begin{variable}{self.parser}
% The correctly set up \texttt{argarse} instance. 
% \end{variable}
%    \begin{MacroCode}[OK]
  @property
  def parser(self):
    parser = argparse.ArgumentParser(
      prog=sys.argv[0],
      description='''
Writes to the output file a set of LaTeX macros describing
the syntax hilighting of the input file as given by pygments.
'''
    )
    parser.add_argument(
      "-v", "--version",
      help="Print the version and exit",
      action='version',
      version=f'coder-tool version {__version__},'
      ' (c) {__YEAR__} by Jérôme LAURENS.'
    )
    parser.add_argument(
      "--debug",
      action='store_true',
      default=None,
      help="display informations useful for debugging"
    )
    parser.add_argument(
      "--create_style",
      action='store_true',
      default=None,
      help="create the style definitions"
    )
    parser.add_argument(
      "--base",
      action='store',
      default=None,
      help="the path of the file to be colored, with no extension"
    )
    parser.add_argument(
      "json",
      metavar="<json data file>",
      help="""
file name with extension, contains processing information.
"""
    )
    return parser

%    \end{MacroCode}
%
% \subsection{Methods}
% \subsubsection{\texttt{__init__}}
% \begin{function}{__init__}
% Constructor. Reads the command line arguments.
% \end{function}
%    \begin{MacroCode}[OK]
  def __init__(self, argv = sys.argv):
    argv = argv[1:] if re.match(".*coder\-tool\.py$", argv[0]) else argv
    ns = self.parser.parse_args(
      argv if len(argv) else ['-h']
    )
    with open(ns.json, 'r') as f:
      self.arguments = json.load(
        f,
        object_hook = Controller.object_hook
      )
    args = self.arguments
    args.json = ns.json
    self.texopts = args.texopts
    pygopts = self.pygopts = args.pygopts
    fv_opts = self.fv_opts = args.fv_opts
    self.formatter = LatexFormatter(
      style = pygopts.style,
      nobackground = pygopts.nobackground,
      commandprefix = pygopts.commandprefix,
      texcomments  = pygopts.texcomments,
      mathescape   = pygopts.mathescape,
      escapeinside = pygopts.escapeinside,
      envname = 'CDR@Pyg@Verbatim',
    )

    try:
      lexer = self.lexer = get_lexer_by_name(pygopts.lang)
    except ClassNotFound as err:
      sys.stderr.write('Error: ')
      sys.stderr.write(str(err))

    escapeinside = pygopts.escapeinside
    # When using the LaTeX formatter and the option `escapeinside` is
    # specified, we need a special lexer which collects escaped text
    # before running the chosen language lexer.
    if len(escapeinside) == 2:
      left  = escapeinside[0]
      right = escapeinside[1]
      lexer = self.lexer = LatexEmbeddedLexer(left, right, lexer)

    gobble = fv_opts.gobble
    if gobble:
      lexer.add_filter('gobble', n=gobble)
    tabsize = fv_opts.tabsize
    if tabsize:
      lexer.tabsize = tabsize
    lexer.encoding = ''
    args.base = ns.base
    args.create_style = ns.create_style
    if ns.debug:
      args.debug = True
    # IN PROGRESS: support for extra keywords
    # EXTRA_KEYWORDS = set(('foo', 'bar', 'foobar', 'barfoo', 'spam', 'eggs'))
    # def over(self, text):
    #   for index, token, value in lexer.__class__.get_tokens_unprocessed(self, text):
    #     if token is Name and value in EXTRA_KEYWORDS:
    #       yield index, Keyword.Pseudo, value
    #   else:
    #       yield index, token, value
    # lexer.get_tokens_unprocessed = over.__get__(lexer)

%    \end{MacroCode}
%
% \subsubsection{\texttt{create\texorpdfstring{_}{-}style}}
% \begin{function}{self.create_style}
% \begin{syntax}
% self.create_style()
% \end{syntax}
% Where the \meta{style} is created.
% Does quite nothing if the style is already available.
% \end{function}
%    \begin{MacroCode}[OK]
  def create_style(self):
    args = self.arguments
    if not args.create_style:
      return
    texopts = args.texopts
    pyg_sty_p = texopts.pyg_sty_p
    if args.cache and pyg_sty_p.exists():
      return
    texopts = self.texopts
    style = self.pygopts.style
    formatter = self.formatter
    style_defs = formatter.get_style_defs() \
      .replace(r'\makeatletter', '') \
      .replace(r'\makeatother', '') \
      .replace('\n', '%\n')
    sty = self.texopts.sty_template.replace(
      '<placeholder:style_name>',
      style,
    ).replace(
      '<placeholder:style_defs>', 
      style_defs,
    ).replace(
      '{}%',
      '{%}\n}%{'
    ).replace(
      '[}%',
      '[%]\n}%'
    ).replace(
      '{]}%',
      '{%[\n]}%'
    )
    with pyg_sty_p.open(mode='w',encoding='utf-8') as f:  
      f.write(sty)
    if args.debug:
      print('STYLE', os.path.relpath(pyg_sty_p))
%    \end{MacroCode}
%
% \subsubsection{\texttt{pygmentize}}
% \begin{function}{self.pygmentize}
% \begin{syntax}
% \meta{code variable} = self.pygmentize(\meta{code}[, inline=\meta{yorn}])
% \end{syntax}
% Where the \meta{code} is hilighted by \pkg{pygments}.
% \end{function}
%    \begin{MacroCode}[OK]
  def pygmentize(self, source):
    source = hilight(source, self.lexer, self.formatter)
    m = re.match(
      r'\\begin{CDR@Pyg@Verbatim}.*?\n(.*?)\n\\end{CDR@Pyg@Verbatim}\s*\Z',
      source,
      flags=re.S
    )
    assert(m)
    hilighted = m.group(1)
    texopts = self.texopts
    if texopts.is_inline:
      s = r'\CDR@Setup{'
      if texopts.synctex_tag:
        s += f'synctex_tag={texopts.synctex_tag},'
      if texopts.synctex_line:
        s += f'synctex_line={texopts.synctex_line},'
      s+='}'
      return s + hilighted.replace(' ', r'\CDR@Sp ')+r'\ignorespaces'
    lines = hilighted.split('\n')
    ans_code = []
    last = 0
    for line in lines:
      last += 1
      ans_code.append(rf'''\CDR@Line{{{last}}}{{{line}}}''')
    if last:
      s = r'\CDR@Setup{'
      s += f'last={last},'
      if texopts.synctex_tag:
        s += f'synctex_tag={texopts.synctex_tag},'
      if texopts.synctex_line:
        s += f'synctex_line={texopts.synctex_line},'
      s+='}'
      ans_code.insert(0, s)
    hilighted = '\n'.join(ans_code)
    return hilighted
%    \end{MacroCode}
%
% \subsubsection{\texttt{create_pygmented}}
% \begin{function}{self.create_pygmented}
% \begin{syntax}
% self.create_pygmented()
% \end{syntax}
% Call \texttt{self.pygmentize} and save the resulting pygmented code
% at the proper location.
% \end{function}
%    \begin{MacroCode}[OK]
  def create_pygmented(self):
    args = self.arguments
    base = args.base
    if not base:
      return False
    source = args.source
    if not source:
      tex_p = Path(base).with_suffix('.tex')
      with open(tex_p, 'r') as f:
        source = f.read()
    if args.debug:
      print('SOURCE', source)
    pyg_tex_p = Path(base).with_suffix('.pyg.tex')
    hilighted = self.pygmentize(source)
    with pyg_tex_p.open(mode='w',encoding='utf-8') as f:
      f.write(hilighted)
    if args.debug:
      print('HILIGHTED', os.path.relpath(pyg_tex_p), hilighted)
%    \end{MacroCode}
%
% \subsection{Main entry}
%
%    \begin{MacroCode}[OK]
if __name__ == '__main__':
  try:
    ctrl = Controller()
    x = ctrl.create_style() or ctrl.create_pygmented()
    print(f'{sys.argv[0]}: done')    
    sys.exit(x)
  except KeyboardInterrupt:
    sys.exit(1)
%</py>
%    \end{MacroCode}
%
% \part{\CDRSty{} implementation}
%    \begin{MacroCode}
%<*sty>
\makeatletter
%    \end{MacroCode}
%
% \section{Setup}
%
% \subsection{\string\CDRMeta}
% 
% \begin{function}{\CDRMeta,\CDRMeta*}
% \begin{syntax}
% \cs{CDRMeta} \Arg{description}
% \end{syntax}
% Typeset the \meta{description} with |\CDRMetaFormat|
% and enclosed between $\langle$ and $\rangle$.
% The starred version is typeset in tt when not in tt,
% and in default font oherwise.
% \end{function}
%    \begin{MacroCode}
\DeclareDocumentCommand \CDRMeta { s m }
  { \CDR_meta:nn {#1} { #2 } }
\cs_new_protected:Npn \CDR_meta:nn #1 #2 {
  \tl_set:Nn \l_CDR_a_tl {#2}
  \tl_map_inline:nn {
    3 4 7 8 { 11 } { 12 } { 13 }
  } {
    \tl_set_rescan:Nnn \l_CDR_b_tl {
      \char_set_catcode:nn { `_ } {##1}
    } { _ }
    \exp_args:NNV
    \tl_replace_all:Nnn \l_CDR_a_tl \l_CDR_b_tl
      { \CDRMeta_sub:n }
  }
  \exp_args:NnV \CDRMeta_angle:nn { #1 } \l_CDR_a_tl
}
\cs_new_protected:Npn \CDRMeta_sub:n #1 {
  \ensuremath { \sb {#1} }
}
\tl_const:Nn \CDRMetaFormat { \slshape }
\cs_new_protected:Npn \CDRMetaFormat:n #1 {
  \CDRMetaFormat
  \IfBooleanTF { #1 } {
    \group_begin:
    \ttfamily
    \exp_args:NNNV
    \group_end:
    \exp_args:NnV
    \tl_if_eq:nnTF\f@family\f@family {
      \fontfamily{\familydefault}\selectfont
    } {
      \ttfamily
    }
  } { }
}
\cs_new_protected:Npn \CDRMeta_angle:nn #1 #2 {
  \ensuremath \langle
  \mode_if_math:T { \nfss@text }
  {
    \CDRMetaFormat:n { #1 }
    \edef \CDR: {
      \hyphenchar \the \font \the \hyphenchar \font
    }
    \hyphenchar \font \m@ne
    \language \l@nohyphenation
    #2 \/
    \CDR:
  }
  \ensuremath \rangle
}
%    \end{MacroCode}
%
%
% \subsection{Utilities}
%
% \begin{function}{\CDR_set_conditional:Nn}
% \begin{syntax}
% \cs{CDR_set_conditional:Nn} \meta{core name} \Arg{condition}
% \end{syntax}
% Wrapper over |\prg_set_conditional:Nnn|.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_set_conditional:Nn #1 #2 {
  \bool_if:nTF { #2 } {
    \prg_set_conditional:Nnn #1 { p, T, F, TF } { \prg_return_true: }
  } {
    \prg_set_conditional:Nnn #1 { p, T, F, TF } { \prg_return_false: }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_set_conditional_alt:Nn}
% \begin{syntax}
% \cs{CDR_set_conditional_alt:Nnnn} \meta{core name} \Arg{condition}
% \end{syntax}
% Wrapper over |\prg_set_conditional:Nnn|.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_set_conditional_alt:Nn #1 #2 {
  \prg_set_conditional:Nnn #1 { p, T, F, TF } {
    \bool_if:nTF { #2 } { \prg_return_true: } { \prg_return_false: }
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP,pTF]
%   {\CDR_has_pygments:}
%   \begin{syntax}
%     \cs{CDR_has_pygments:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \metatt{true code} when \pkg{pygments} is available,
% \meta{false code} otherwise.
% \emph{Implementation detail}: we define the conditionals to raise and set
% them later by a call to |\CDR_pygments_setup:n|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
  \PackageError { coder } { Internal~error(pygments~path) } { Please~report~error }
}
%    \end{MacroCode}
%
% \begin{function} { \CDR_pygments_setup:n }
%   \begin{syntax}
%     \cs{CDR_pygments_setup:n} \Arg{boolean string}
%   \end{syntax}
% Set up the conditional set |\CDR_has_pygments...| according to \metatt{boolean string}. When this string is |true|, then \pkg{\jobname} has pygments, it has not otherwise.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_pygments_setup:n #1 {
  \cs_undefine:N \CDR_has_pygments:T
  \cs_undefine:N \CDR_has_pygments:F
  \cs_undefine:N \CDR_has_pygments:TF
  \cs_undefine:N \CDR_has_pygments_p:
  \str_if_eq:nnTF { #1 } { true } {
    \prg_new_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
      \prg_return_true:
    }
  } {
    \prg_new_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
      \prg_return_false:
    }
  }
}
\lua_now:n { CDR = require("coder-util") }
\exp_args:Nx \CDR_pygments_setup:n {
  \lua_now:n { CDR:set_python_path() }
}
\cs_new:Npn \CDR_pygments_setup: {
  \sys_get_shell:nnNTF {which~pygmentize} { \cc_select:N \c_str_cctab } \l_CDR_a_tl {
    \tl_if_in:NnTF \l_CDR_a_tl { pygmentize } {
      \prg_set_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
        \prg_return_true:
      }  
    } {
      \prg_set_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
        \prg_return_false:
      }  
    }
  } {
    \typeout {Shell~escape~is~not~available}
  }
}
%    \end{MacroCode}
%







%    \begin{MacroCode}
\NewDocumentCommand \CDRTest {} {
  \par\noindent
  Path~to~\textsf{python}:~\texttt{\directlua{tex.print(CDR.PYTHON_PATH)}}
  \par\noindent
  Path~to~\textsf{pygmentize}:~\texttt{\directlua{tex.print(CDR.PYGMENTIZE_PATH)}}
  \par\noindent
  \CDR_has_pygments:TF { Pygments~is~available } { Pygments~is~not~available
}:~%\CDRCode[lang=tex]|\textit{text}|
  \par\noindent
}
%    \end{MacroCode}
% \section{Messages}
%    \begin{MacroCode}[OK]
\msg_new:nnn { coder } { unknown-choice } {
  #1~given~value~`#3'~not~in~#2
}
%    \end{MacroCode}
% \section{Constants}
% \begin{variable}{\c_CDR_tags,\c_CDR_Tag}
% Paths of \pkg{L3keys} modules.\\
% These are root path components used throughout the pakage.
% The latter is a subpath of the former.
%    \begin{MacroCode}[OK]
\str_const:Nn \c_CDR_Tag { CDR@Tag }
\str_const:Nx \c_CDR_tags { \c_CDR_Tag / tags }
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\c_CDR_tag_get}
% Root identifier for tag properties, used throughout the pakage.
% \vspace{1\baselineskip}
%    \begin{MacroCode}[OK]
\str_const:Nn \c_CDR_tag_get { CDR@tag@get }
%    \end{MacroCode}
% \end{variable}
%
% \section{Implementation details}
% As far as possible, macro making assignments
% to variables are protected.
% All variables following \pkg{expl3} naming conventions are
% implementation details and therefore must be considered private.
%
% Many functions have useful hooks for debugging or testing.
%
% \begin{function}{\CDR@Debug}
% \begin{syntax}
% \cs{CDR@Debug} \Arg{argument}
% \end{syntax}
% The default implementation just gobbles its argument.
% During development or testing, this may call |\typeout|.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR@Debug { \use_none:n }
%    \end{MacroCode}
% \end{function}
%
% \section{Variables}
%
% \subsection{Internal scratch variables}
% These local variables are used in a very limited scope.
% \begin{variable}{\l_CDR_bool}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\bool_new:N \l_CDR_bool
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_[a$\vert$b]_tl}
% Local scratch variables.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_a_tl
\tl_new:N \l_CDR_b_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_str}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\str_new:N \l_CDR_str
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_seq}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\seq_new:N \l_CDR_seq
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_prop}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\prop_new:N \l_CDR_prop
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_clist}
% The comma separated list of current chunks.
%    \begin{MacroCode}[OK]
\clist_new:N \l_CDR_clist
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\l_CDR_ior}
% Input file identifier
%    \begin{MacroCode}[OK]
\ior_new:N \l_CDR_ior
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\l_CDR_kv_clist}
% keyval storage.
%    \begin{MacroCode}
\clist_new:N \l_CDR_kv_clist
%    \end{MacroCode}
% \end{variable}
%
% \subsection{Counters}
%
% \begin{function}{\CDR_int_new:cn}
% \begin{syntax}
% \cs{CDR_int_new:cn} \Arg{tag name} \Arg{value}
% \end{syntax}
% Create an integer after \metatt{tag name} and
% set it globally to \metatt{value}.
%    \begin{MacroCode}
\cs_new:Npn \CDR_int_new:cn #1 #2 {
  \int_new:c { CDR@int.#1 }
  \int_gset:cn { CDR@int.#1 } { #2 }
}
%    \end{MacroCode}
% \end{function}
% \begin{variable}{default}
% Generic and named line number counter.
%    \begin{MacroCode}[OK]
\CDR_int_new:cn { default } { 1 }
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{__n}
% Generic and named line number counter.
%    \begin{MacroCode}[OK]
\CDR_int_new:cn { __n } { 1 }
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{__i}
% Generic and named line number counter.
%    \begin{MacroCode}[OK]
\CDR_int_new:cn { __i } { 1 }
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{__line}
% Generic and named line number counter.
%    \begin{MacroCode}[OK]
\CDR_int_new:cn { __line } { 1 }
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}[EXP]{\CDR_int:c}
% \begin{syntax}
% \cs{CDR_int:c} \Arg{tag name}
% \end{syntax}
% Use the integer named after \metatt{tag name}.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int:c #1 {
  \use:c { CDR@int.#1 }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[EXP]{\CDR_int_use:c}
% \begin{syntax}
% \cs{CDR_int_use:n} \Arg{tag name}
% \end{syntax}
% Use the value of the integer named after \metatt{tag name}.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_use:c #1 {
  \int_use:c { CDR@int.#1 }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {\CDR_int_if_exist:c}
%   \begin{syntax}
%     \cs{CDR_int_if_exist:cTF} \Arg{tag name} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \metatt{true code} when
% an integer named after \metatt{tag name} exists,
% \metatt{false code} otherwise.
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_int_if_exist:c { p, T, F, TF } {
  \int_if_exist:cTF { CDR@int.#1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {\CDR_int_compare:cNn}
%   \begin{syntax}
%     \cs{CDR_int_compare:cNnTF} \Arg{tag name} \meta{operator} \Arg{intexpr_2} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Forwards to |\int_compare...| with |\CDR_int_use:c { #1 }|.
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_int_compare:cNn { p, T, F, TF } {
  \int_compare:nNnTF { \CDR_int:c { #1 } } #2 { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_int_set:cn,\CDR_int_gset:cn}
% \begin{syntax}
% \cs{CDR_int_set:cn} \Arg{tag name} \Arg{value}
% \end{syntax}
% Set the integer named after \metatt{tag name} to the \metatt{value}. \cs{CDR_int_gset:cn} makes a global change.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_set:cn #1 #2 {
  \int_set:cn { CDR@int.#1 } { #2 }
}
\cs_new:Npn \CDR_int_gset:cn #1 #2 {
  \int_gset:cn { CDR@int.#1 } { #2 }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_int_set:cc,\CDR_int_gset:cc}
% \begin{syntax}
% \cs{CDR_int_set:cc} \Arg{tag name} \Arg{other tag name}
% \end{syntax}
% Set the integer named after \metatt{tag name} to the value of
% the integer named after \metatt{other tag name}.
% \cs{CDR_int_gset:cc} makes a global change.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_set:cc #1 #2 {
  \CDR_int_set:cn { #1 } { \CDR_int:c { #2 } }
}
\cs_new:Npn \CDR_int_gset:cc #1 #2 {
  \CDR_int_gset:cn { #1 } { \CDR_int:c { #2 } }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_int_add:cn,\CDR_int_gadd:cn}
% \begin{syntax}
% \cs{CDR_int_add:cn} \Arg{tag name} \Arg{value}
% \end{syntax}
% Add the \metatt{value} to the integer named after \metatt{tag name}.
% \cs{CDR_int_gadd:cn} makes a global change.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_add:cn #1 #2 {
  \int_add:cn { CDR@int.#1 } { #2 }
}
\cs_new:Npn \CDR_int_gadd:cn #1 #2 {
  \int_gadd:cn { CDR@int.#1 } { #2 }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_int_add:cc,\CDR_int_gadd:cc}
% \begin{syntax}
% \cs{CDR_int_add:cn} \Arg{tag name} \Arg{other tag name}
% \end{syntax}
% Add to the integer named after \metatt{tag name} the value of
% the integer named after \metatt{other tag name}.
% \cs{CDR_int_gadd:cc} makes a global change.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_add:cc #1 #2 {
  \CDR_int_add:cn { #1 } { \CDR_int:c { #2 } }
}
\cs_new:Npn \CDR_int_gadd:cc #1 #2 {
  \CDR_int_gadd:cn { #1 } { \CDR_int:c { #2 } }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_int_sub:cn,\CDR_int_gsub:cn}
% \begin{syntax}
% \cs{CDR_int_sub:cn} \Arg{tag name} \Arg{value}
% \end{syntax}
% Substract the \metatt{value} from the integer named after \metatt{tag name}. \cs{CDR_int_gsub:n} makes a global change.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_sub:cn #1 #2 {
  \int_sub:cn { CDR@int.#1 } { #2 }
}
\cs_new:Npn \CDR_int_gsub:cn #1 #2 {
  \int_gsub:cn { CDR@int.#1 } { #2 }
}
%    \end{MacroCode}
%
% \subsection{Utilities}
%
% \begin{variable}{\g_CDR_tags_clist, \g_CDR_all_tags_clist, \g_CDR_last_tags_clist}
% Store the current list of tags used by |\CDRCode| and the
% |CDRBlock| environment, or declared by |\CDRExport|.
% All the tags are recorded, if there is an only one, it is not shown
% in block code chunks.
% The |\g_CDR_last_tags_clist| variable contains the last list of tags that was displayed.
%    \begin{MacroCode}[OK]
\clist_new:N \g_CDR_tags_clist
\clist_new:N \g_CDR_all_tags_clist
\clist_new:N \g_CDR_last_tags_clist
\AddToHook { shipout/before } {
  \clist_gclear:N \g_CDR_last_tags_clist
}
%    \end{MacroCode}
% \end{variable}
%
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_clist_if_eq:NN { p, T, F, TF } {
  \tl_if_eq:NNTF #1 #2 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \section{Tag properties}
% The tag properties concern the code chunks.
% They are set from different paths, such that
% |\l_keys_path_str| must
% be properly parsed for that purpose.
% Commands in this section and the next ones contain |CDR_tag|.
%
% The \metatt{tag names} starting with a double underscore are reserved by the package.
%
% \subsection{Helpers}
%
% \begin{function}[EXP]{\CDR_tag_get_path:cc, \CDR_tag_get_path:c}
% \begin{syntax}
% \cs{CDR_tag_get_path:cc} \Arg{tag name} \Arg{relative key path}
% \cs{CDR_tag_get_path:c} \Arg{relative key path}
% \end{syntax}
% Internal: return a unique key based on the arguments.
% Used to store and retrieve values.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_get_path:cc #1 #2 {
  \c_CDR_tag_get @ #1 / #2
}
\cs_new:Npn \CDR_tag_get_path:c {
  \CDR_tag_get_path:cc { __local }
}
%    \end{MacroCode}
%
% \subsection{Set}
% \begin{function}{\CDR_tag_set:ccn,\CDR_tag_set:ccV}
% \begin{syntax}
% \cs{CDR_tag_set:ccn} \Arg{tag name} \Arg{relative key path} \Arg{value}
% \end{syntax}
% Store \metatt{value}, which is further retrieved with the instruction
% |\CDR_tag_get:cc {|\metatt{tag name}|}| \linebreak[3]|{|\metatt{relative key path}|}|.
% Only \metatt{tag name} and \metatt{relative key path}
% containing no |@| character are supported.
% All the affectations are made at the current \TeX{} group level.
% \emph{Nota Bene:} |\cs_generate_variant:Nn| is buggy when there is a `c' argument.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_tag_set:ccn #1 #2 #3 {
  \cs_set:cpn { \CDR_tag_get_path:cc { #1 } { #2 } } { \exp_not:n { #3 } }
}
\cs_new_protected:Npn \CDR_tag_set:ccV #1 #2 #3 {
  \exp_args:NnnV
  \CDR_tag_set:ccn { #1 } { #2 } #3
}
%    \end{MacroCode}
%
% \begin{variable}{\c_CDR_tag_regex}
% To parse a \pkg{l3keys} full key path.
%    \begin{MacroCode}[OK]
\tl_set:Nn \l_CDR_a_tl { /([^/]*)/(.*)$ } \use_none:n { $ }
\tl_put_left:NV \l_CDR_a_tl \c_CDR_tags
\tl_put_left:Nn \l_CDR_a_tl { ^ }
\exp_args:NNV
\regex_const:Nn \c_CDR_tag_regex \l_CDR_a_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDR_tag_set:n}
% \begin{syntax}
% \cs{CDR_tag_set:n} \Arg{value}
% \end{syntax}
% The value is provided but not the \meta{dir} nor the \meta{relative key path},
% both are guessed from |\l_keys_path_str|.
% More precisely, |\l_keys_path_str| is expected to read something like
% \cs{c_CDR_tags}|/|\metatt{tag name}|/|\metatt{relative key path},
% an error is raised on the contrary.
% This is meant to be called from |\keys_define:nn| argument.
% Implementation detail: the last argument is parsed by the last command.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_tag_set:n {
  \exp_args:NnV
  \regex_extract_once:NnNTF \c_CDR_tag_regex
      \l_keys_path_str \l_CDR_seq {
    \CDR_tag_set:ccn
      { \seq_item:Nn \l_CDR_seq 2 }
      { \seq_item:Nn \l_CDR_seq 3 }
  } {
    \PackageWarning
      { coder }
      { Unexpected~key~path~`\l_keys_path_str' }
    \use_none:n
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR_tag_set:}
% \begin{syntax}
% \cs{CDR_tag_set:}
% \end{syntax}
% None of \meta{dir}, \meta{relative key path} and \metatt{value} are provided.
% The latter is guessed from |\l_keys_value_tl|, and |CDR_tag_set:n| is called.
% This is meant to be call from |\keys_define:nn| argument.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_tag_set: {
  \exp_args:NV
  \CDR_tag_set:n \l_keys_value_tl
}
%    \end{MacroCode}
% \begin{function}{\CDR_tag_set:cn}
% \begin{syntax}
% \cs{CDR_tag_set:cn} \Arg{key path} \Arg{value}
% \end{syntax}
% When the last component of |\l_keys_path_str| should not be used
% to store the \metatt{value}, but \metatt{key path} should be used instead.
% This last component is replaced and |\CDR_tag_set:n| is called afterwards.
% Implementation detail: the second argument is parsed by the last command
% of the expansion.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_set:cn #1 {
  \exp_args:NnV
  \regex_extract_once:NnNTF \c_CDR_tag_regex
      \l_keys_path_str \l_CDR_seq {
    \CDR_tag_set:ccn
      { \seq_item:Nn \l_CDR_seq 2 }
      { #1 }
  } {
    \PackageWarning
      { coder }
      { Unexpected~key~path~`\l_keys_path_str' }
    \use_none:n
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR_tag_choices:}
% \begin{syntax}
% \cs{CDR_tag_choices:}
% \end{syntax}
% Ensure that the |\l_keys_path_str| is set properly.
% This is where a syntax like |\keys_set:nn {...} { choice/a }|
% is managed.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_generate_conditional_variant:Nnn \str_if_eq:nn { Vn } { p, T, F, TF }

\regex_const:Nn \c_CDR_root_regex { ^(.*)/.*$ } \use_none:n { $ }
\cs_new:Npn \CDR_tag_choices: {
  \str_if_eq:nnT \l_keys_key_tl \l_keys_choice_tl {
    \exp_args:NnV
    \regex_extract_once:NnNT \c_CDR_root_regex
        \l_keys_path_str \l_CDR_seq {
      \str_set:Nx \l_keys_path_str {
        \seq_item:Nn \l_CDR_seq 2
      }
    }
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR_tag_choices_set:}
% \begin{syntax}
% \cs{CDR_tag_choices_set:}
% \end{syntax}
% Calls |\CDR_tag_set:n| with the content of |\l_keys_choice_tl| as value.
% Before, ensure that the |\l_keys_path_str| is set properly.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_tag_choices_set: {
  \CDR_tag_choices:
  \exp_args:NV
  \CDR_tag_set:n \l_keys_choice_tl
}
%    \end{MacroCode}
%
% \begin{function}[EXP,pTF]{ \CDR_if_tag_truthy:cc, \CDR_if_tag_truthy:c }
% \begin{syntax}
% \cs{CDR_if_tag_truthy:ccTF} \Arg{tag name} \Arg{relative key path} \Arg{true code} \Arg{false code}
% \cs{CDR_if_tag_truthy:cTF} \Arg{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when the property for \metatt{tag name}
% and \metatt{relative key path} is a truthy value,
% \metatt{false code} otherwise.
% A truthy value is a text which is not ``false'' in a case insensitive comparison.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_tag_truthy:cc { p, T,  F, TF } {
  \exp_args:Ne
  \str_compare:nNnTF {
    \exp_args:Ne \str_lowercase:n { \CDR_tag_get:cc { #1 } { #2 } }
  } = { true } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDR_if_tag_truthy:c { p, T,  F, TF } {
  \exp_args:Ne
  \str_compare:nNnTF {
    \exp_args:Ne \str_lowercase:n { \CDR_tag_get:c { #1 } }
  } = { true } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP,pTF]{ \CDR_if_tag_eq:ccn, \CDR_if_tag_eq:cn }
% \begin{syntax}
% \cs{CDR_if_tag_eq:ccnTF} \Arg{tag name} \Arg{relative key path} \Arg{value} \Arg{true code} \Arg{false code}
% \cs{CDR_if_tag_eq:cnTF} \Arg{relative key path} \Arg{value} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when the property for \metatt{tag name}
% and \metatt{relative key path} is equal to \Arg{value},
% \metatt{false code} otherwise.
% The comparison is based on |\str_compare:...|.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_tag_eq:ccn { p, T,  F, TF } {
  \exp_args:Nf
  \str_compare:nNnTF { \CDR_tag_get:cc { #1 } { #2 } } = { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDR_if_tag_eq:cn { p, T,  F, TF } {
  \exp_args:Nf
  \str_compare:nNnTF { \CDR_tag_get:cc { __local } { #1 } } = { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP,pTF]{ \CDR_if_truthy:n }
% \begin{syntax}
% \cs{CDR_if_truthy:nTF} \Arg{token list} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when \metatt{token list} is a truthy value,
% \metatt{false code} otherwise.
% A truthy value is a text which leading character, if any,
% is none of ``fFnN''.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_truthy:n { p, T,  F, TF } {
  \exp_args:Ne
  \str_compare:nNnTF { \exp_args:Ne \str_lowercase:n { #1 } } = { true } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_tag_boolean_set:n}
% \begin{syntax}
% \cs{CDR_tag_boolean_set:n} \Arg{choice}
% \end{syntax}
% Calls |\CDR_tag_set:n| with |true| if the argument is truthy,
% |false| otherwise.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_tag_boolean_set:n #1 {
  \CDR_if_truthy:nTF { #1 } {
    \CDR_tag_set:n { true }
  } {
    \CDR_tag_set:n { false }
  }
}
\cs_generate_variant:Nn \CDR_tag_boolean_set:n { x }
%    \end{MacroCode}
%
% \subsection{Retrieving tag properties}
% Internally, all tag properties are collected with a full key path like
% |\c_CDR_tag_get/|\metatt{tag name}|/|\metatt{relative key path}.
% When typesetting some code with either the \cs{CDRCode} command or the
% |CDRBlock| environment, all properties defined locally are collected under
% the reserved |\c_CDR_tag_get/__local/|\metatt{relative path} full key paths.
% The \pkg{l3keys} module |\c_CDR_tag_get/__local| is modified in \TeX{} groups only.
% For running text code chunks, this module inherits from
% \begin{enumerate}
% \item |\c_CDR_tag_get/|\metatt{tag name} for the provided \metatt{tag name},
% \item |\c_CDR_tag_get/default.code|
% \item |\c_CDR_tag_get/default|
% \item |\c_CDR_tag_get/__pygments|
% \item |\c_CDR_tag_get/__fancyvrb|
% \item |\c_CDR_tag_get/__fancyvrb.all| when no using \pkg{pygments}
% \end{enumerate}
% For text block code chunks, this module inherits from
% \begin{enumerate}
% \item |\c_CDR_tag_get/|\metatt{name_1}, ..., |\c_CDR_tag_get/|\metatt{name_n}
% for each tag name of the ordered tags list
% \item |\c_CDR_tag_get/default.block|
% \item |\c_CDR_tag_get/default|
% \item |\c_CDR_tag_get/__pygments|
% \item |\c_CDR_tag_get/__pygments.block|
% \item |\c_CDR_tag_get/__fancyvrb|
% \item |\c_CDR_tag_get/__fancyvrb.block|
% \item |\c_CDR_tag_get/__fancyvrb.all| when no using \pkg{pygments}
% \end{enumerate}
%
% \begin{function}[pTF,EXP]{\CDR_if_tag_exist_here:cc}
% \begin{syntax}
% \cs{CDR_if_tag_exist_here:ccTF} \Arg{tag name} \meta{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% If the \metatt{relative key path} is known within \metatt{tag name},
% the \metatt{true code} is executed,
% otherwise, the \metatt{false code} is executed.
% No inheritance.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_tag_exist_here:cc { p, T, F, TF } {
  \cs_if_exist:cTF { \CDR_tag_get_path:cc { #1 } { #2 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \begin{function}[pTF,EXP]{\CDR_if_tag_exist:cc, \CDR_if_tag_exist:c}
% \begin{syntax}
% \cs{CDR_if_tag_exist:ccTF} \Arg{tag name} \meta{relative key path} \Arg{true code} \Arg{false code}
% \cs{CDR_if_tag_exist:cTF} \meta{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% If the \metatt{relative key path} is known within \metatt{tag name},
% the \metatt{true code} is executed,
% otherwise, the \metatt{false code} is executed if none of the  parents has the \metatt{relative key path} on its own.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_tag_exist:cc { p, T, F, TF } {
  \cs_if_exist:cTF { \CDR_tag_get_path:cc { #1 } { #2 } } {
    \prg_return_true:
  } {
    \seq_if_exist:cTF { \CDR_tag_parent_seq:c { #1 } } {
      \seq_map_tokens:cn
        { \CDR_tag_parent_seq:c { #1 } }
        { \CDR_if_tag_exist_f:cn { #2 } }
    } {
      \prg_return_false:
    }
  }
}
\prg_new_conditional:Nnn \CDR_if_tag_exist:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDR_tag_get_path:c { #1 } } {
    \prg_return_true:
  } {
    \seq_if_exist:cTF { \CDR_tag_parent_seq:c { __local } } {
      \seq_map_tokens:cn
        { \CDR_tag_parent_seq:c { __local } }
        { \CDR_if_tag_exist_f:cn { #1 } }
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \CDR_if_tag_exist_f:cn #1 #2 {
  \quark_if_no_value:nTF { #2 } {
    \seq_map_break:n {
      \prg_return_false:
    }
  } {
    \CDR_if_tag_exist:ccT { #2 } { #1 } {
      \seq_map_break:n {
        \prg_return_true:
      }
    }
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP]{\CDR_tag_get:cc, \CDR_tag_get:c}
% \begin{syntax}
% \cs{CDR_tag_get:cc} \Arg{tag name} \Arg{relative key path}
% \cs{CDR_tag_get:c} \Arg{relative key path}
% \end{syntax}
% The property value stored for \metatt{tag name}
% and \metatt{relative key path}.
% Takes care of inheritance.
% In the second version, the \metatt{tag name} is not provided an set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_get:cc #1 #2 {
  \CDR_if_tag_exist_here:ccTF { #1 } { #2 } {
    \use:c { \CDR_tag_get_path:cc { #1 } { #2 } }
  } {
    \seq_if_exist:cT { \CDR_tag_parent_seq:c { #1 } } {
      \seq_map_tokens:cn
        { \CDR_tag_parent_seq:c { #1 } }
        { \CDR_tag_get_f:cn { #2 } }
    }
  }
}
\cs_new:Npn \CDR_tag_get_f:cn #1 #2 {
  \quark_if_no_value:nF { #2 } {
    \CDR_if_tag_exist_here:ccT { #2 } { #1 } {
      \seq_map_break:n {
        \use:c { \CDR_tag_get_path:cc { #2 } { #1 } }  
      }
    }
  }
}
\cs_new:Npn \CDR_tag_get:c {
  \CDR_tag_get:cc { __local }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_tag_get:ccN, \CDR_tag_get:cN}
% \begin{syntax}
% \cs{CDR_tag_get:ccN} \Arg{tag name} \Arg{relative key path} \Arg{tl variable}
% \cs{CDR_tag_get:cN} \Arg{relative key path} \Arg{tl variable}
% \end{syntax}
% Put in \metatt{tl variable} the property value stored
% for the |__local| \metatt{tag name} and \metatt{relative key path}.
% In the second version, the \metatt{tag name} is not provided an set to |__local|.
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_tag_get:ccN #1 #2 #3 {
  \tl_set:Nf #3 { \CDR_tag_get:cc { #1 } { #2 } }
}
\cs_new_protected:Npn \CDR_tag_get:cN {
  \CDR_tag_get:ccN { __local }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[TF]{\CDR_tag_get:ccN, \CDR_tag_get:cN}
% \begin{syntax}
% \cs{CDR_tag_get:ccNTF} \Arg{tag name} \Arg{relative key path} \meta{tl var} \Arg{true code} \Arg{false code}
% \cs{CDR_tag_get:cNTF} \Arg{relative key path} \meta{tl var} \Arg{true code} \Arg{false code}
% \end{syntax}
% Getter with branching.
% If the \metatt{relative key path} is knwon,
% save the value into \metatt{tl var} and
% execute \meta{true code}.
% Otherwise, execute \metatt{false code}.
% In the second version, the \metatt{tag name} is not provided an set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_protected_conditional:Nnn \CDR_tag_get:ccN { T, F, TF } {
  \CDR_if_tag_exist:ccTF { #1 } { #2 } {
    \CDR_tag_get:ccN { #1 } { #2 } #3
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_protected_conditional:Nnn \CDR_tag_get:cN { T, F, TF } {
  \CDR_if_tag_exist:cTF { #1 } {
    \CDR_tag_get:cN { #1 } #2
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \subsection{Inheritance}
% When a child inherits from a parent, all the keys of the parent
% that are not inherited are made available to the child
% (inheritance does not jump over generations).
% \begin{function}[EXP]{\CDR_tag_parent_seq:c}
% \begin{syntax}
% \cs{CDR_tag_parent_seq:c} \Arg{tag name}
% \end{syntax}
% Return the name of the sequence variable containing the list of the parents. Each child has its own sequence of parents assigned locally.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_parent_seq:c #1 {
  l_CDR:parent.tag @ #1 _seq
}
%    \end{MacroCode}
% \begin{function}{\CDR_get_inherit:cn, \CDR_get_inherit:cf,\CDR_get_inherit:n, \CDR_get_inherit:f}
% \begin{syntax}
% \cs{CDR_get_inherit:cn} \Arg{child name} \Arg{parent names comma list}
% \end{syntax}
% Set the parents of \metatt{child name} to the
% given list.
% When the \metatt{child name} is not provided, it defaults to |__local|.
% Implementation detail: uses |\l_CDR_a_tl|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_get_inherit:cn #1 #2 {
  \tl_set:Nx \l_CDR_a_tl { \CDR_tag_parent_seq:c { #1 } }
  \seq_set_from_clist:cn { \l_CDR_a_tl } { #2 }
  \seq_remove_duplicates:c { \l_CDR_a_tl }
  \seq_remove_all:cn { \l_CDR_a_tl } {}
  \seq_put_right:cn { \l_CDR_a_tl } { \q_no_value }
}
\cs_new:Npn \CDR_get_inherit:cf {
  \exp_args:Nnf \CDR_get_inherit:cn
}
\cs_new:Npn \CDR_tag_parents:c #1 {
  \seq_map_inline:cn { \CDR_tag_parent_seq:c { #1 } } {
    \quark_if_no_value:nF { ##1 } {
      ##1,
    }
  }
}
\cs_new:Npn \CDR_get_inherit:n {
  \CDR_get_inherit:cn { __local }
}
\cs_new:Npn \CDR_get_inherit:f {
  \CDR_get_inherit:cf { __local }
}
%    \end{MacroCode}
% \section{Cache management}
% If there is no \metatt{jobname}|.aux| file, there should be no cached files either,
% \CDRLua{} is asked to clean all of them, if any.
%    \begin{MacroCode}[OK]
\AddToHook { begindocument/before } {
  \IfFileExists {./\jobname.aux} {} {
   \lua_now:n {CDR:cache_clean_all()}
  }
}
%    \end{MacroCode}
% At the end of the document, \CDRLua{} is asked to clean all
% unused cached files that could come from a previous process.
%    \begin{MacroCode}[OK]
\AddToHook { enddocument/end } {
  \lua_now:n {CDR:cache_clean_unused()}
}
%    \end{MacroCode}
%
% \section{Utilities}
% \begin{function}{\CDR_clist_map_inline:Nnn}
% \begin{syntax}
% \cs{CDR_clist_map_inline:Nnn} \meta{clist var} \Arg{empty code} \Arg{non empty code}
% \end{syntax}
% Execute \metatt{empty code} when the list is empty, otherwise
% call |\clist_map_inline:Nn| with \metatt{non empty code}.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_clist_map_inline:Nnn #1 #2 {
  \clist_if_empty:NTF #1 {
    #2
    \use_none:n
  } {
    \clist_map_inline:Nn #1
  }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[EXP,pTF]{\CDR_if_block:}
% \begin{syntax}
% \cs{CDR_if_block:TF} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when inside a code block,
% \metatt{false code} when inside an inline code.
% Raises an error otherwise.
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_block: { p, T, F, TF } {
  \PackageError
    { coder }
    { Conditional~not~available }
    { Internal~error:~report~bug }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_process_record:}
% Record the current line or not.
% The default implementation does nothing and is meant to
% be defines locally.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_process_record: {}
%    \end{MacroCode}
% \end{function}
%
% \section{\pkg{l3keys} modules for code chunks}
%
% All these modules are initialized at the beginning
% of the document using the |__initialize| meta key.
%
% \subsection{Utilities}
%
% \begin{function}[EXP]{\CDR_tag_module:n}
% \begin{syntax}
% \cs{CDR_tag_module:n} \Arg{module base}
% \end{syntax}
% The \metatt{module} is uniquely based on \metatt{module base}.
% This should be |f| expanded when used as |n| argument of \pkg{l3keys} functions.
%    \begin{MacroCode}[OK]
\cs_set:Npn \CDR_tag_module:n #1 {
  \str_if_eq:nnTF { #1 } { .. } {
    \c_CDR_Tag
  } {
    \tl_if_empty:nTF { #1 } { \c_CDR_tags } { \c_CDR_tags / #1 }
  }
}
%    \end{MacroCode}
% \end{function}
% \begin{function}{\CDR_tag_keys_define:nn}
% \begin{syntax}
% \cs{CDR_tag_keys_define:nn} \Arg{module base} \Arg{keyval list}
% \end{syntax}
% The \metatt{module} is uniquely based on \metatt{module base} before
% forwarding to |\keys_define:nn|.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_keys_define:nn #1 {
  \exp_args:Nf
  \keys_define:nn { \CDR_tag_module:n { #1 } }
}
%    \end{MacroCode}
% \end{function}
% \begin{function}[EXP,TF]{\CDR_tag_keys_if_exist:nn}
% \begin{syntax}
% \cs{CDR_tag_keys_if_exist:nnTF} \Arg{module base} \Arg{key} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} if there is a \metatt{key} for the given \metatt{module base},
% \metatt{false code} otherwise.
% If \metatt{module base} is empty, \Arg{key} is the module base used.
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_tag_keys_if_exist:nn { p, T, F, TF } {
  \exp_args:Nf
  \keys_if_exist:nnTF { \CDR_tag_module:n { #1 } } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_tag_keys_set:nn}
% \begin{syntax}
% \cs{CDR_tag_keys_set:nn} \Arg{module base} \Arg{keyval list}
% \end{syntax}
% The \metatt{module} is uniquely based on \metatt{module base} before
% forwarding to |\keys_set:nn|.
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_tag_keys_set:nn #1 {
  \exp_args:Nf
  \keys_set:nn { \CDR_tag_module:n { #1 } }
}
\cs_generate_variant:Nn \CDR_tag_keys_set:nn { nV }
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_tag_keys_set:nn}
% \begin{syntax}
% \cs{CDR_tag_keys_set:nn} \Arg{module base} \Arg{keyval list}
% \end{syntax}
% The \metatt{module} is uniquely based on \metatt{module base} before
% forwarding to |\keys_set:nn|.
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_local_set:n {
  \CDR_tag_keys_set:nn { __local }
}
\cs_generate_variant:Nn \CDR_local_set:n { V }
%    \end{MacroCode}
% \end{function}
%
% \subsubsection{Handling unknown tags}
% While using |\keys_set:nn| and variants, each time a full key path matching the pattern
% |\c_CDR_tag/|\metatt{tag name}|/|\metatt{relative key path}
% is not recognized, we assume that the client implicitly wants a tag
% with the given \metatt{tag name} to be defined. For that purpose, we collect
% unknown keys with |\keys_set_known:nnnN| then process them to find
% each \metatt{tag name} and define
% the new tag accordingly.
% A similar situation occurs for display engine options where the
% full key path reads
% |\c_CDR_tag/|\metatt{tag name}|/|\metatt{engine name}| engine options|
% where \metatt{engine name} is not known in advance.
%
% \begin{function}{\CDR_tag_keys_inherit:nn}
% \begin{syntax}
% \cs{CDR_tag_keys_inherit:nn} \Arg{tag name} \Arg{parents comma list}
% \end{syntax}
% Set the inheritance: \metatt{tag name} inherits from each parent, which is a tag name.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDR_tag_keys_inherit__:nnn #1 #2 #3 {
  \keys_define:nn { #1 } { #2 .inherit:n = { #1 / #3 } }
}
\cs_new_protected_nopar:Npn \CDR_tag_keys_inherit_:nnn #1 #2 #3 {
  \exp_args:Nnx
  \use:n { \CDR_tag_keys_inherit__:nnn { #1 } { #2 } } {
    \clist_use:nn { #3 } { ,#1/ }
  }
}
\cs_new_protected_nopar:Npn \CDR_tag_keys_inherit:nn {
  \exp_args:Nf
  \CDR_tag_keys_inherit_:nnn { \CDR_tag_module:n { } }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_local_inherit:n}
% \begin{syntax}
% Wrapper over |\CDR_tag_keys_inherit:nn| where \metatt{tag name} is
% given by \cs{CDR_tag_module:n}|{__local}|.
% \end{syntax}
% Set the inheritance: \metatt{tag name} inherits from each parent, which is a tag name.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDR_local_inherit:n {
  \CDR_tag_keys_inherit:nn { __local }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_tag_keys_set_known:nnN, \CDR_tag_keys_set_known:nVN, \CDR_tag_keys_set_known:nN, \CDR_tag_keys_set_known:N}
% \begin{syntax}
% \cs{CDR_tag_keys_set_known:nnN} \Arg{tag name} \Arg{key[=value] items} \meta{clist var}
% \cs{CDR_tag_keys_set_known:nN} \Arg{tag name} \meta{clist var}
% \end{syntax}
% Wrappers over |\keys_set_known:nnnN|
% where the module is given by |\CDR_tag_module:n{|\metatt{tag name}|}|.
% \emph{Implementation detail} the remaining arguments are absorbed by the last macro.
% When \metatt{key[=value] items} is omitted, it is the content of \metatt{clist var}.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDR_tag_keys_set_known__:nnN #1 #2 {
  \keys_set_known:nnnN { #1 } { #2 } { #1 }
}
\cs_new_protected_nopar:Npn \CDR_tag_keys_set_known:nnN #1 {
  \exp_args:Nf
  \CDR_tag_keys_set_known__:nnN { \CDR_tag_module:n { #1 } }
}
\cs_generate_variant:Nn \CDR_tag_keys_set_known:nnN { nV }
\cs_new_protected_nopar:Npn \CDR_tag_keys_set_known:nN #1 #2 {
  \CDR_tag_keys_set_known:nVN { #1 } #2 #2
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_tag_keys_set_known:nnN, \CDR_tag_keys_set_known:nVN, \CDR_tag_keys_set_known:nN, \CDR_tag_keys_set_known:N}
% \begin{syntax}
% \cs{CDR_local_set_known:nN} \Arg{key[=value] items} \meta{clist var}
% \cs{CDR_local_set_known:N} \meta{clist var}
% \end{syntax}
% Wrappers over |\CDR_tag_keys_set_known:...|
% where the module is given by |\CDR_tag_module:n{|__local|}|.
% When \metatt{key[=value] items} is omitted, it is the content of \metatt{clist var}.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDR_local_set_known:nN {
  \CDR_tag_keys_set_known:nnN { __local }
}
\cs_generate_variant:Nn \CDR_local_set_known:nN { V }
\cs_new_protected_nopar:Npn \CDR_local_set_known:N #1 {
  \CDR_local_set_known:VN #1 #1
}
%    \end{MacroCode}
%
% \begin{variable}{\c_CDR_provide_regex}
% To parse a \pkg{l3keys} full key path.
%    \begin{MacroCode}[OK]
\tl_set:Nn \l_CDR_a_tl { /([^/]*)(?:/(.*))?$ } \use_none:n { $ }
\exp_args:NNf
\tl_put_left:Nn \l_CDR_a_tl { \CDR_tag_module:n {} }
\tl_put_left:Nn \l_CDR_a_tl { ^ }
\exp_args:NNV
\regex_const:Nn \c_CDR_provide_regex \l_CDR_a_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDR_tag_expand_kv:n}
% \begin{syntax}
% \cs{CDR_tag_expand_kv:N} \Arg{key-value list variable}
% \end{syntax}
% Expands the keys matching |tags/|\meta{tag names list}.
% The list a comma separated list, except that the pipe character replaces the comma.
% Implementation detail: uses |\l_CDR_clist|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDR_tag_expand_kv:N #1 {
\CDR@Debug{\string\CDR_tag_expand_kv:N}
  \clist_clear:N \l_CDR_clist
  \cs_set:Npn \@CDR:n {
    \clist_put_right:Nn \l_CDR_clist
  }
  \cs_set:Npn \@CDR:nn ##1 ##2 {
    \regex_extract_once:nnNTF { ^ tags/([^/]+)(/([^/]+))? $} { ##1 } \l_CDR_seq {
      \tl_set:Nx \l_CDR_a_tl { \seq_item:Nn \l_CDR_seq 4 }
      \cs_set:Npn \@@CDR:nn ####1 ####2 {
        \clist_put_right:Nn \l_CDR_clist {
          tags / ####1 / ####2 = { ##2 }
        }
      }
      \seq_map_inline:Nn \l_CDR_seq {
        \CDR@Debug{====CAPTURE ####1}
      }
      \exp_args:Nnx
      \regex_split:nnNTF { [|] } { \seq_item:Nn \l_CDR_seq 2 } \l_CDR_seq {
        \tl_if_empty:NTF \l_CDR_a_tl {
          \seq_map_inline:Nn \l_CDR_seq {
            \clist_put_right:Nn \l_CDR_clist { tags/####1 = { ##2 } }
          }
        } {
          \seq_map_inline:Nn \l_CDR_seq {
            \exp_args:NnV \@@CDR:nn { ####1 } \l_CDR_a_tl
          }
        }
      } {
        \clist_put_right:Nn \l_CDR_clist { ##1 = { ##2 } } 
      }
    } {
      \clist_put_right:Nn \l_CDR_clist { ##1 = { ##2 } } 
    }
  }
  \exp_args:NnnV
  \keyval_parse:nnn {
    \@CDR:n
  } {
    \@CDR:nn
  } #1
  \clist_map_inline:Nn \l_CDR_clist {
    \exp_args:Nx \CDR@Debug {KV:\tl_to_str:n{##1}}
  }
  \clist_set_eq:NN #1 \l_CDR_clist
\CDR@Debug{\string\CDR_tag_expand_kv:N...DONE}
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_tag_provide_from_kv:n}
% \begin{syntax}
% \cs{CDR_tag_provide:n} \Arg{deep comma list}
% \cs{CDR_tag_provide_from_kv:n} \Arg{key-value list}
% \end{syntax}
% \metatt{deep comma list} has format
% |tag/|\metatt{tag name comma list}.
% Parse the \metatt{key-value list} for full key path matching
% |tag/|\metatt{tag name}|/|\metatt{relative key path},
% then ensure that \cs{c_CDR_tag}|/|\metatt{tag name} is a known full key path.
% For that purpose, we use |\keyval_parse:nnn| with two |\CDR_tag_provide:| helper.
%
% Notice that a tag name should contain no `/'.
% Implementation detail: uses |\l_CDR_a_tl|.
% \end{function}
%    \begin{MacroCode}[OK]
\regex_const:Nn \c_CDR_engine_regex { ^[^/]+\sengine\soptions$ } \use_none:n { $ }
\cs_new_protected_nopar:Npn \CDR_tag_provide:n #1 {
\CDR@Debug { \string\CDR_tag_provide:n~#1 }
  \exp_args:NNf
  \regex_extract_once:NnNTF \c_CDR_provide_regex {
    \CDR_tag_module:n { .. } / #1
  } \l_CDR_seq {
    \tl_set:Nx \l_CDR_a_tl { \seq_item:Nn \l_CDR_seq 3 }
    \exp_args:Nx
    \clist_map_inline:nn {
      \seq_item:Nn \l_CDR_seq 2
    } {
      \CDR_tag_keys_if_exist:nnF { } { ##1 } {
        \CDR_tag_keys_inherit:nn { ##1 } {
          __pygments, __pygments.block,
          default.block, default.code, default, __tags, __engine,
          __fancyvrb, __fancyvrb.block, __fancyvrb.frame,
          __fancyvrb.number, __fancyvrb.all,
        }
        \CDR_tag_keys_define:nn { } {
          ##1 .code:n = \CDR_tag_keys_set:nn { ##1 } { ####1 },
          ##1 .value_required:n = true,
        }
\CDR@Debug{\string\CDR_tag_provide:n~\CDR_tag_module:n {##1} = ...}
      }
      \exp_args:NnV
      \CDR_tag_keys_if_exist:nnF { ##1 } \l_CDR_a_tl {
        \exp_args:NNV
        \regex_match:NnT \c_CDR_engine_regex \l_CDR_a_tl {
          \exp_args:Nnf
          \CDR_tag_keys_define:nn { ##1 } {
            \use:n { \l_CDR_a_tl } .code:n = \CDR_tag_set:n { ####1 },
          }
          \exp_args:Nnf
          \CDR_tag_keys_define:nn { ##1 } {
            \use:n { \l_CDR_a_tl } .value_required:n = true,
          }
\CDR@Debug{\string\CDR_tag_provide:n:~\CDR_tag_module:n { ##1 } / \l_CDR_a_tl = ...}
        }
      }
    }
  } {
    \regex_match:NnTF \c_CDR_engine_regex { #1 } {
      \CDR_tag_keys_define:nn { default } {
        #1 .code:n = \CDR_tag_set:n { ##1 },
        #1 .value_required:n = true,
      }
\CDR@Debug{\string\CDR_tag_provide:n~C:\CDR_tag_module:n { default } / #1 = ...}
    } {
\CDR@Debug{\string\CDR_tag_provide:n\space did~nothing~new.}
    }
  }
}
\cs_new:Npn \CDR_tag_provide:nn #1 #2 {
  \CDR_tag_provide:n { #1 }
}
\cs_new:Npn \CDR_tag_provide_from_kv:n {
  \keyval_parse:nnn {
    \CDR_tag_provide:n
  } {
    \CDR_tag_provide:nn
  }
}
\cs_generate_variant:Nn \CDR_tag_provide_from_kv:n { V }
%    \end{MacroCode}
%
%
% \subsection{\pkg{pygments}}
% These are \pkg{pygments}'s |LatexFormatter| options,
% that are not covered by |__fancyvrb|.
% They are made available at the end user level,
% but may not be relevant when \pkg{pygments} is nor used.
%
% \subsubsection{\texttt{__pygments }
% \pkg{l3keys} module}
%
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __pygments } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed lang=\meta{language name}]^^A
%where \metatt{language name} is recognized by \pkg{pygments}, including a void string,
%    \begin{MacroCode}[OK]
  lang .code:n = \CDR_tag_set:,
  lang .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed pygments{[=true$\vert$false]}]^^A
% whether \pkg{pygments} should be used for syntax coloring.
% Initially |true| if \pkg{pygments} is available,
% |false| otherwise.
%    \begin{MacroCode}[OK]
  pygments .code:n = \CDR_tag_boolean_set:x { #1 },
  pygments .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed style=\meta{style name}]^^A
%where \metatt{style name} is recognized by \pkg{pygments}, including a void string,
%    \begin{MacroCode}[OK]
  style .code:n = \CDR_tag_set:,
  style .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed commandprefix=\meta{text}]^^A
% The \LaTeX{} commands used to produce colored output are constructed
%        using this prefix and some letters.
% Initially |Py|.
%    \begin{MacroCode}[OK]
  commandprefix .code:n = \CDR_tag_set:,
  commandprefix .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed mathescape{[=true$\vert$false]}]^^A
% If set to |true|, enables \LaTeX{} math mode escape in comments. That
%        is, |$...$| inside a comment will trigger math mode.
% Initially |false|.
%    \begin{MacroCode}[OK]
  mathescape .code:n = \CDR_tag_boolean_set:x { #1 },
  mathescape .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed escapeinside=\meta{before}\meta{after}]^^A
% If set to a string of length 2, enables escaping to \LaTeX{}. Text
%        delimited by these 2 characters is read as \LaTeX{} code and
%        typeset accordingly. It has no effect in string literals. It has
%        no effect in comments if |texcomments| or |mathescape| is
%        set.
% Initially empty.
%    \begin{MacroCode}[OK]
  escapeinside .code:n = \CDR_tag_set:,
  escapeinside .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% Initializer.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    lang = tex,
    pygments = \CDR_has_pygments:TF { true } { false },
    style = default,
    commandprefix = PY,
    mathescape = false,
    escapeinside = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __pygments } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__pygments.block} \pkg{l3keys} module}
%
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __pygments.block } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed texcomments{[=true$\vert$false]}]^^A
% If set to |true|, enables \LaTeX{} comment lines.  That is, \LaTeX{} markup
%        in comment tokens is not escaped so that \LaTeX{} can render it.
% Initially |false|.
%    \begin{MacroCode}[OK]
  texcomments .code:n = \CDR_tag_boolean_set:x { #1 },
  texcomments .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% Initializer.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    texcomments = false,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __pygments.block } { __initialize }
}
%    \end{MacroCode}
%
% \subsection{Specifc to \pkg{coder}}
%
% \subsubsection{\texttt{default} \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { default } {
%    \end{MacroCode}
% Keys are:
% \begin{description}
% \itemtt[\CDRCheckRed format=\meta{format commands}]^^A
% the format used to display the code (mainly font, size and color),
% after the font has been selected.
% Initially empty.
%    \begin{MacroCode}[OK]
  format .code:n = \CDR_tag_set:,
  format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed cache]^^A
% Set to |true| if \CDRPy{} should use already existing files
% instead of creating new ones.
% Initially true.
%    \begin{MacroCode}[OK]
  cache .code:n = \CDR_tag_boolean_set:x { #1 },
  cache .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed debug]^^A
% Set to |true| if various debugging messages should be printed to the console .
% Initially false.
%    \begin{MacroCode}[OK]
  debug .code:n = \CDR_tag_boolean_set:x { #1 },
  debug .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed post processor=\meta{command}]^^A
% the command for \pkg{pygments} post processor.
% This is a string where every occurrence of ``|%%file%%|'' is replaced by
% the full path of the |*.pyg.tex| file to be post processed
% and then executed as terminal instruction.
% Initially empty.
%    \begin{MacroCode}[OK]
  post~processor .code:n = \CDR_tag_set:,
  post~processor .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen reflabel=\meta{label}]^^A
% define a label to be used with |\pageref|.
% Initially empty.
%    \begin{MacroCode}[OK]
  reflabel .code:n = \CDR_tag_set:, 
  reflabel .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% to initialize storage properly. We cannot use |.initial:n| actions
% because the |\l_keys_path_str| is not set up properly.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    format = ,
    cache = true,
    debug = false,
    post~processor = ,
    reflabel = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
%
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { default } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{default.code} \pkg{l3keys} module}
% Void for the moment.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { default.code } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed mbox{[=true$\vert$false]}]^^A
% When set to |true|, put the argument inside a \LaTeX{} |mbox| to prevent the code chunk to spread over different lines.
% Initially |true|.
%    \begin{MacroCode}[OK]
  mbox .code:n = \CDR_tag_boolean_set:x { #1 },
  mbox .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% to initialize storage properly. We cannot use |.initial:n| actions
% because the |\l_keys_path_str| is not set up properly.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    mbox = true,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
%
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { default.code } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__tags} \pkg{l3keys} module}
% The only purpose is to catch only the |tags| key very early.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __tags } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed tags=\meta{comma list of tag names}]^^A
% to enable/disable the display of the code chunks tags, setup some style, export.
% Initially |empty|.
% to export and display.
%    \begin{MacroCode}
  tags .code:n = {
    \str_set:Nx \l_CDR_str { #1 }
    \str_replace_all:Nnn \l_CDR_str {|} {,}
    \exp_args:NNV
    \clist_set:Nn \l_CDR_clist \l_CDR_str
    \clist_remove_duplicates:N \l_CDR_clist
    \exp_args:NV
    \CDR_tag_set:n \l_CDR_clist
  },
  tags .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed default tags=\meta{comma list of tag names}]^^A
% to enable/disable the display of the code chunks tags, setup some style, export.
% Initially |empty|.
% to export and display.
%    \begin{MacroCode}
  default~tags .code:n = {
    \clist_set:Nx \l_CDR_clist { #1 }
    \clist_remove_duplicates:N \l_CDR_clist
    \exp_args:NV
    \CDR_tag_set:n \l_CDR_clist
  },
  default~tags .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    tags = ,
    default~tags = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __tags } { __initialize }
}
%    \end{MacroCode}
% There is a compagnion module to catch unexpected |tags| key.
% Used for \pkg{\jobname} options when defining engines.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __no_tags } {
  tags .code:n = {
    \PackageError
      { coder }
      { Key~`tags'~is~forbidden~for~engines }
      { See~the~coder~manual }
  }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__engine} \pkg{l3keys} module}
% The only purpose is to catch only the |engine| key very early,
% just after the |tags| key.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __engine } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed engine=\meta{engine name}]^^A
% to specify the engine used to display inline code or blocks.
% Initially |default|.
%    \begin{MacroCode}[OK]
  engine .code:n = \CDR_tag_set:,
  engine .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed default engine options=\meta{default engine options}]^^A
% to specify the corresponding options,
%    \begin{MacroCode}[OK]
  default~engine~options .code:n = \CDR_tag_set:,
  default~engine~options .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed engine options=\meta{engine options}]^^A
% options forwarded to the engine. They are appended to the options
% given with key \metatt{engine name}| engine options|.
% Mainly a convenient user interface shortcut.
%    \begin{MacroCode}[OK]
  engine~options .code:n = \CDR_tag_set:,
  engine~options .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed \meta{engine name} engine options=\meta{engine options}]^^A
% to specify the options
% for the named engine,
% \itemtt[\CDRCheckRed \meta{engine name} options=\meta{\pkg{\jobname} options}]^^A
% to specify the \pkg{\jobname} options that should apply
% when the named engine is selected.
% \itemtt[\CDRCheckRed __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    engine = default,
    default~engine~options = ,
    engine~options = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __engine } { __initialize }
}
%    \end{MacroCode}
%
% There is a compagnion module to catch unexpected |tags| key.
% Used for \pkg{\jobname} options when defining engines.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __no_engine } {
  engine .code:n = {
    \PackageError
      { coder }
      { Key~`engine'~is~forbidden~for~engines }
      { See~the~coder~manual }
  }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{default.block} \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { default.block } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed tags format=\meta{format commands}]^^A
%, where \meta{format} is used
% the format used to display the tag names (mainly font, size and color),
% after it is appended to the |numbers format|.
% Initially empty.
%    \begin{MacroCode}[OK]
  tags~format .code:n = \CDR_tag_set:,
  tags~format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed numbers format=\meta{format commands}]^^A
% the format used to display line numbers (mainly font, size and color).
%    \begin{MacroCode}[OK]
  numbers~format .code:n = \CDR_tag_set:,
  numbers~format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed show tags={[=true$\vert$false]}]^^A
% whether tags should be displayed.
%    \begin{MacroCode}[OK]
  show~tags .choices:nn =
    { none, left, right, same, mirror, dry }
    { \CDR_tag_choices_set: },
  show~tags .default:n = same,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed only top{[=true$\vert$false]}]^^A
% to avoid chunk tags repetitions, if on the same page,
% two consecutive code chunks have the same tag names, the second names are not displayed.
%    \begin{MacroCode}[OK]
  only~top .code:n = \CDR_tag_boolean_set:x { #1 },
  only~top .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed use margin{[=true$\vert$false]}]^^A
% to use the magin to display line numbers
% and tag names, or not, UNUSED
%    \begin{MacroCode}[OK]
  use~margin .code:n = \CDR_tag_boolean_set:x { #1 },
  use~margin .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    show~tags = same,
    only~top = true,
    use~margin = true,
    numbers~format = {
      \sffamily
      \scriptsize
      \color{gray}
    },
    tags~format = {
      \bfseries
    },
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { default.block } { __initialize }
}
%    \end{MacroCode}
%
% \subsection{\pkg{fancyvrb}}
% These are \pkg{fancyvrb} options verbatim.
% The \pkg{fancyvrb} manual has more details, only some parts are reproduced hereafter.
% All of these options may not be relevant for all situations.
% Some of them make no sense in |code| mode, whereas others may not be
% compatible with the display engine.
%
% \subsubsection{\texttt{__fancyvrb } \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __fancyvrb } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed formatcom=\meta{command}]^^A
% execute before printing verbatim text.
% Initially empty.
%    \begin{MacroCode}[OK]
  formatcom .code:n = \CDR_tag_set:,
  formatcom .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed fontfamily=\meta{family name}]^^A
% font family to use. |tt|, |courier| and |helvetica| are pre-defined.
% Initially \texttt{tt}.
%    \begin{MacroCode}[OK]
  fontfamily .code:n = \CDR_tag_set:,
  fontfamily .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed fontsize=\meta{font size}]^^A
% size of the font to use. If you use the \pkg{relsize} package as well,
% you can require a change of the size proportional to the current one
% (for instance: |fontsize=\relsize{-2}|).
% Initially \texttt{auto}: the same as the current font.
%    \begin{MacroCode}[OK]
  fontsize .code:n = \CDR_tag_set:,
  fontsize .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed fontshape=\meta{font shape}]^^A
% font shape to use. Initially \texttt{auto}: the same as the current font.
%    \begin{MacroCode}[OK]
  fontshape .code:n = \CDR_tag_set:,
  fontshape .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed fontseries=\meta{series name}]^^A
% \LaTeX{} font ‘series’ to use.
% Initially \texttt{auto}: the same as the current font.
%    \begin{MacroCode}[OK]
  fontseries .code:n = \CDR_tag_set:,
  fontseries .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed showspaces{[=true$\vert$false]}]^^A
% print a special character representing each space.
% Initially |false|: spaces not shown.
%    \begin{MacroCode}[OK]
  showspaces .code:n = \CDR_tag_boolean_set:x { #1 },
  showspaces .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed showtabs=true$\vert$false]^^A
% explicitly show tab characters.
% Initially |false|: tab characters not shown.
%    \begin{MacroCode}[OK]
  showtabs .code:n = \CDR_tag_boolean_set:x { #1 },
  showtabs .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed obeytabs=true$\vert$false]^^A
% position characters according to the tabs.
% Initially false: tab characters are added to the current position.
%    \begin{MacroCode}[OK]
  obeytabs .code:n = \CDR_tag_boolean_set:x { #1 },
  obeytabs .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed tabsize=\meta{integer}]^^A
% number of spaces given by a tab character,
% Initially 2 (8 for \pkg{fancyvrb}).
%    \begin{MacroCode}[OK]
  tabsize .code:n = \CDR_tag_set:,
  tabsize .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed defineactive=\meta{macro}]^^A
% to define the effect of active characters.
% This allows to do some devious tricks, see the \pkg{fancyvrb} package.
% Initially empty.
%    \begin{MacroCode}[OK]
  defineactive .code:n = \CDR_tag_set:, 
  defineactive .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    formatcom = ,
    fontfamily = tt,
    fontsize = auto,
    fontseries = auto,
    fontshape = auto,
    showspaces = false,
    showtabs = false,
    obeytabs = false,
    tabsize = 2,
    defineactive = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __fancyvrb } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__fancyvrb.frame} \pkg{l3keys} module}
%
% Block specific options, frame related.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __fancyvrb.frame } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed frame=none$\vert$leftline$\vert$topline$\vert$bottomline$\vert$lines$\vert$single]^^A
% type of frame around the verbatim environment.
% With \texttt{leftline} and \texttt{single} modes, a space of a length given
% by the \LaTeX{} |\fboxsep| macro is added between the left vertical line
% and the text. Initially \texttt{none}: no frame.
%    \begin{MacroCode}[OK]
  frame .choices:nn =
    { none, leftline, topline, bottomline, lines, single }
    { \CDR_tag_choices_set: },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed framerule=\meta{dimension}]^^A
% width of the rule of the frame if any.
% Initially 0.4pt.
%    \begin{MacroCode}[OK]
  framerule .code:n = \CDR_tag_set:,
  framerule .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed framesep=\meta{dimension}]^^A
% width of the gap between the frame (if any) and the text.
% Initially |\fboxsep|.
%    \begin{MacroCode}[OK]
  framesep .code:n = \CDR_tag_set:,
  framesep .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed rulecolor=\meta{color command}]^^A
% color of the frame rule, expressed in the standard \LaTeX{} way.
% Initially black.
%    \begin{MacroCode}[OK]
  rulecolor .code:n = \CDR_tag_set:,
  rulecolor .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed rulecolor=\meta{color command}]^^A
% color used to fill the space between the frame and the text
% (its thickness is given by |framesep|).
% Initially empty.
%    \begin{MacroCode}[OK]
  fillcolor .code:n = \CDR_tag_set:,
  fillcolor .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed labelposition=none$\vert$topline$\vert$bottomline$\vert$all]^^A
% position where to print the label(s) when defined.
% When options happen to be contradictory,
% like |frame=topline| and  |labelposition=bottomline|,
% nothing is displayed.
% Initially |none| when no labels are defined,
% |topline| for one label and |all| otherwise.
%    \begin{MacroCode}[OK]
  labelposition .choices:nn =
    { none, topline, bottomline, all }
    { \CDR_tag_choices_set: },
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    frame = none,
    framerule = 0.4pt,
    framesep = \fboxsep,
    rulecolor = black,
    fillcolor = ,
    labelposition = none,% auto?
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __fancyvrb.frame } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__fancyvrb.block} \pkg{l3keys} module}
%
% Block specific options, except numbering.
%    \begin{MacroCode}[OK]
\regex_const:Nn \c_CDR_int_regex { ^(+|-)?\d+$ } \use_none:n { $ }
\CDR_tag_keys_define:nn { __fancyvrb.block } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed commentchar=\meta{character}]^^A
% lines starting with this character are ignored.
% Initially empty.
%    \begin{MacroCode}[OK]
  commentchar .code:n = \CDR_tag_set:,
  commentchar .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed gobble=\meta{integer}]^^A
% number of characters to suppress
% at the beginning of each line (from 0 to 9),
% mainly useful when environments are indented.
% Only |block| mode.
%    \begin{MacroCode}[OK]
  gobble .choices:nn = {
    0,1,2,3,4,5,6,7,8,9
  } {
    \CDR_tag_choices_set:
  },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed baselinestretch=auto$\vert$\meta{dimension}]^^A
% value to give to the usual \cs{baselinestretch} \LaTeX{} parameter.
% Initially \texttt{auto}: its current value just before the verbatim command.
%    \begin{MacroCode}[OK]
  baselinestretch .code:n = \CDR_tag_set:, 
  baselinestretch .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckProhibited commandchars=\meta{three characters}]^^A
% characters which define the character which starts a macro and marks the
% beginning and end of a group; thus lets us introduce escape sequences in
% verbatim code. Of course, it is better to choose special characters which
% are not used in the verbatim text.
% Private to \pkg{coder}, unavailable to users.
% \itemtt[\CDRCheckRed xleftmargin=\meta{dimension}]^^A
% indentation to add at the start of each line.
% Initially |0pt|: no left margin.
%    \begin{MacroCode}[OK]
  xleftmargin .code:n = \CDR_tag_set:, 
  xleftmargin .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed xrightmargin=\meta{dimension}]^^A
% right margin to add after each line.
% Initially |0pt|: no right margin.
%    \begin{MacroCode}[OK]
  xrightmargin .code:n = \CDR_tag_set:, 
  xrightmargin .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed resetmargins{[=true$\vert$false]}]^^A
% reset the left margin, which is useful if we are inside other indented environments.
% Initially |true|.
%    \begin{MacroCode}[OK]
  resetmargins .code:n = \CDR_tag_boolean_set:x { #1 }, 
  resetmargins .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed hfuzz=\meta{dimension}]^^A
% value to give to the \TeX{} |\hfuzz| dimension for text to format.
% This can be used to avoid seeing some unimportant overfull box messages.
% Initially 2pt.
%    \begin{MacroCode}[OK]
  hfuzz .code:n = \CDR_tag_set:, 
  hfuzz .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed vspace=\metatt{dimension}]^^A
% the amount of vertical space added to |\parskip| before and after blocks.
% Initially |\topsep|.
%    \begin{MacroCode}[OK]
  vspace .code:n = \CDR_tag_set:,
  vspace .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed samepage{[=true$\vert$false]}]^^A
% in very special circumstances, we may want to make sure that a verbatim environment
% is not broken, even if it does not fit on the current page.
% To avoid a page break, we can set the samepage parameter to |true|.
% Initially |false|.
%    \begin{MacroCode}[OK]
  samepage .code:n = \CDR_tag_boolean_set:x { #1 },
  samepage .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed label={\{[\meta{top string}]^^A
%\meta{string}\}}]
% label(s) to print on top, bottom or both, frame lines.
% If the label(s) contains special characters, comma or equal sign,
% it must be placed inside a group.
% If an optional \metatt{top string} is given between square brackets,
% it will be used for the top line and \metatt{string} for the bottom line.
% Otherwise, \metatt{string} is used for both the top or bottom lines.
% Label(s) are printed only if the \texttt{frame} parameter is one of
% \texttt{topline}, \texttt{bottomline}, \texttt{lines} or \texttt{single}.
% Initially empty: no label.
%    \begin{MacroCode}[OK]
  label .code:n = \CDR_tag_set:,
  label .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    commentchar = ,
    gobble = 0,
    baselinestretch = auto,
    resetmargins = true,
    xleftmargin = 0pt,
    xrightmargin = 0pt,
    hfuzz = 2pt,
    vspace = \topset,
    samepage = false,
    label = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __fancyvrb.block } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__fancyvrb.number} \pkg{l3keys} module}
% Block line numbering.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __fancyvrb.number } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed numbers=none$\vert$left$\vert$right]^^A
% numbering of the verbatim lines.
% If requested, this numbering is done outside the verbatim environment.
% Initially none: no numbering.
% 
%    \begin{MacroCode}[OK]
  numbers .choices:nn =
    { none, left, right }
    { \CDR_tag_choices_set: },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed numbersep=\meta{dimension}]^^A
% gap between numbers and verbatim lines.
% Initially 12pt.
%    \begin{MacroCode}[OK]
  numbersep .code:n = \CDR_tag_set:,
  numbersep .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed firstnumber=auto$\vert$last$\vert$\meta{integer}]^^A
% number of the first line.
% |last| means that the numbering is continued from the previous verbatim environment.
% If an integer is given, its value will be used to start the numbering.
% Initially \texttt{auto}: numbering starts from 1.
%    \begin{MacroCode}[OK]
  firstnumber .code:n = {
    \regex_match:NnTF \c_CDR_int_regex { #1 } {
      \CDR_tag_set:
    } {
      \str_case:nnF { #1 } {
        { auto } { \CDR_tag_set: }
        { last } { \CDR_tag_set: }
      } {
        \PackageWarning
          { CDR }
          { Value~`#1'~not~in~auto,~last. }
      }
    }
  },
  firstnumber .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed stepnumber=\meta{integer}]^^A
% interval at which line numbers are printed.
% Initially 1: all lines are numbered.
%    \begin{MacroCode}[OK]
  stepnumber .code:n = \CDR_tag_set:,
  stepnumber .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed numberblanklines{[=true$\vert$false]}]^^A
% to number or not the white lines (really empty or containing blank characters only).
% Initially |true|: all lines are numbered.
%    \begin{MacroCode}[OK]
  numberblanklines .code:n = \CDR_tag_boolean_set:x { #1 },
  numberblanklines .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed firstline=\meta{integer}$\vert$\meta{regex}]^^A
% first line to print.
% Initially empty: all lines from the first are printed.
%    \begin{MacroCode}[OK]
  firstline .code:n = {
    \regex_match:NnTF \c_CDR_int_regex { #1 } {
      \CDR_tag_set:
    } {
      \tl_if_empty:nTF { #1 } {
        \CDR_tag_set:
      } {
        \CDR_tag_set:n { \unexpanded { #1 } }
      }
    }
  },
  firstline .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed lastline=\meta{integer}$\vert$\meta{regex}]^^A
% last line to print.
% Initially empty: all lines until the last one are printed.
%    \begin{MacroCode}[OK]
  lastline .code:n = {
    \regex_match:NnTF \c_CDR_int_regex { #1 } {
      \CDR_tag_set:n { #1 }
    } {
      \CDR_tag_set:n { \unexpanded { #1 } }
    }
  },
  lastline .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    numbers = left,
    numbersep = 1ex,
    firstnumber = auto,
    stepnumber = 1,
    numberblanklines = true,
    firstline = ,
    lastline = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __fancyvrb.number } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__fancyvrb.all }
% \pkg{l3keys} module}
% Options available when \pkg{pygments} is not used.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __fancyvrb.all } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed commandchars=\meta{three characters}]^^A
% characters that define the character that starts a macro and marks the beginning
% and end of a group; allows to introduce escape sequences in the verbatim code.
% Of course, it is better to choose special characters that are not used in
% the verbatim text!
% Initially |none|.
% Ignored in \pkg{pygments} mode.
%    \begin{MacroCode}[OK]
  commandchars .code:n = \CDR_tag_set:, 
  commandchars .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed codes=\meta{macro}]^^A
% to specify catcode changes.
% For instance, this allows us to include formatted mathematics in verbatim text.
% Initially empty.
% Ignored in \pkg{pygments} mode.
%    \begin{MacroCode}[OK]
  codes .code:n = \CDR_tag_set:, 
  codes .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    commandchars = ,
    codes = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __fancyvrb.all } { __initialize }
}
%    \end{MacroCode}
%
% \section{\cs{CDRSet}}
% \begin{function}{\CDRSet}
% \begin{syntax}
% \cs{CDRSet} \Arg{key[=value] list}
% \cs{CDRSet} \{only description=true, font family=tt\}
% \cs{CDRSet} \{tag/default.code/font family=sf\}
% \end{syntax}
% To set up the package. This is executed at least once at the end of the preamble.
% The unique mandatory argument of \cs{CDRSet} is a
% list of \texttt{\meta{key}[=\meta{value}]} items defined by
% the \texttt{CDR@Set} \pkg{l3keys} module.
% \end{function}
%
% \subsection{\texttt{CDR@Set} \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\keys_define:nn { CDR@Set } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed only description]^^A
% to typeset only the description
% section and ignore the implementation section.
%    \begin{MacroCode}[OK]
  only~description .choices:nn = { false, true, {} } {
    \int_compare:nNnTF \l_keys_choice_int = 1 {
      \prg_set_conditional:Nnn \CDR_if_only_description: { p, T, F, TF } { \prg_return_true: }
    } {
      \prg_set_conditional:Nnn \CDR_if_only_description: { p, T, F, TF } { \prg_return_false: }
    }
  },
  only~description .initial:n = false,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed python path]^^A
% if automatic processing is not available, manually setting the path
% to the |python| utility is required. Giving a void path forces an automatic
% guess using |which|.
%    \begin{MacroCode}[OK]
  python~path .code:n = {
    \str_set:Nn \l_CDR_str { #1 }
    \exp_args:Nx \CDR_pygments_setup:n {
      \lua_now:n { CDR:set_python_path('l_CDR_str') }
    }
  },
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%
% \subsection{Branching}
% \begin{function}[pTF]{\CDR_if_only_description:}
% \begin{syntax}
% \cs{CDR_if_only_description:TF} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when only the description is expected,
% \metatt{false code} otherwise.
% \emph{Implementation detail}: the functions are defined as part
% of the \texttt{CDR@Set} \pkg{l3keys} module.
% \end{function}
%
% \subsection{Implementation}
%
% \begin{function}{\CDRBlock_preflight:n}
% \begin{syntax}
% \cs{CDR_set_preflight:n} \Arg{CDR@Set kv list}
% \end{syntax}
% This is a prefligh hook intended for testing.
% The default implementation does nothing.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_set_preflight:n #1 { }
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRSet { m } {
\CDR@Debug{\string\CDRSet}
  \CDR_set_preflight:n { #1 }
  \keys_set_known:nnnN { CDR@Set } { #1 } { CDR@Set } \l_CDR_kv_clist
  \CDR_tag_expand_kv:N \l_CDR_kv_clist
  \clist_map_inline:nn {
    __pygments, __pygments.block,
    __tags, __engine, default.block, default.code, default,
    __fancyvrb, __fancyvrb.frame, __fancyvrb.block, __fancyvrb.number, __fancyvrb.all
  } {
    \CDR_tag_keys_set_known:nN { ##1 } \l_CDR_kv_clist
\CDR@Debug{\string\CDRSet.1:##1/\l_CDR_kv_clist/ }
  }
  \CDR_tag_keys_set_known:nN { .. } \l_CDR_kv_clist
\CDR@Debug{\string\CDRSet.2:\CDR_tag_module:n { .. }+\l_CDR_kv_clist/ }
  \CDR_tag_provide_from_kv:V \l_CDR_kv_clist
\CDR@Debug{\string\CDRSet.2a:\CDR_tag_module:n { .. }+\l_CDR_kv_clist/ }  
  \CDR_tag_keys_set_known:nN { .. } \l_CDR_kv_clist
\CDR@Debug{\string\CDRSet.3:\CDR_tag_module:n { .. }+\l_CDR_kv_clist/ }
  \CDR_tag_keys_set:nV { default } \l_CDR_kv_clist
\CDR@Debug{\string\CDRSet.4:\CDR_tag_module:n { default } /\l_CDR_kv_clist/ }
  \keys_define:nn { CDR@Set@tags } {
    tags .code:n = {
      \clist_set:Nx \g_CDR_tags_clist { ##1 }
      \clist_remove_duplicates:N \g_CDR_tags_clist
    },
  }
  \keys_set_known:nn { CDR@Set@tags } { #1 }
  \ignorespaces
}
%    \end{MacroCode}
%
%
% \section{\cs{CDRExport}}
% \begin{function}{\CDRExport}
% \begin{syntax}
% \cs{CDRExport} \Arg{key[=value] controls}
% \end{syntax}
% The \texttt{\meta{key}[=\meta{value}]} controls are defined by
% \texttt{CDR@Export} \pkg{l3keys} module.
% \end{function}
%
% \subsection{Storage}
%
% \begin{function}[EXP]{\CDR_export_get_path:cc}
% \begin{syntax}
% \cs{CDR_tag_export_path:cc} \Arg{file name} \Arg{relative key path}
% \end{syntax}
% Internal: return a unique key based on the arguments.
% Used to store and retrieve values.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_export_get_path:cc #1 #2 {
  CDR @ export @ get @ #1 / #2
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_export_set:ccn, \CDR_export_set:Vcn, \CDR_export_set:VcV}
% \begin{syntax}
% \cs{CDR_export_set:ccn} \Arg{file name} \Arg{relative key path} \Arg{value}
% \end{syntax}
% Store \metatt{value}, which is further retrieved with the instruction
% |\CDR_get_get:cc {|\metatt{file name}|}| \linebreak[3]|{|\metatt{relative key path}|}|.
% All the affectations are made at the global \TeX{} group level.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_export_gset:ccn #1 #2 #3 {
  \cs_gset:cpn { \CDR_export_get_path:cc { #1 } { #2 } } { \exp_stop_f: #3 }
}
\cs_new_protected:Npn \CDR_export_gset:Vcn #1 {
  \exp_args:NV
  \CDR_export_gset:ccn { #1 }
}
\cs_new_protected:Npn \CDR_export_gset:VcV #1 #2 #3 {
  \exp_args:NnV
  \use:n {
    \exp_args:NV \CDR_export_gset:ccn #1 { #2 }
  } #3
}
%    \end{MacroCode}
%
% \begin{function}[TF,EXP]{\CDR_export_if_exist:cc}
% \begin{syntax}
% \cs{CDR_export_if_exist:ccTF} \Arg{file name} \meta{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% If the \metatt{relative key path} is known within \metatt{file name},
% the \metatt{true code} is executed,
% otherwise, the \metatt{false code} is executed.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_export_if_exist:cc { p, T, F, TF } {
  \cs_if_exist:cTF { \CDR_export_get_path:cc { #1 } { #2 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP]{\CDR_export_get:cc}
% \begin{syntax}
% \cs{CDR_export_get:cc} \Arg{file name} \Arg{relative key path}
% \end{syntax}
% The property value stored for \metatt{file name}
% and \metatt{relative key path}.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_export_get:cc #1 #2 {
  \CDR_export_if_exist:ccT { #1 } { #2 } {
    \use:c { \CDR_export_get_path:cc { #1 } { #2 } }
  }
}
%    \end{MacroCode}
%
% \begin{function}[TF]{\CDR_export_get:ccN}
% \begin{syntax}
% \cs{CDR_export_get:ccNTF} \Arg{file name} \Arg{relative key path}
% \meta{tl var} \Arg{true code} \Arg{false code}
% \end{syntax}
% Get the property value stored for \metatt{file name}
% and \metatt{relative key path}, copy it to \metatt{tl var}.
% Execute \metatt{true code} on success, \metatt{false code} otherwise.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_protected_conditional:Nnn \CDR_export_get:ccN { T, F, TF } {
  \CDR_export_if_exist:ccTF { #1 } { #2 } {
    \tl_set:Nf #3 { \CDR_export_get:cc { #1 } { #2 } }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \subsection{Storage}
%
% \begin{variable}{\g_CDR_export_seq}
% Global list of all the files to be exported.
%    \begin{MacroCode}[OK]
\seq_new:N \g_CDR_export_seq
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_file_tl}
% Store the file name used for exportation, used as key in the above property list.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_file_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\l_CDR_export_prop}
% Used by \texttt{CDR@Export} \pkg{l3keys} module to temporarily store properties.
%    \begin{MacroCode}[OK]
\prop_new:N \l_CDR_export_prop
%    \end{MacroCode}
% \end{variable}
%
% \subsection{\texttt{CDR@Export} \pkg{l3keys} module}
% No initial value is given for every key.
% An |__initialize| action will set the storage with proper initial values.
%    \begin{MacroCode}[OK]
\keys_define:nn { CDR@Export } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed file=\meta{name}]^^A
% the output file name, must be provided otherwise an error is raised.
%    \begin{MacroCode}[OK]
  file .tl_set:N = \l_CDR_file_tl,
  file .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed tags=\meta{tags comma list}]^^A
% the list of tags. No exportation when this list is void.
% Initially empty.
%    \begin{MacroCode}[OK]
  tags .code:n = {
    \clist_set:Nx \l_CDR_clist { #1 }
    \clist_remove_duplicates:N \l_CDR_clist
    \prop_put:NVV \l_CDR_export_prop \l_keys_key_str \l_CDR_clist
  },
  tags .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed lang]^^A
% one of the languages \pkg{pygments} is aware of.
% Initially |tex|.
%    \begin{MacroCode}[OK]
  lang .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  lang .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed preamble=\meta{preamble content}]^^A
% the added preamble.
% Initially empty.
%    \begin{MacroCode}[OK]
  preamble .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  preamble .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed preamble file=\meta{preamble file path}]^^A
% when provided, the preamble is the content of the file at the given path,
% overriding the |preamble| option. |escapeinside| applies.
% Initially empty.
%    \begin{MacroCode}[OK]
  preamble~file .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  preamble~file .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed postamble=\meta{postamble content}]^^A
% the added postamble.
% Initially empty.
%    \begin{MacroCode}[OK]
  postamble .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  postamble .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed postamble file=\meta{postamble file path}]^^A
% when provided, the postamble is the content of the file at the given path,
% overriding the |postamble| option. |escapeinside| applies.
% Initially empty.
%    \begin{MacroCode}[OK]
  postamble~file .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  postamble~file .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed escapeinside=\meta{2 delimiters}]^^A
% When provided, the text of the preamble or the postamble enclosed
% between the delimiters is interpreted as \LaTeX{} instructions.
% Quite any unicode character is permitted, except the caret |^|.
% Useful to insert the current date.
% Initially empty.
%    \begin{MacroCode}[OK]
  escapeinside .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  escapeinside .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed raw{[=true$\vert$false]}]^^A
% true to remove any additional material, false otherwise.
% Initially |false|.
%    \begin{MacroCode}[OK]
  raw .choices:nn = { false, true, {} } {
    \prop_put:NVx \l_CDR_export_prop \l_keys_key_str {
      \int_compare:nNnTF
        \l_keys_choice_int = 1 { false } { true }
    }
  },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed once{[=true$\vert$false]}]^^A
% true to remove any additional material, false otherwise.
% Initially |true|.
%    \begin{MacroCode}[OK]
  once .choices:nn = { false, true, {} } {
    \prop_put:NVx \l_CDR_export_prop \l_keys_key_str {
      \int_compare:nNnTF
        \l_keys_choice_int = 1 { false } { true }
    }
  },
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Properly initialize the local property storage.
%    \begin{MacroCode}[OK]
  __initialize .code:n = \prop_clear:N #1,
  __initialize .default:n = \l_CDR_export_prop,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
% 
% \subsection{Implementation}
% \begin{variable}{\CDRPercent, \CDRHash}
% To include a |%| or a |#| character in the preamble or the postamble below.
% Must be escaped.
% \end{variable}
%    \begin{MacroCode}[OK]
\str_set_eq:NN \CDRPercent \c_percent_str
\str_set_eq:NN \CDRHash \c_hash_str
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\str_set_eq:NN \CDRPercent \c_percent_str
\str_set_eq:NN \CDRHash \c_hash_str
\NewDocumentCommand \CDRExport { m } {
  \keys_set:nn { CDR@Export } { __initialize }
  \keys_set:nn { CDR@Export } { #1 }
  \tl_if_empty:NTF \l_CDR_file_tl {
    \PackageWarning
      { coder }
      { Missing~export~key~`file' }
  } {
    \CDR_export_gset:VcV \l_CDR_file_tl { file } \l_CDR_file_tl
    \prop_map_inline:Nn \l_CDR_export_prop {
      \CDR_export_gset:Vcn \l_CDR_file_tl { ##1 } { ##2 }
    }
%    \end{MacroCode}
% The list of tags must not be empty, raise an error otherwise.
% Records the list in |\g_CDR_tags_clist|, it will be the default list
% of forthcoming code blocks if the |default tags| is not set.
%    \begin{MacroCode}[OK]
    \prop_get:NnNTF \l_CDR_export_prop { tags } \l_CDR_clist {
      \clist_set_eq:NN \g_CDR_tags_clist \l_CDR_clist
      \clist_if_empty:NF \l_CDR_clist {
        \clist_remove_duplicates:N \g_CDR_tags_clist
        \clist_put_left:NV \g_CDR_all_tags_clist \l_CDR_clist
        \clist_remove_duplicates:N \g_CDR_all_tags_clist
%    \end{MacroCode}
% If a |lang| is given, forwards the declaration
% to all the code chunks tagged within |\g_CDR_tags_clist|.
%    \begin{MacroCode}[OK]
        \CDR_export_get:ccNT { \l_CDR_file_tl } { lang } \l_CDR_a_tl {
          \clist_map_inline:Nn \g_CDR_tags_clist {
            \CDR_tag_set:ccV { ##1 } { lang } \l_CDR_a_tl
          }
        }
      }
      \seq_put_left:NV \g_CDR_export_seq \l_CDR_file_tl
      \seq_remove_duplicates:N \g_CDR_export_seq
    } {
      \CDR_export_if_exist:ccF { \l_CDR_file_tl } { tags }  {
        \PackageWarning
          { coder }
          { Missing~export~key~`tags' }
      }
    }
  }
  \ignorespaces
}
%    \end{MacroCode}
% \begin{variable}{\l_CDR_export_tl}
% Scratch variable.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_export_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDR_rescan_regex_split:NNn}
% \begin{syntax}
% \cs{CDR_escapeinside:Nn} \meta{regex variable} \meta{tl variable} \Arg{argument}
% \end{syntax}
% Escape the content of \metatt{argumen} with
% respect to \metatt{regex variable} and put the result in \meta{tl variable}.
% Implementation detail: uses |\l_CDR_a_tl| and |\l_CDR_seq|.
% \end{function}
%    \begin{MacroCode}
\cs_new_protected:Npn \CDR_rescan_regex_split:NNn #1 #2 #3 {
  \regex_split:NnN #1 { #3 } \l_CDR_seq
  \seq_pop_left:NN \l_CDR_seq #2
  \bool_until_do:nn { \seq_if_empty_p:N \l_CDR_seq } {
    \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl
    \exp_args:NNnV
    \tl_set_rescan:Nnn \l_CDR_a_tl {} \l_CDR_a_tl
    \tl_put_right:NV #2 \l_CDR_a_tl
    \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl
    \tl_put_right:NV #2 \l_CDR_a_tl
  }
}
%    \end{MacroCode}
%
% Files are created at the end of the typesetting process.
% We define a separate macro to be used for testing purposes.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_export_complete: {
\CDR@Debug{\string\CDR_export_complete:}
  \prg_set_conditional:Nnn \CDR_if_amblefile:nNn { T, F, TF } {
    \CDR_export_get:ccNTF { ##1 } { ##3~file } ##2 {
      \tl_if_empty:NTF ##2 {
\CDR@Debug{\string\CDR_export_complete:~empty~file~option}
        \prg_return_false:
      } {
        \exp_args:NV
        \file_if_exist:nTF ##2 {
          \prg_return_true:      
        } {
\CDR@Debug{\string\CDR_export_complete:~no~file~at~##2}
          \prg_return_false:
        }
      }
    } {
\CDR@Debug{\string\CDR_export_complete:~no~option~'##1->##3~file' }
      \prg_return_false:
    }
  }
  \prg_set_conditional:Nnn \CDR_export_if_tags:nN { T, F, TF } {
    \CDR_export_get:ccNTF { ##1 } { tags } ##2 {
      \tl_if_empty:NTF ##2 {
        \prg_return_false:
      } {
        \prg_return_true:
      }
    } {
      \prg_return_false:
    }
  }
  \seq_map_inline:Nn \g_CDR_export_seq {
\CDR@Debug{\string\CDR_export_complete:~FILE~##1}
    \CDR_export_if_tags:nNTF { ##1 } \l_CDR_clist {
      \str_set:Nx \l_CDR_str { ##1 }
      \lua_now:n { CDR:export_file('l_CDR_str') }
      \lua_now:n {
        CDR:export_file_info('tags','l_CDR_clist')
      }
\CDR@Debug{\string\CDR_export_complete:~TAGS~\l_CDR_clist}
      \clist_map_inline:nn { raw, once, } {
        \CDR_export_get:ccNTF { ##1 } { ####1 } \l_CDR_export_tl {
          \lua_now:n {
            CDR:export_file_info('####1','l_CDR_export_tl')
          }
        } {
          \CDR@Debug{\string\CDR_export_complete:~no~####1}
        }
      }
      \tl_clear:N \l_CDR_regex
      \CDR_export_get:ccNT { ##1 } { escapeinside } \l_CDR_a_tl {
        \int_compare:nNnTF { \tl_count:N \l_CDR_a_tl } = 1 {
          \regex_set:Nx \l_CDR_regex {
            [ \tl_item:Nn \l_CDR_a_tl 1 ]
            ( .*? )
            [ \tl_item:Nn \l_CDR_a_tl 1 ]
          }
        } {
          \int_compare:nNnT { \tl_count:N \l_CDR_a_tl } > 1 {
            \regex_set:Nx \l_CDR_regex {
              [ \tl_item:Nn \l_CDR_a_tl 1 ]
              ( .*? )
              [ \tl_item:Nn \l_CDR_a_tl 2 ]
            }
          }
        }
      }
%    \end{MacroCode}
% Read preamble and postamble from file if any.
%    \begin{MacroCode}[OK]
      \clist_map_inline:nn { preamble, postamble, } {
\CDR@Debug{\string\CDR_export_complete:~####1}
        \CDR_if_amblefile:nNnTF { ##1 } \l_CDR_a_tl { ####1 } {
\CDR@Debug{\string\CDR_export_complete:~file: \l_CDR_a_tl}
          \exp_args:NNV
          \ior_open:Nn \l_CDR_ior \l_CDR_a_tl
          \tl_if_empty:NTF \l_CDR_regex {
            \ior_str_map_inline:Nn \l_CDR_ior {
              \l_set:Nn \l_CDR_export_tl { ########1 }
              \lua_now:n {
                CDR:append_file_info('####1','l_CDR_export_tl')
              }
            }
          } {
            \ior_str_map_inline:Nn \l_CDR_ior {
              \CDR_rescan_regex_split:NNn
                \l_CDR_regex
                \l_CDR_export_tl
                { ########1 }
              \tl_set:Nx \l_CDR_export_tl { \l_CDR_export_tl }
              \lua_now:n {
                CDR:append_file_info('####1','l_CDR_export_tl')
              }
            }
          }
          \ior_close:N \l_CDR_ior
        } {
\CDR@Debug{\string\CDR_export_complete:~no~file}
          \tl_if_empty:NTF \l_CDR_regex {
            \CDR_export_get:ccNTF { ##1 } { ####1 } \l_CDR_export_tl {
              \lua_now:n {
                CDR:append_file_info('####1','l_CDR_export_tl')
              }
            } {
\CDR@Debug{\string\CDR_export_complete:~no~'##1'->'####1' }
            }
          } {
            \CDR_export_get:ccNTF { ##1 } { ####1 } \l_CDR_a_tl {
              \exp_args:NNV
              \regex_split:NnN \l_CDR_regex \l_CDR_a_tl \l_CDR_seq
              \seq_pop_left:NN \l_CDR_seq \l_CDR_export_tl
              \bool_until_do:nn { \seq_if_empty_p:N \l_CDR_seq } {
                \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl
                \tl_put_right:Nx \l_CDR_export_tl { \l_CDR_a_tl }
                \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl
                \tl_put_right:NV \l_CDR_export_tl \l_CDR_a_tl
              }
              \lua_now:n {
                CDR:append_file_info('####1','l_CDR_export_tl')
              }
            } {
\CDR@Debug{\string\CDR_export_complete:~no~'##1'->'####1' }
            }
          }
        }
      }
      \lua_now:n { CDR:export_complete() }
    } {
      \typeout {\string\CDR_export_complete:~##1:~nothing~to~export}
    }
  }
  \cs_set_eq:NN \CDR_export_complete: \prg_do_nothing:
}

\AddToHook { enddocument / end } {
  \CDR_export_complete:
}
%    \end{MacroCode}
%
% \section{Style}
% \pkg{pygments}, through \CDRPy{}, creates style commands,
% but the storage is managed on the \LaTeX{} side by \CDRSty{}.
% This is a \LaTeX{} style API.
%
% \begin{function}{\CDR@StyleDefine}
% \begin{syntax}
% \cs{CDR@StyleDefine} \Arg{pygments style name} \Arg{definitions}
% \end{syntax}
% Define the definitions for the given \metatt{pygments style name}.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDR@StyleDefine #1 {
  \tl_gset:cn { g_CDR@Style/#1 }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR@StyleUse, CDR@StyleUseTag}
% \begin{syntax}
% \cs{CDR@StyleUse} \Arg{pygments style name}
% \cs{CDR@StyleUseTag}
% \end{syntax}
% Use the definitions for the given \metatt{pygments style name}.
% No safe check is made.
% The |\CDR@StyleUseTag| version finds the \metatt{pygments style name}
% from the context.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDR@StyleUse #1 {
  \tl_use:c { g_CDR@Style/#1 }
}
\cs_set:Npn \CDR@StyleUseTag {
  \CDR@StyleUse { \CDR_tag_get:c { style } }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR@StyleExist}
% \begin{syntax}
% \cs{CDR@StyleExist} \Arg{pygments style name} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} if a style exists with that given name,
% \metatt{false code} otherwise.
% \end{function}
%    \begin{MacroCode}
\prg_new_conditional:Nnn \CDR@StyleIfExist:c { TF } {
  \tl_if_exist:cTF { g_CDR@Style/#1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\cs_set_eq:NN \CDR@StyleIfExist \CDR@StyleIfExist:cTF
%    \end{MacroCode}
%
% \section{Creating display engines}
% \subsection{Utilities}
%
% \begin{function}[EXP]{\CDRCode_engine:c, \CDRCode_engine:V, \CDRBlock_engine:c, \CDRBlock_engine:V}
% \begin{syntax}
% \cs{CDRCode_engine:c} \Arg{engine name}
% \cs{CDRBlock_engine:c} \Arg{engine name}
% \end{syntax}
% |\CDRCode_engine:c| builds a command sequence name
% based on \metatt{engine name}.
% |\CDRBlock_engine:c| builds an environment name
% based on \metatt{engine name}.
%\end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRCode_engine:c #1 {
  CDR@colored/code/#1:nn
}
\cs_new:Npn \CDRBlock_engine:c #1 {
  CDR@colored/block/#1
}
\cs_new:Npn \CDRCode_engine:V {
  \exp_args:NV \CDRCode_engine:c
}
\cs_new:Npn \CDRBlock_engine:V {
  \exp_args:NV \CDRBlock_engine:c
}
%    \end{MacroCode}
%
% \begin{function}[EXP]{\CDRCode_options:c, \CDRCode_options:V, \CDRBlock_options:c, \CDRBlock_options:V}
% \begin{syntax}
% \cs{CDRCode_options:c} \Arg{engine name}
% \cs{CDRBlock_options:c} \Arg{engine name}
% \end{syntax}
% |\CDRCode_options:c| builds a command sequence name
% based on \metatt{engine name} used to store the comma list of key value options.
% |\CDRBlock_options:c| builds a command sequence name
% based on \metatt{engine name} used to store the comma list of key value options.
%\end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRCode_options:c #1 {
  CDR@colored/code~options/#1:nn
}
\cs_new:Npn \CDRBlock_options:c #1 {
  CDR@colored/block~options/#1
}
\cs_new:Npn \CDRCode_options:V {
  \exp_args:NV \CDRCode_options:c
}
\cs_new:Npn \CDRBlock_options:V {
  \exp_args:NV \CDRBlock_options:c
}
%    \end{MacroCode}
%
% \begin{function}[EXP]{\CDRCode_options_use:c, \CDRCode_options_use:V, \CDRBlock_options_use:c, \CDRBlock_options_use:V}
% \begin{syntax}
% \cs{CDRCode_options_use:c} \Arg{engine name}
% \cs{CDRBlock_options_use:c} \Arg{engine name}
% \end{syntax}
% |\CDRCode_options_use:c| builds a command sequence name
% based on \metatt{engine name} and use it.
% |\CDRBlock_options:c| builds a command sequence name
% based on \metatt{engine name} and use it.
%\end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRCode_options_use:c #1 {
  \CDRCode_if_options:cT { #1 } {
    \use:c { \CDRCode_options:c { #1 } }
  }
}
\cs_new:Npn \CDRBlock_options_use:c #1 {
  \CDRBlock_if_options:cT { #1 } {
    \use:c { \CDRBlock_options:c { #1 } }
  }
}
\cs_new:Npn \CDRCode_options_use:V {
  \exp_args:NV \CDRCode_options_use:c
}
\cs_new:Npn \CDRBlock_options_use:V {
  \exp_args:NV \CDRBlock_options_use:c
}
%    \end{MacroCode}
%
% \begin{variable}{\l_CDR_engine_tl}
% Storage for an engine name.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_engine_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDRGetOption}
% \begin{syntax}
% \cs{CDRGetOption} \Arg{relative key path}
% \end{syntax}
% Returns the value given to |\CDRCode| command or |CDRBlock| environment
% for the \metatt{relative key path}.
% This function is only available during |\CDRCode| execution
% and inside |CDRBlock| environment.
% \end{function}
%
% \subsection{Implementation}
%
% \begin{function}{\CDRCodeEngineNew, \CDRCodeEngineRenew}
% \begin{syntax}
% \cs{CDRCodeEngineNew}  \Arg{engine name}\Arg{engine body}
% \cs{CDRCodeEngineRenew}\Arg{engine name}\Arg{engine body}
% \end{syntax}
% \metatt{engine name} is a non void string, once expanded.
% The \metatt{engine body} is a list of instructions which may refer to
% the first argument as |#1|,
% which is the value given for key \metatt{engine name}| engine options|,
% and the second argument as |#2|, which is the colored code.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_forbidden:n #1 {
  \group_begin:
  \CDR_local_inherit:n { __no_tag, __no_engine }
  \CDR_local_set_known:nN { #1 } \l_CDR_kv_clist
  \group_end:
}
\NewDocumentCommand \CDRCodeEngineNew { mO{}m } {
  \exp_args:Nx
  \tl_if_empty:nTF { #1 } {
    \PackageWarning
      { coder }
      { The~engine~cannot~be~void. }
  } {
    \CDR_forbidden:n { #2 }
    \cs_set:cpn { \CDRCode_options:c { #1 } } { \exp_not:n { #2 } }
    \cs_new:cpn { \CDRCode_engine:c {#1} } ##1 ##2 {
      \cs_set_eq:NN \CDRGetOption \CDR_tag_get:c
      #3
    }
    \ignorespaces
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR_forbidden_keys:n}
% \begin{syntax}
% \cs{CDR_forbidden_keys:n} \Arg{key[=value] items}
% \end{syntax}
% Raise an error if one of |tags| and |engine| keys is provided in
% \metatt{key[=value] items}.
% These keys are forbidden for the \pkg{\jobname} options associate to
% an engine.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_forbidden_keys:n #1 {
  \group_begin:
  \CDR_local_inherit:n { __no_tags, __no_engine }
  \CDR_local_set_known:nN { #1 } \l_CDR_kv_clist
  \group_end:
}
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRCodeEngineRenew { mO{}m } {
  \exp_args:Nx
  \tl_if_empty:nTF { #1 } {
    \PackageWarning
      { coder }
      { The~engine~cannot~be~void. }
      \use_none:n
  } {
    \cs_if_exist:cTF { \CDRCode_engine:c { #1 } } {
      \CDR_forbidden:n { #2 }
      \cs_set:cpn { \CDRCode_options:c { #1 } } { \exp_not:n { #2 } }
      \cs_set:cpn { \CDRCode_engine:c { #1 } } ##1 ##2 {
        \cs_set_eq:NN \CDRGetOption \CDR_tag_get:c
        #3
      }
    } {
      \PackageWarning
        { coder }
        { No~code~engine~#1.}
    }
    \ignorespaces
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR@CodeEngineApply}
% \begin{syntax}
% \cs{CDR@CodeEngineApply} \Arg{source}
% \end{syntax}
% Get the code engine and apply it to the given \metatt{source}.
% When the code engine is not recognized, an error is raised.
% \emph{Implementation detail}: the argument is parsed by the last macro.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR@CodeEngineApply {
  \CDRCode_if_engine:cF { \CDR_tag_get:c { engine } } {
    \PackageError
      { coder }
      { \CDR_tag_get:c { engine }~code~engine~unknown,~replaced~by~`default' }
      { See~\CDRCodeEngineNew~in~the~coder~manual }
    \CDR_tag_set:cn { engine } { default }
  }
  \CDR_tag_get:c { format }  
  \exp_args:Nnx
  \use:c { \CDRCode_engine:c { \CDR_tag_get:c { engine } } } {
    \CDR_tag_get:c { \CDR_tag_get:c { engine }~engine~options },
    \CDR_tag_get:c { engine~options }
  }
}
%    \end{MacroCode}
% \begin{function}{\CDRBlockEngineNew, \CDRBlockEngineRenew}
% \begin{syntax}
% \cs{CDRBlockEngineNew}   \Arg{engine name} \oarg{options} \Arg{begin instructions} \Arg{end instructions}
% \cs{CDRBlockEngineRenew} \Arg{engine name} \oarg{options} \Arg{begin instructions} \Arg{end instructions}
% \end{syntax}
% Create a \LaTeX{} environment uniquely named after \metatt{engine name},
% which must be a non void string once expanded.
% The \metatt{begin instructions} and \metatt{end instructions}
% are lists of instructions which may refer to the name as |#1|,
% which is the value given to |CDRBlock| environment
% for key \metatt{engine name}| engine options|.
% Various options are available with the |\CDRGetOption| function.
% \emph{Implementation detail}: the fourth argument is parsed by
% |\NewDocumentEnvironment|.
% \end{function}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRBlockEngineNew { mO{}m } {
  \CDR_forbidden:n { #2 }
  \cs_set:cpn { \CDRBlock_options:c { #1 } } { \exp_not:n { #2 } }
  \NewDocumentEnvironment { \CDRBlock_engine:c { #1 } } { m } {
    \cs_set_eq:NN \CDRGetOption \CDR_tag_get:c
    #3
  }
}
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRBlockEngineRenew { mO{}m } {
  \tl_if_empty:nTF { #1 } {
    \PackageError
      { coder }
      { The~engine~cannot~be~void. }
      { See~\string\CDRBlockEngineNew~in~the~coder~manual }
      \use_none:n
  } {
    \cs_if_exist:cTF { \CDRBlock_engine:c { #1 } } {
      \CDR_forbidden:n { #2 }
      \cs_set:cpn { \CDRBlock_options:c { #1 } } { \exp_not:n { #2 } }
      \RenewDocumentEnvironment { \CDRBlock_engine:c { #1 } } { m } {
        \cs_set_eq:NN \CDRGetOption \CDR_tag_get:c
        #3
      }
    } {
      \PackageError
        { coder }
        { No~block~engine~#1.}
        { See~\string\CDRBlockEngineNew~in~the~coder~manual }
    }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_engine_begin:, \CDR@Block_engine_end:}
% \begin{syntax}
% \cs{CDRBlock_engine_begin:}
% \cs{CDRBlock_engine_end:}
% \end{syntax}
% After some checking, begin the engine display environment with the proper options.
% The second command closes the environment.
% This does not start a new group.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_engine_begin: {
\CDR@Debug{\string\CDRBlock_engine_begin:}
  \CDRBlock_if_engine:cF { \CDR_tag_get:c { engine } } {
    \PackageError
      { coder }
      { \CDR_tag_get:c { engine }~block~engine~unknown,~replaced~by~`default' }
      {See~\CDRBlockEngineNew~in~the~coder~manual}
    \CDR_tag_set:cn { engine } { default }
  }
  \exp_args:Nnx
  \use:c { \CDRBlock_engine:c \CDR_tag_get:c { engine } } {
    \CDR_tag_get:c { \CDR_tag_get:c { engine }~engine~options },
    \CDR_tag_get:c { engine~options },
  }
}
\cs_new:Npn \CDRBlock_engine_end: {
\CDR@Debug{\string\CDRBlock_engine_end:}
  \use:c { end \CDRBlock_engine:c \CDR_tag_get:c { engine } }
}
%    \begin{MacroCode}
%
% \subsection{Conditionals}
%
% \begin{function}[EXP,TF]{\CDRCode_if_engine:c}
% \begin{syntax}
% \cs{CDRCode_if_engine:cTF} \Arg{engine name} \Arg{true code} \Arg{false code}
% \end{syntax}
% If there exists a code engine with the given \metatt{engine name},
% execute \metatt{true code}.
% Otherwise, execute \metatt{false code}.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRCode_if_engine:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRCode_engine:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDRCode_if_engine:V { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRCode_engine:V #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \begin{function}[EXP,TF]{\CDRBlock_if_engine:c}
% \begin{syntax}
% \cs{CDRBlock_if_engine:c} \Arg{engine name} \Arg{true code} \Arg{false code}
% \end{syntax}
% If there exists a block engine with the given \metatt{engine name},
% execute \metatt{true code}, otherwise, execute \metatt{false code}.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRBlock_if_engine:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRBlock_engine:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDRBlock_if_engine:V { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRBlock_engine:V #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP,TF]{\CDRCode_if_options:c}
% \begin{syntax}
% \cs{CDRCode_if_options:cTF} \Arg{engine name} \Arg{true code} \Arg{false code}
% \end{syntax}
% If there exists a code options with the given \metatt{engine name},
% execute \metatt{true code}.
% Otherwise, execute \metatt{false code}.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRCode_if_options:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRCode_options:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDRCode_if_options:V { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRCode_options:V #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \begin{function}[EXP,TF]{\CDRBlock_if_options:c}
% \begin{syntax}
% \cs{CDRBlock_if_options:c} \Arg{engine name} \Arg{true code} \Arg{false code}
% \end{syntax}
% If there exists a block options with the given \metatt{engine name},
% execute \metatt{true code}, otherwise, execute \metatt{false code}.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRBlock_if_options:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRBlock_options:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDRBlock_if_options:V { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRBlock_options:V #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \subsection{Default code engine}
% The default code engine does nothing special and forwards its argument as is.
%    \begin{MacroCode}[OK]
\CDRCodeEngineNew { default } { #2 }
%    \end{MacroCode}
% 
% \subsection{\pkg{efbox} code engine}
%    \begin{MacroCode}
\AtBeginDocument {
  \@ifpackageloaded{efbox} {
    \CDRCodeEngineNew {efbox} {
      \efbox[#1]{#2}
    }
  } {}
}
%    \end{MacroCode}
% \subsection{Block mode default engine}
%    \begin{MacroCode}
\CDRBlockEngineNew { default } {
  \@bsphack
} {
  \@esphack
}
%    \end{MacroCode}
%
% \subsection{\pkg{tcolorbox} related engine}
% If the \pkg{tcolorbox} is loaded, related code and block engines are available.
%    \begin{MacroCode}
\AtBeginDocument {
  \@ifpackageloaded{tcolorbox} {
    \CDRBlockEngineNew {tcbox} {
      \begin{tcolorbox}[#1]
    } {
      \end{tcolorbox}
    }
  } {}
}
%    \end{MacroCode}
% 
% \section{\cs{CDRCode} function}
%
% \subsection{API}
% \begin{function}{\CDR@Sp}
% \begin{syntax}
% \cs{CDR@Sp}
% \end{syntax}
% Private method to eventually make the space character visible using
% |\FancyVerbSpace| base on |showspaces| value.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR@DefinePygSp {
  \CDR_if_tag_truthy:cTF { showspaces } {
    \cs_set:Npn \CDR@Sp {{\FancyVerbSpace}}
  } {
    \cs_set_eq:NN \CDR@Sp \space
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode}
% \begin{syntax}
% \cs{CDRCode}\Arg{key[=value]}\meta{delimiter}\meta{code}\meta{same delimiter}
% \end{syntax}
% Public method to declare inline code.
% \end{function}
%
% \subsection{Storage}
%
% \subsection{\texttt{__code} \pkg{l3keys} module}
% This is the module used to parse the user interface of the \cs{CDRCode} command.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __code } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed __initialize]^^A
% initialize
%    \begin{MacroCode}[OK]
  __initialize .meta:n = { 
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%
% \subsection{Implementation}
%
% \begin{function}{\CDRCodeSave}
% \begin{syntax}
% \cs{CDRCodeSave} \Arg{unique id} \metatt{delimiter}
% \end{syntax}
% \metatt{unique id} will be the argument of \cs{CDRCodeUse}.
% \end{function}
%    \begin{MacroCode}[OK]
\exp_args_generate:n {xxV}
\cs_set:Npn \CDRCodeSave:nnnn #1 #2 #3 #4 {
  \tl_gset:cn { CDRCodeUse / #4 : } {
    \CDR@Setup {
      synctex_tag=#1,
      synctex_line=#2,
    }
    \tl_set:Nn \CDR@Source {#3}
  }
}
\cs_new:Npn \CDRCodeSave #1 #2 {
  \group_begin:
  \lua_now:n { CDR:synctex_state_save() }
  \DefineShortVerb { #2 }
  \SaveVerb [
    aftersave = {
      \exp_args:Nx \UndefineShortVerb { #2 }
      \exp_args:NxxV
      \CDRCodeSave:nnnn {
        \lua_now:n { tex.print(CDR.synctex_tag) }
      } {
        \lua_now:n { tex.print(CDR.synctex_line) }
      } \FV@SV@CDR@Source { #1 }
      \lua_now:n { CDR:synctex_state_restore() }
      \group_end:
      \ignorespaces
    }
  ] { CDR@Source } #2
}
\cs_new:Npn \CDRCode_prepare:n #1 {
  \prg_set_conditional:Nnn \CDR_if_block: { p, T, F, TF } {
    \prg_return_false:
  }
  \clist_set:Nn \l_CDR_kv_clist { #1 }
  \CDRCode_tags_setup:N \l_CDR_kv_clist
  \CDRCode_engine_setup:N \l_CDR_kv_clist
  \CDR_local_inherit:n {
    __code, default.code, __pygments, default,
  }
  \CDR_local_set_known:N \l_CDR_kv_clist
  \CDR_tag_provide_from_kv:V \l_CDR_kv_clist
  \CDR_local_set_known:N \l_CDR_kv_clist
  \CDR_local_inherit:n {
    __fancyvrb,
  }
  \CDR_local_set:V \l_CDR_kv_clist  
  \CDR_set_conditional:Nn \CDR_if_pygments: {
    \CDR_has_pygments_p: && \CDR_if_tag_truthy_p:c {pygments}
  }
  \clist_map_inline:nn {
    fontsize, fontshape, fontseries,
    showspaces, showtabs, reflabel,
  } {
    \CDR_tag_get:cNTF { ##1 } \l_CDR_a_tl {
      \exp_args:NnV
      \CDR_fvset:nn { ##1 } \l_CDR_a_tl
    } {
      \PackageError
        { coder }
        { Build~time~error,~missing~key:~##1 }
        { Please report }
    }
  }
}
\NewDocumentCommand \CDRCodeUse { O{} m } {
\CDR@Debug{\string\CDRCodeUse=#2}
  \cs_if_exist:cTF { CDRCodeUse / #2 : } {
    \group_begin:
    \lua_now:n { CDR:synctex_state_save() }        
    \CDRCode_prepare:n { #1 }
    \use:c { CDRCodeUse / #2 : }
    \lua_now:n { CDR:synctex_target_set(0) }
    \CDR_if_pygments:TF {
      \cs_set:Npn \CDR@StyleUseTag {
        \CDR@StyleUse { \CDR_tag_get:c { style } }
        \cs_set_eq:NN \CDR@StyleUseTag \prg_do_nothing:
      }
      \CDRCode_pyg:v { CDR@Source }
    } {
      \CDRCode_fv:v  { CDR@Source }
    }
    \lua_now:n { CDR:synctex_state_restore() }
    \group_end:
  } {
    \PackageError
      { coder }
      { Bad~identifier:~#2 }
      { See~\string\CDRCodeSave }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_escape_inside:n}
% \begin{syntax}
% \cs{CDRCode_escape_inside:n} \Arg{text}
% \end{syntax}
% When \pkg{pygments} does not manage what is escaped,
% it must be done by hand.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDRCode_escape_inside:n #1 {
\CDR@Debug{\string\CDRCode_escape_inside:nn}
  \CDR_tag_get:cN { escapeinside } \l_CDR_delimiters_tl
  \int_compare:nNnTF { \tl_count:N \l_CDR_delimiters_tl } = 2 {
    \regex_set:Nx \l_CDR_regex {
      [ \tl_item:Nn \l_CDR_delimiters_tl { 1 } ]
      (.*?) [ \tl_item:Nn \l_CDR_delimiters_tl { 2 } ]
    }
    \regex_split:NnN \l_CDR_regex { #1 } \l_CDR_seq
  } {
    \int_compare:nNnTF { \tl_count:N \l_CDR_delimiters_tl } = 3 {
      \regex_set:Nx \l_CDR_regex {
        [ \tl_item:Nn \l_CDR_delimiters_tl { 1 } ]
        (.*?) [ \tl_item:Nn \l_CDR_delimiters_tl { 2 } ]
        .*? [ \tl_item:Nn \l_CDR_delimiters_tl { 3 } ]
      }
      \regex_split:NnN \l_CDR_regex { #1 } \l_CDR_seq
    } {
      \seq_clear:N \l_CDR_seq
    }
  }
  \seq_if_empty:NTF \l_CDR_seq {
    #1
  } {
    \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl \tl_use:N \l_CDR_a_tl
    \bool_while_do:nn { ! \seq_if_empty_p:N \l_CDR_seq } {
      \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl
      \exp_args:NnV
      \tl_rescan:nn { } \l_CDR_a_tl
      \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl \tl_use:N \l_CDR_a_tl  
    }
  }
}
\NewDocumentCommand \CDRCode { O{} m } {  \group_begin:
  \CDRCode_prepare:n { #1 }
  \CDR_if_pygments:TF {
    \cs_set:Npn \CDR@StyleUseTag {
      \CDR@StyleUse { \CDR_tag_get:c { style } }
      \cs_set_eq:NN \CDR@StyleUseTag \prg_do_nothing:
    }
    \DefineShortVerb { #2 }
    \SaveVerb [
      aftersave = {
        \exp_args:Nx \UndefineShortVerb { #2 }
        \CDRCode_pyg:v{FV@SV@CDR@Source}
        \group_end:
      }
    ] { CDR@Source } #2
  } {
    \DefineShortVerb { #2 }
    \SaveVerb [
      aftersave = {
        \exp_args:Nx \UndefineShortVerb { #2 }
        \CDRCode_fv:v { FV@SV@CDR@Source }
        \group_end:
      }
    ] { CDR@Source } #2
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_tags_setup:N, \CDRCode_engine_setup:N}
% \begin{syntax}
% \cs{CDRCode_tags_setup:N} \Arg{clist var}
% \cs{CDRCode_engine_setup:N} \Arg{clist var}
% \end{syntax}
% Utility to setup the tags, the tag inheritance tree and the engine.
% When not provided explicitly with the |tags=...| user interface,
% a code chunk will have the list of tags stored in |\g_CDR_tags_clist|
% by last |\CDRExport|, |\CDRSet| or |\CDRBlock| environment.
% At least one tag must be provided, either implicitly or explicitly.
% \end{function}
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRCode_tags_setup:N #1 {
\CDR@Debug{\string \CDRCode_tags_setup:N, \string #1 }
  \CDR_local_inherit:n { __tags }
  \CDR_local_set_known:N #1
  \CDR_if_tag_exist_here:ccT { __local } { tags } {
    \CDR_tag_get:cN { tags } \l_CDR_clist
    \clist_if_empty:NF \l_CDR_clist {
      \clist_gset_eq:NN \g_CDR_tags_clist \l_CDR_clist
    }
  }
  \clist_if_empty:NT \g_CDR_tags_clist {
    \CDR_tag_get:cN { default~tags } \g_CDR_tags_clist
    \clist_if_empty:NT \g_CDR_tags_clist {
      \PackageWarning
        { coder }
        { No~default~tags~provided. }
    }
  }
\CDR@Debug {CDRCode_tags_setup:N\space\g_CDR_tags_clist}
%    \end{MacroCode}
% Setup the inheritance tree for the |\CDR_tag_get:...| related functions.
%    \begin{MacroCode}
  \CDR_get_inherit:f {
    \g_CDR_tags_clist,
    __tags, __engine, __code, default.code, __pygments, default,
  }
}
%    \end{MacroCode}
% Now setup the engine options if any.
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRCode_engine_setup:N #1 {
\CDR@Debug{\string \CDRCode_engine_setup:N, \string #1}
  \CDR_local_inherit:n { __engine }
  \CDR_local_set_known:N #1
  \CDR_tag_get:cNT { engine } \l_CDR_a_tl {
    \clist_put_left:Nx #1 { \CDRCode_options_use:V \l_CDR_a_tl }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_pyg:}
% \begin{syntax}
% \cs{CDRCode_pyg:n} \Arg{tl variable name}
% \end{syntax}
% Utility used by |\CDRCode:n|.
% The main tricky part is that we must collect the \metatt{key[=value]}
% items and feed |\FV@KeyValues| with them in the |aftersave| handler.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDRCode_pyg:v #1 {
  \lua_now:n { CDR:hilight_code_setup() }
  \CDR_tag_get:cN {lang} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('lang') }
  \CDR_tag_get:cN {cache} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('cache') }
  \CDR_tag_get:cN {debug} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('debug') }
  \CDR_tag_get:cN {escapeinside} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('escapeinside') }
  \CDR_tag_get:cN {mathescape} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('mathescape') }
  \CDR_tag_get:cN {style} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('style') }
  \lua_now:n { CDR:hilight_set_var('source', '#1') }
  \clist_set_eq:NN \FV@KeyValues \l_CDR_kv_clist
  \FV@UseKeyValues
  \frenchspacing
  \FV@BaseLineStretch
  \FV@FontSize
  \FV@FontFamily
  \FV@FontSeries
  \FV@FontShape
  \selectfont
  \FV@DefineWhiteSpace
  \FancyVerbDefineActive
  \FancyVerbFormatCom
  \CDR@DefinePygSp
  \CDR_tag_get:c { format }
  \CDR@CodeEngineApply {
    \CDR@StyleIfExist { \CDR_tag_get:c { style } } { } {
      \lua_now:n { CDR:hilight_source(true, false) }
      \input { \l_CDR_pyg_sty_tl }
    }
    \CDR@StyleUseTag
    \lua_now:n { CDR:hilight_source(false, true) }        
    \makeatletter
    \CDR_if_tag_truthy:cT { mbox } { \mbox } {
      \input { \l_CDR_pyg_tex_tl }\ignorespaces
    }  
    \lua_now:n { CDR:hilight_code_teardown() }
    \makeatother
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_fv:v}
% \begin{syntax}
% \cs{CDRCode_fv:n} \Arg{cs name}
% \end{syntax}
% Utility used by |\CDRCode:n|.
% The main tricky part is that we must collect the \metatt{key[=value]}
% items and feed |\FV@KeyValues| with them in the |aftersave| handler.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDRCode_fv:v #1 {
  \cs_set_eq:NN \CDR@FormattingPrep \FV@FormattingPrep
  \cs_set:Npn \FV@FormattingPrep {
    \CDR@FormattingPrep
    \CDR_tag_get:c { format }
  }
  \CDR@CodeEngineApply { \CDR_if_tag_truthy:cT { mbox } { \mbox } {
    \clist_set_eq:NN \FV@KeyValues \l_CDR_kv_clist
    \FV@UseKeyValues
    \FV@FormattingPrep
    \exp_args:Nv
    \CDRCode_escape_inside:n { #1 }
  } }
}
%    \end{MacroCode}
%
% \section{\texttt{CDRBlock} environment}
%
% \begin{environment}{CDRBlock}
% \begin{syntax}
% \cs{begin}\{CDRBlock\}\Arg{key[=value] list} ... \cs{end}\{CDRBlock\}
% \end{syntax}
% \end{environment}
%
% \subsection{\texttt{__block} \pkg{l3keys} module}
% This module is used to parse the user interface of the |CDRBlock| environment.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __block } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed no~export{[=true$\vert$false]}]^^A
% to ignore this code chunk at export time.
%    \begin{MacroCode}[OK]
  no~export .code:n = \CDR_tag_boolean_set:x { #1 },
  no~export .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed no export format=\metatt{format commands}]^^A
% a format appended to |format|, |tags format| and |numbers format|
% when |no export| is |true|..
% Initially empty.
%    \begin{MacroCode}[OK]
  no~export~format .code:n = \CDR_tag_set:,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed dry numbers{[=true$\vert$false]}]^^A
% Initially |false|.
%    \begin{MacroCode}[OK]
  dry~numbers .code:n = \CDR_tag_boolean_set:x { #1 },
  dry~numbers .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed no top space{[=true$\vert$false]}]^^A
% Initially |false|.
%    \begin{MacroCode}[OK]
  no~top~space .code:n = \CDR_tag_boolean_set:x { #1 },
  no~top~space .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed test{[=true$\vert$false]}]^^A
% whether the chunk is a test,
%    \begin{MacroCode}[OK]
  test .code:n = \CDR_tag_boolean_set:x { #1 },
  test .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed obey lines{[=true$\vert$false]}]^^A
% The displayed line numbers are exactly the physical ones.
%    \begin{MacroCode}[OK]
  obey~lines .code:n = \CDR_tag_set:,
  obey~lines .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% initialize
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    no~export = false,
    no~export~format = ,
    dry~numbers  = false,
    no~top~space = false,
    test   = false,
    obey~lines = false,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%
% \subsection{Implementation}
%
% \subsubsection{Storage}
%
% \begin{variable}{__start, __step, __last, __mini, __maxi }
% For the line numbering, these are loop integer controls.
% The lines displayed are in the range $⟦$|__mini|;|__maxi|$⟧$\CDRCheckRed,
% relative to the \LaTeX\ source block where they are defined.
% \begin{description}
% \itemtt[__start] for the first index
% \itemtt[__step] for the step, defaults to 1
% \itemtt[__last] for the last index, included
% \end{description}
%    \begin{MacroCode}[OK]
\CDR_int_new:cn { __start } { 0 }
\CDR_int_new:cn { __step  } { 0 }
\CDR_int_new:cn { __last  } { 0 }
\CDR_int_new:cn { __mini  } { 0 }
\CDR_int_new:cn { __maxi  } { 0 }
%    \end{MacroCode}
% \end{variable}
%
% \subsubsection{Preparation}
%
% \begin{function}{\CDRBlock_preflight:n}
% \begin{syntax}
% \cs{CDRBlock_preflight:n} \Arg{CDR@Block kv list}
% \end{syntax}
% This is a prefligh hook intended for testing.
% The default implementation does nothing.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_preflight:n #1 { }
%    \end{MacroCode}
%
% \subsubsection{Main environment}
%
% \begin{variable}{\l_CDR_vrb_tl}
% Storage for the mandatory argument of the |CDRBlockSave| environment.
% This data must be shared with the command that closes the environment.
% \end{variable}
%    \begin{MacroCode}
\tl_new:N \l_CDR_vrb_tl
%    \end{MacroCode}
%
% \begin{variable}{\l_CDR_vrb_seq}
% All the lines are scanned and recorded before they are processed.
% \end{variable}
%    \begin{MacroCode}
\seq_new:N \l_CDR_vrb_seq
%    \end{MacroCode}
% \begin{variable}{\l_CDR_vrb_prop}
% Extra fields.
% \end{variable}
%    \begin{MacroCode}
\prop_new:N \l_CDR_vrb_prop
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_scan_begin:, \CDRBlock_scan_end:}
% \begin{syntax}
% \cs{CDRBlock_scan:}
% \end{syntax}
% Helper to begin/end the |CDRBlock| and |CDRBlockSave| environments.
% These functions must be balanced.
% The purpose is to record the verbatim text in a sequence of lines,
% this is done inside a group to keep the catcodes intact from the outer word.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_scan_begin: {
\CDR@Debug{\string\CDRBlock_scan_begin:}
  \group_begin:
  \seq_clear:N  \l_CDR_vrb_seq
  \cs_set_protected_nopar:Npn \FV@ProcessLine ##1 {
    \seq_put_right:Nn \l_CDR_vrb_seq { ##1 }
  }
  \FV@Scan
}
\cs_new:Npn \CDRBlock_scan_end: {
\CDR@Debug{\string\CDRBlock_scan_end:~\seq_count:N \l_CDR_vrb_seq~lines}
  \exp_args:NNNV
  \group_end:
  \tl_set:Nn \l_CDR_vrb_seq \l_CDR_vrb_seq
}
%    \end{MacroCode}
% \begin{function}{\FVB@CDRBlock}
% \pkg{fancyvrb} helper to begin the |CDRBlock| environment.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \FVB@CDRBlock {
\CDR@Debug{\string\FVB@CDRBlock}
  \exp_args:NV \CDRBlock_preflight:n \FV@KeyValues
  \CDRBlock_scan_begin:
}
%    \end{MacroCode}
%
% \begin{variable}{\l_CDR_regex}
% Scratch variable to hold a regular expression.
% \end{variable}
%    \begin{MacroCode}
\regex_new:N \l_CDR_regex
%    \end{MacroCode}
% Utility to use \string\fvset\ properly.
%    \begin{MacroCode}
\cs_new:Npn \CDR_fvset:nn #1 #2 {
  \fvset{#1={#2}}
}
%    \end{MacroCode}
%
% \begin{function}{\FVE@CDRBlock}
% \pkg{fancyvrb} helper to end the |CDRBlock| environment.
% \end{function}
%    \begin{MacroCode}
\cs_generate_variant:Nn \regex_set:Nn { Nx, NV }
\cs_new:Npn \FVE@CDRBlock {
  \CDRBlock_scan_end:
  \exp_args:Nx
  \lua_now:n { CDR:synctex_state_save(-1-\seq_count:N \l_CDR_vrb_seq ) }
  \prop_clear:N \l_CDR_vrb_prop
  \prop_put:Nnx \l_CDR_vrb_prop { synctex_tag } {
    \lua_now:n { tex.print( CDR.synctex_tag ) }
  }
  \prop_put:Nnx \l_CDR_vrb_prop { synctex_line } {
    \lua_now:n { tex.print( CDR.synctex_line ) }
  }
  \CDRBlock_use:c { l_CDR_vrb }
  \lua_now:n { CDR:synctex_state_restore() } 
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_use:c}
% \begin{syntax}
% \cs{CDRBlock_use:nc} \Arg{sequence name}
% \end{syntax}
% Helper to complete the |CDRBlock| environments and and |CDRBlockUse| command.
% \pkg{fancyvrb} helper to end the |CDRBlock| environment.
% \end{function}
%    \begin{MacroCode}
\cs_generate_variant:Nn \seq_map_indexed_inline:Nn { cn }
\cs_new:Npn \CDRBlock_use:c #1 {
  \seq_if_exist:cTF { #1_seq } {
\CDR@Debug{\string\CDRBlock_use:c, \seq_count:c {#1_seq} }
    \CDRBlock_setup:
    \CDRBlock_engine_begin:
%    \end{MacroCode}
% We export all the lines if requested except what was escaped to \LaTeX.
% As we use regular expressions, we must take care of characters with a special
% meaning. For that purpose we enclose between square brackets, this is why
% the carret |^| is not allowed, as it would negate the class.
%
% If |texcomment| has been set and the language is not |tex|,
% for each line, only the part before the first |%| will be exported.
%
% If |texcomment| has not been set, and |escapeinside| has been provided with
% two characters, then what is inside the delimiter and the delimiters is not exported.
%
% Actually, no alternate possibility is offered.
%    \begin{MacroCode}  
\CDR@Debug{\string\CDRBlock_use:c\space Record lines}
    \seq_map_inline:cn { #1_seq } {
      \tl_set:Nn \l_CDR_a_tl { ##1 }
      \lua_now:n { CDR:record_line('l_CDR_a_tl') }
    }
%    \end{MacroCode}
% Line numbering is not delegated to \pkg{fancyvrb}, the main difficulty
% is to manage the |__mini| and |__maxi| values because they can be defined either
% explicitly by a number or implicitly by a regular expression.
% Let us start by the minimum index.
%    \begin{MacroCode}  
    \CDR_int_set:cn { __mini } { 1 }
    \CDR_tag_get:cNT { firstline } \l_CDR_a_tl {
      \tl_if_empty:NF \l_CDR_a_tl {
        \exp_args:NNV
        \regex_match:NnTF \c_CDR_int_regex \l_CDR_a_tl {
          \int_compare:nNnTF { \l_CDR_a_tl } > 0 {
            \CDR_int_set:cn { __mini } { \l_CDR_a_tl }
          } {
            \CDR_int_set:cn { __mini } { \seq_count:c { #1_seq } + \l_CDR_a_tl }
          }
        } {
          \regex_set:NV \l_CDR_regex \l_CDR_a_tl
          \seq_map_indexed_inline:cn { #1_seq } {
            \regex_match:NnT \l_CDR_regex { ##2 } {
              \CDR_int_set:cn { __mini } { ##1 }
              \seq_map_break:
            }
          }
        }
      }
    }
%    \end{MacroCode}
% Let us go now for the maximum index.
%    \begin{MacroCode}  
    \CDR_int_set:cn { __maxi } { \seq_count:c { #1_seq } }
    \CDR_tag_get:cNT { lastline } \l_CDR_a_tl {
      \tl_if_empty:NF \l_CDR_a_tl {
        \exp_args:NNV
        \regex_match:NnTF \c_CDR_int_regex \l_CDR_a_tl {
          \int_compare:nNnTF { \l_CDR_a_tl } > 0 {
            \CDR_int_set:cn { __maxi } { \l_CDR_a_tl }
          } {
            \CDR_int_set:cn { __maxi } { \seq_count:c { #1_seq } + \l_CDR_a_tl }
          }
        } {
          \regex_set:NV \l_CDR_regex \l_CDR_a_tl
          \seq_map_indexed_inline:cn { #1_seq } {
            \CDR_int_compare:cNnF { __mini } > { ##1 } {
              \regex_match:NnT \l_CDR_regex { ##2 } {
                \CDR_int_set:cn { __maxi } { ##1 }
                \seq_map_break:
              }
            }
          }
        }
      }
    }
%    \end{MacroCode}
% This is a patch to remove an extra space at the top.
%    \begin{MacroCode}
    \cs_set:Npn \FV@ListVSpace {%
%  \@topsepadd\topsep
      \@topsepadd=\FancyVerbVspace
      \if@noparlist\advance\@topsepadd\partopsep\fi
      \if@inlabel
        \vskip\parskip
      \else
        \if@nobreak
          \vskip\parskip
          \clubpenalty\@M
        \else
          \CDR_if_tag_truthy:cF { no~top~space } {
            \addpenalty\@beginparpenalty
            \@topsep\@topsepadd
            \advance\@topsep\parskip
            \addvspace\@topsep
          }
        \fi
      \fi
      \global\@nobreakfalse
      \global\@inlabelfalse
      \global\@minipagefalse
      \global\@newlistfalse
    }
    \clist_map_inline:nn { resetmargins, gobble, fontsize, fontshape, fontseries,
      showspaces, showtabs,
    } {
      \CDR_tag_get:cNTF { ##1 } \l_CDR_a_tl {
        \exp_args:NnV
        \CDR_fvset:nn { ##1 } \l_CDR_a_tl
      } {
        \PackageError
          { coder }
          { Build~time~error,~missing~key:~##1 }
          { Please report }
      }
    }
\CDR@Debug{\string\CDRBlock_use:c\space 2}
    \CDR_if_tag_truthy:cT { obey~lines } {
      \tl_set:Nn \l_CDR_obey_tl { __n }
    }
    \tl_clear:N \FV@ListProcessLastLine
    \CDR_if_pygments:TF {
      \CDRBlock_use_pyg:c { #1 }
    } {
      \CDRBlock_use_fv:c { #1 }
    }
    \CDRBlock_teardown:c { #1 }
    \CDRBlock_engine_end:
%  \endgroup
  } {
    \PackageError
      { coder }
      { Unknown~block~identifier:~#1 }
      { See~CDRBlockSave~environment. }
  }
}
\DefineVerbatimEnvironment{CDRBlock}{CDRBlock}{}
%    \end{MacroCode}
% Read and catch the key value arguments,
% except the ones related to \pkg{fancyvrb}.
% Then build the dynamic keys matching
% \metatt{engine name}| engine options| for appropriate
% engine names.
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRBlock_setup: {
\CDR@Debug { \string \CDRBlock_setup:n , \exp_args:NV \tl_to_str:n \FV@KeyValues }
  \prg_set_conditional:Nnn \CDR_if_block: { p, T, F, TF } {
    \prg_return_true:
  }
  \CDR_tag_keys_set:nn { __block } { __initialize }
%    \end{MacroCode}
% Read and catch the key value arguments,
% except the ones related to \pkg{fancyvrb}.
% Then build the dynamic keys matching
% \metatt{engine name}| engine options| for appropriate
% engine names.
%    \begin{MacroCode}
  \clist_put_right:NV \FV@KeyValues \l_CDR_kv_clist
  \clist_clear:N \l_CDR_kv_clist
  \CDRBlock_tags_setup:N \FV@KeyValues
  \CDRBlock_engine_setup:N \FV@KeyValues
  \CDR_local_inherit:n {
    __block, __pygments.block, default.block,
    __pygments, default
  }
  \CDR_local_set_known:N \FV@KeyValues
  \CDR_tag_provide_from_kv:V \FV@KeyValues
  \CDR_local_set_known:N \FV@KeyValues
\CDR@Debug{\string \CDRBlock_setup:n.KV1:}
%    \end{MacroCode}
% Now |\FV@KeyValues| is meant to contains only keys
% related to \pkg{fancyvrb} but we still need to filter them out.
% If the display engine is not the default one, we catch any key related
% to framing. Anyways, we catch keys related to numbering because
% line numbering is completely performed by \pkg{\jobname}.
%    \begin{MacroCode}
  \CDR_local_inherit:n {
    \CDR_if_tag_eq:cnF { engine } { default } {
      __fancyvrb.frame,
    },
    __fancyvrb.number,
  }
  \CDR_local_set_known:N \FV@KeyValues
\CDR@Debug{\string \CDRBlock_setup:n, \FV@KeyValues}
%    \end{MacroCode}
% These keys are read without removing them
% later and eventually forwarded to \pkg{fancyvrb}
% through its natural |\FV@UseKeyValues| mechanism.
%    \begin{MacroCode}  
  \CDR_local_inherit:n {
    __fancyvrb.block,
    __fancyvrb,
  }
  \CDR_local_set_known:VN \FV@KeyValues \l_CDR_kv_clist
  \lua_now:n {
    CDR:hilight_block_setup('g_CDR_tags_clist')
  }
  \CDR_set_conditional:Nn \CDR_if_pygments:
    { \CDR_has_pygments_p: && \CDR_if_tag_truthy_p:c { pygments } }
  \CDR_set_conditional:Nn \CDR_if_no_export:
    { \CDR_if_tag_truthy_p:c { no~export } }
  \CDR_set_conditional:Nn \CDR_if_numbers_dry:
    { \CDR_if_tag_truthy_p:c { dry~numbers } }
  \CDR_set_conditional:Nn \CDR_if_dry_tags:
    { \CDR_if_tag_eq_p:cn { show~tags } { dry } }
  \CDR_set_conditional:Nn \CDR_if_number_on:
    { ! \CDR_if_tag_eq_p:cn { numbers } { none } }
  \CDR_set_conditional:Nn \CDR_if_already_tags: {
    \CDR_if_tag_truthy_p:c { only~top } &&
    \CDR_clist_if_eq_p:NN \g_CDR_tags_clist \g_CDR_last_tags_clist
  }
  \CDR_if_number_on:T {
    \clist_map_inline:Nn \g_CDR_tags_clist {
      \CDR_int_if_exist:cF { ##1 } {
        \CDR_int_new:cn { ##1 } { 1 }
      }
    }
  }
}
%    \end{MacroCode}
% \begin{function}{\CDRBlock_teardown:c}
% \begin{syntax}
% \cs{CDRBlock_teardown:c} \Arg{block identifier}
% \end{syntax}
% Update the stored line numbers and send the |hilight_block_teardown| message to |CDR|.
% In general, line numbers are updated such that people reading the whole document
% can have the impression that the numbering flow is continuous.
% If numbering was off or |dry|, no number update is performed.
% \end{function}
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRBlock_teardown:c #1 {
\CDR@Debug{ \string \CDRBlock_teardown:c }
  \bool_if:nT { \CDR_if_number_on_p: && !\CDR_if_numbers_dry_p: } {
\CDR@Debug{ \string \CDRBlock_teardown:c ~UPDATE}
    \CDR_if_tag_eq:cnTF { firstnumber } { last } {
\CDR@Debug{ \string \CDRBlock_teardown:c~CONTINUOUS }
      \CDR_int_set:cn { __n } {
        \seq_count:c { #1_seq }
      }
      \clist_map_inline:Nn \g_CDR_tags_clist {
        \CDR_int_gadd:cc { ##1 } { __n }
        \CDR@Debug{NEXT~LINE~##1:~\CDR_int_use:c { ##1 } }
      }
    } {
\CDR@Debug{ \string \CDRBlock_teardown:c~NORMAL }
      \CDR_if_tag_eq:cnTF { firstnumber } { auto } {
        \CDR_int_set:cn { __n } {
          1 + \seq_count:c { #1_seq }
        }
      } {
        \CDR_int_set:cn { __n } {
          \CDR_tag_get:c { firstnumber } + \seq_count:c { #1_seq }
        }
      }
      \clist_map_inline:Nn \g_CDR_tags_clist {
        \CDR_int_gset:cc { ##1 } { __n }
        \CDR@Debug{NEXT~LINE~##1:~\CDR_int_use:c { ##1 } }
      }
    }
  }
  \lua_now:n {
    CDR:hilight_block_teardown()
  }
  \CDR_if_dry_tags:F {
    \clist_gset_eq:NN \g_CDR_last_tags_clist \g_CDR_tags_clist
  }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{CDRBlockSave} environment}
% This is used to save code for a later use by |\CDRBlockUse|.
%
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { CDRBlockSave } {
  gobble .choices:nn = {
    0,1,2,3,4,5,6,7,8,9
  } {
    \CDR_tag_choices_set:
  },
}
%    \end{MacroCode}
% \begin{function}{\FVB@CDRBlockSave}
% \pkg{fancyvrb} helper to begin the |CDRBlockSave| environment.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \FVB@CDRBlockSave #1 {
\CDR@Debug{\string\FVB@CDRBlockSave}
  \CDR_local_inherit:n { CDRBlockSave }
  \exp_args:NV 
  \CDR_local_set:n \FV@KeyValues
  \tl_set:Nn \l_CDR_vrb_tl { CDRBlockUse / #1 }
  \CDRBlock_scan_begin:
}
%    \end{MacroCode}
%
% \begin{function}{\FVE@CDRBlockSave}
% \pkg{fancyvrb} helper to end the |CDRBlockSave| environment, no operation.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \FVE@CDRBlockSave {
\CDR@Debug{\string\FVE@CDRBlockSave/\l_CDR_vrb_tl}
  \CDRBlock_scan_end:
  \exp_args:Nx
  \lua_now:n { CDR:synctex_state_save(-1-\seq_count:N \l_CDR_vrb_seq ) }
  \prop_gclear:c { \l_CDR_vrb_tl _prop }
  \prop_gput:cnx { \l_CDR_vrb_tl _prop } { synctex_tag } {
    \lua_now:n { tex.print( CDR.synctex_tag ) }
  }
  \prop_gput:cnx { \l_CDR_vrb_tl  _prop } { synctex_line } {
    \lua_now:n { tex.print( CDR.synctex_line ) }
  }
  \CDR_get_inherit:f {
    __fancyvrb.block,
  }
\CDR@Debug{\string\FVE@CDRBlockSave/\CDR_tag_get:c { gobble }}
  \CDR_if_tag_eq:cnTF { gobble } { 0 } {
    \seq_gset_eq:cN { \l_CDR_vrb_tl _seq } \l_CDR_vrb_seq
  } {
\CDR@Debug{\string\FVE@CDRBlockSave/1}
    \CDR_tag_get:cN { gobble } \l_CDR_a_tl
\CDR@Debug{\string\FVE@CDRBlockSave/2}
    \exp_args:NnV
    \use:n {
      \renewcommand{\FV@@@@Gobble} [ %]
    } \l_CDR_a_tl %[
    ] {}
\CDR@Debug{\string\FVE@CDRBlockSave/3}
    \seq_gclear:c { \l_CDR_vrb_tl _seq }
    \seq_map_inline:Nn \l_CDR_vrb_seq {
\CDR@Debug{\string\FVE@CDRBlockSave/4}
      \tl_if_empty:nTF { ##1 } {
\CDR@Debug{\string\FVE@CDRBlockSave/5}
        \seq_gput_right:cn { \l_CDR_vrb_tl _seq } {}
      } {
\CDR@Debug{\string\FVE@CDRBlockSave/6}
        \int_compare:nNnTF {
          \CDR_tag_get:c { gobble }
        } < {
          \tl_count:n { ##1 }
        } {
\CDR@Debug{\string\FVE@CDRBlockSave/7}
          \seq_gput_right:co { \l_CDR_vrb_tl _seq } {
            \FV@@@@Gobble ##1
          }
        } {
\CDR@Debug{\string\FVE@CDRBlockSave/8}
          \seq_gput_right:cn { \l_CDR_vrb_tl _seq } {}
        }
      }
    }
  }
  \lua_now:n { CDR:synctex_state_restore() }
}
\DefineVerbatimEnvironment{CDRBlockSave}{CDRBlockSave}{}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlockUse}
% \begin{syntax}
% \cs{CDRBlockUse} \oarg{key[=value] list} \marg{unique identifier}
% \end{syntax}
% \end{function}
%    \begin{MacroCode}
\NewDocumentCommand\CDRBlockUse{ O{} m } {
\CDR@Debug{\string\CDRBlockUse/#2}
  \lua_now:n { CDR:synctex_state_save() }
  \cs_set:Npn \FV@KeyValues { #1 }
  \CDRBlock_use:c { CDRBlockUse / #2 }
  \lua_now:n { CDR:synctex_state_restore() }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlockExe}
% \begin{syntax}
% \cs{CDRBlockExe} \marg{unique identifier}
% \end{syntax}
% \end{function}
%    \begin{MacroCode}
\NewDocumentCommand\CDRBlockExe{ O{} m } {
\CDR@Debug{\string\CDRBlockExe/#2}
  \lua_now:n {
    CDR:rescan_begin()
    CDR:synctex_state_save()
  }
  \exp_args:Nnx
  \keys_set:nn { CDRBlockExe } {
    \tl_if_empty:nT { #1 } { makeatletter=false, }
    #1
  }
  \CDRBlock_if_saved:cTF { #2 } {
    \prop_get:cnNT { #2_prop } { synctex_tag } \l_CDR_a_tl {
      \lua_now:n { CDR:synctex_tag_set(\l_CDR_a_tl) }
    }
    \prop_get:cnNT { #2_prop } { synctex_line } \l_CDR_a_tl {
      \lua_now:n { CDR:synctex_line_set(\l_CDR_a_tl) }
    }
    \seq_map_variable:cNn { CDRBlockUse / #2_seq } \l_CDR_a_tl {
      \directlua{CDR:rescan_push_line('l_CDR_a_tl')}
    }
    \directlua{CDR:rescan_end()}    
  } {
    NO~\string\CDRBlockUse/#1!
  }
  \lua_now:n { CDR:synctex_state_restore() }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlockFree}
% \begin{syntax}
% \cs{CDRBlockFree} \marg{unique identifier}
% \end{syntax}
% Free the memory for this identifier. After that instruction,
% |\CDRBlockUse{|\marg{unique identifier}|}| is no longer available.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlockFree #1 {
\CDR@Debug{\string\CDRBlockFree/#1}
  \cs_undefine:c { CDRBlockUse / #1 }
}
%    \end{MacroCode}
%
% \subsubsection{\pkg{pygments} only}
%
% Parts of |CDRBlock| environment specific to \pkg{pygments}.
%
% \begin{function}{\CDRBlock_use_pyg:c}
% \begin{syntax}
% \cs{CDRBlock_use_pyg:c} \Arg{identifier}
% \end{syntax}
% The code chunk is stored line by line in |#1_seq|.
% Other field are in |#1_prop|.
% Use \pkg{pygments} to colorize the code,
% and use \pkg{fancyvrb} once more to display the colored code.
% \end{function}
%    \begin{MacroCode}
\cs_set_protected:Npn \CDRBlock_use_pyg:c #1 {
\CDR@Debug { \string\CDRBlock_use_pyg:c / #1 }
  \prop_get:cnNT { #1_prop } { synctex_tag } \l_CDR_a_tl {
    \lua_now:n { CDR:hilight_set_var('synctex_tag') }
  }
  \prop_get:cnNT { #1_prop } { synctex_line } \l_CDR_a_tl {
    \lua_now:n { CDR:hilight_set_var('synctex_line') }
  }
  \lua_now:n { CDR:hilight_set_var('lang') }
  \CDR_tag_get:cN {lang} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('lang') }
  \CDR_tag_get:cN {cache} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('cache') }
  \CDR_tag_get:cN {debug} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('debug') }
  \CDR_tag_get:cN {texcomments} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('texcomments') }
  \CDR_tag_get:cN {escapeinside} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('escapeinside') }
  \CDR_tag_get:cN {mathescape} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('mathescape') }
  \CDR_tag_get:cN {style} \l_CDR_a_tl
  \lua_now:n { CDR:hilight_set_var('style') }
%  \cctab_select:N \c_document_cctab
\CDR@Debug { \string\CDRBlock_use_pyg:c / Style:\l_CDR_a_tl }
  \CDR@StyleIfExist { \l_CDR_a_tl } { } {
    \lua_now:n { CDR:hilight_source(true, false) }
    \input { \l_CDR_pyg_sty_tl }
  }
  \CDR@StyleUseTag
  \CDR@DefinePygSp
  \lua_now:n { CDR:hilight_source(false, true) }
  \fvset{ commandchars=\\\{\} }
  \FV@UseVerbatim {
    \CDR_tag_get:c { format }
    \CDR_if_no_export:T {
      \CDR_tag_get:c { no~export~format }
    }
    \makeatletter
    \input{ \l_CDR_pyg_tex_tl }\ignorespaces
    \makeatother
  }
}
%    \end{MacroCode}
%
% \paragraph{Info}
%
%    \begin{MacroCode}
\cs_new:Npn \CDR@NumberFormat {
  \CDR_tag_get:c { numbers~format }
}
\cs_new:Npn \CDR@NumberSep {
  \hspace{ \CDR_tag_get:c { numbersep } }
}
\cs_new:Npn \CDR@TagsFormat {
  \CDR_tag_get:c { tags~format }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_info_N_L:n, \CDR_info_N_R:n,\CDR_info_T_L:n, \CDR_info_T_R:n}
% \begin{syntax}
% \cs{CDR_info_N_L:n} \Arg{line number}
% \cs{CDR_info_T_L:n} \Arg{line number}
% \end{syntax}
% Core methods to display the left and right information. The |T| variants contain
% tags informations, they are only used on the first line eventually.
% The |N| variants are for line numbers only.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_info_N_L:n #1 {
  \hbox_overlap_left:n {
    \cs_set:Npn \baselinestretch { 1 }
    { \CDR@NumberFormat
      #1
    }
    \CDR@NumberSep
  }
}
\cs_new:Npn \CDR_info_T_L:n #1 {
  \hbox_overlap_left:n {
    \cs_set:Npn \baselinestretch { 1 }
    \CDR@NumberFormat
    \smash{
    \parbox[b]{\marginparwidth}{
      \raggedleft
        { \CDR@TagsFormat \g_CDR_tags_clist :} 
      }
      #1
    }
    \CDR@NumberSep
  }
}
\cs_new:Npn \CDR_info_N_R:n #1 {
  \hbox_overlap_right:n {
    \CDR@NumberSep
    \cs_set:Npn \baselinestretch { 1 }
    \CDR@NumberFormat
    #1
  }
}
\cs_new:Npn \CDR_info_T_R:n #1 {
  \hbox_overlap_right:n {
    \cs_set:Npn \baselinestretch { 1 }
    \CDR@NumberSep
    \CDR@NumberFormat
    \smash {
      \parbox[b]{\marginparwidth}{
        \raggedright
        #1:
        {\CDR@TagsFormat \space \g_CDR_tags_clist} 
      }
    }
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR_number_alt:n}
% First line.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDR_number_alt:n #1 {
  \use:c { CDRNumber 
    \CDR_if_number_main:nTF { #1 } { Main } { Other }
  } { #1 }
}
\cs_set:Npn \CDR_number_alt: {
\CDR@Debug{ALT: \CDR_int_use:c { __n } }
  \CDR_number_alt:n { \CDR_int_use:c { __n } }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRNumberMain, \CDRNumberOther, \CDRIfLR}
% \begin{syntax}
% \cs{CDRNumberMain}  \Arg{integer expression}
% \cs{CDRNumberOther} \Arg{integer expression}
% \cs{CDRIfLR} \Arg{left commands} \Arg{right commands}
% \end{syntax}
% This is used when typesseting line numbers.
% The default |...Other| function just gobble one argument.
% The \metatt{integer expression} is exactly what will be displayed.
% The |\cs{CDRIfLR}| allows to format the numbers differently on the left and on the right.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRNumberMain {
  \use:n
}
\cs_new:Npn \CDRNumberOther {
  \use_none:n
}
%    \end{MacroCode}
%
% \begin{function}{\CDR@NumberMain, \CDR@NumberOther}
% \begin{syntax}
% \cs{CDR@NumberMain}
% \cs{CDR@NumberOther}
% \end{syntax}
% Respectively apply |\CDR@NumberMain| or |\CDR@NumberOther|
% on |\CDR_int_use:c { __n }|
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR@NumberMain {
  \CDRNumberMain { \CDR_int_use:c { __n } }
}
\cs_new:Npn \CDR@NumberOther {
  \CDRNumberOther { \CDR_int_use:c { __n } }
}
%    \end{MacroCode}
%
% \paragraph{Boxes for lines}
% The first index is for the tags (|L|, |R|, |N|, |S|, |M|),
% the second for the numbers (|L|, |R|, |N|).
% |L| stands for left, |R| stands for right, |N| stands for nothing,
% |S| stands for same side as numbers, |M| stands for mirror side of numbers.
% 
% \begin{function}{\CDR_line_[LRNSM]_[LRN]:nn}
% \begin{syntax}
% \cs{CDR_line_[LRNSM]_[LRN]:nn} \Arg{line number} \Arg{line content}
% \end{syntax}
% These functions may be called by |\CDR@Line| on each block.
% |LRNSO| corresponds to the |show tags| options
% whereas |LRN| corresponds to the |numbers| options.
% These functions display the first line and setup the next one.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_line_N_N:n {
\CDR@Debug {Debug.CDR_line_N_N:n}
  \CDR_line_box_N:n
}

\cs_new:Npn \CDR_line_L_N:n #1 {
\CDR@Debug {Debug.CDR_line_L_N:n}
  \CDR_line_box:nnn { \CDR_info_T_L:n { } } { #1 } { }
}

\cs_new:Npn \CDR_line_R_N:n #1 {
\CDR@Debug {Debug.CDR_line_R_N:n}
  \CDR_line_box:nnn { } { #1 } { \CDR_info_T_R:n { } }
}

\cs_new:Npn \CDR_line_S_N:n {
\CDR@Debug {Debug.CDR_line_S_N:n}
  \CDR_line_box_N:n
}

\cs_new:Npn \CDR_line_M_N:n {
\CDR@Debug {STEP:CDR_line_M_N:n}
  \CDR_line_box_N:n
}

\cs_new:Npn \CDR_line_N_L:n #1 {
\CDR@Debug {STEP:CDR_line_N_L:n}
  \CDR_if_no_number:TF {
    \CDR_line_box:nnn {
      \CDR_info_N_L:n { \CDR@NumberMain }
    } { #1 } {}
  } {
    \CDR_if_number_main:nTF { \CDR_int:c { __n } + 1 } {
      \CDR_line_box_L:n { #1 }
    } {
      \CDR_line_box:nnn {
        \CDR_info_N_L:n { \CDR@NumberMain }
      } { #1 } {}
    }
  }
}

\cs_new:Npn \CDR_line_L_L:n #1 {
\CDR@Debug {STEP:CDR_line_L_L:n}
  \CDR_if_number_single:TF {
    \CDR_line_box:nnn {
      \CDR_info_T_L:n { \space \CDR@NumberMain }
    } { #1 } {}
  } {
    \CDR_if_no_number:TF {
      \cs_set:Npn \CDR@@Line {
        \cs_set:Npn \CDR@@Line {
          \CDR_line_box_L:nn { \CDR_info_N_L:n { \CDR@NumberOther } }
        }
        \CDR_line_box_L:nn { \CDR_info_N_L:n { \CDR@NumberMain } }
      }
    } {
      \cs_set:Npn \CDR@@Line {
        \CDR_line_box_L:nn { \CDR_info_N_L:n { \CDR_number_alt: } }
      }
    }
    \CDR_line_box:nnn { \CDR_info_T_L:n { } } { #1 } { }
  }
}

\cs_new:Npn \CDR_line_R_R:n #1 {
\CDR@Debug {STEP:CDR_line_R_R:n}
  \CDR_if_number_single:TF {
    \CDR_line_box:nnn { } { #1 } {
      \CDR_info_T_R:n { \CDR@NumberMain }
    }
  } {
    \CDR_if_no_number:TF {
      \cs_set:Npn \CDR@@Line {
        \cs_set:Npn \CDR@@Line {
          \CDR_line_box_R:nn { \CDR_info_N_R:n { \CDR@NumberOther } }
        }
        \CDR_line_box_R:nn { \CDR_info_N_R:n { \CDR@NumberMain } }
      }
    } {
      \cs_set:Npn \CDR@@Line {
        \CDR_line_box_R:nn { \CDR_info_N_R:n { \CDR_number_alt: } }
      }
    }
    \CDR_line_box:nnn { } { #1 } { \CDR_info_T_R:n { } }
  }
}

\cs_new:Npn \CDR_line_R_L:n #1 {
\CDR@Debug {STEP:CDR_line_R_L:n}
  \CDR_line_box:nnn {
    \CDR_if_no_number:TF {
      \CDR_info_N_L:n { \CDR@NumberMain }
    } {
      \CDR_if_number_main:nTF { \CDR_int:c { __n } + 1 } {
        \CDR_info_N_L:n { \CDR_number_alt: }
      } {
        \CDR_info_N_L:n { \CDR@NumberMain }
      }
    }
  } { #1 } {
    \CDR_info_T_R:n { }
  }
}

\cs_set_eq:NN \CDR_line_S_L:n \CDR_line_L_L:n
\cs_set_eq:NN \CDR_line_M_L:n \CDR_line_R_L:n

\cs_new:Npn \CDR_line_N_R:n #1 {
\CDR@Debug {STEP:CDR_line_N_R:n}
  \CDR_if_no_number:TF {
    \CDR_line_box:nnn {} { #1 } {
      \CDR_info_N_R:n { \CDR@NumberMain }
    }
  } {
    \CDR_if_number_main:nTF { \CDR_int:c { __n } + 1 } {
      \CDR_line_box_R:n { #1 }
    } {
      \CDR_line_box:nnn {} { #1 } {
        \CDR_info_N_R:n { \CDR@NumberMain }
      }
    }
  }
}

\cs_new:Npn \CDR_line_L_R:n #1 {
\CDR@Debug {STEP:CDR_line_L_R:n}
  \CDR_line_box:nnn {
    \CDR_info_T_L:n { }
  } { #1 } {
    \CDR_if_no_number:TF {
      \CDR_info_N_R:n { \CDR@NumberMain }
    } {
      \CDR_if_number_main:nTF { \CDR_int:c { __n } + 1 } {
        \CDR_info_N_R:n { \CDR_number_alt: }
      } {
        \CDR_info_N_R:n { \CDR@NumberMain }
      }
    }
  }
}

\cs_set_eq:NN \CDR_line_S_R:n \CDR_line_R_R:n
\cs_set_eq:NN \CDR_line_M_R:n \CDR_line_L_R:n


\cs_new:Npn \CDR_line_box_N:n #1 {
\CDR@Debug {STEP:CDR_line_box_N:n}
  \CDR_line_box:nnn { } { #1 } {}
}

\cs_new:Npn \CDR_line_box_L:n #1 {
\CDR@Debug {STEP:CDR_line_box_L:n}
  \CDR_line_box:nnn {
    \CDR_info_N_L:n { \CDR_number_alt: }
  } { #1 } {}
}

\cs_new:Npn \CDR_line_box_R:n #1 {
\CDR@Debug {STEP:CDR_line_box_R:n}
  \CDR_line_box:nnn { } { #1 } { 
    \CDR_info_N_R:n { \CDR_number_alt: }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_line_box:nnn, \CDR_line_box_L:nn, \CDR_line_box_R:nn, \CDR_line_box:nn}
% \begin{syntax}
% \cs{CDR_line_box:nnn} \Arg{left info} \Arg{line content} \Arg{right info}
% \cs{CDR_line_box_L:nn} \Arg{left info} \Arg{line content}
% \cs{CDR_line_box_R:nn} \Arg{right info} \Arg{line content}
% \end{syntax}
% Returns an hbox with the given material.
% The first |LR| command is the reference, from which are derived the |L|, |R| and |N| commands.
% At run time the |\CDR_line_box:nn| is defined to call one of the above commands
% (with the same signature).
% \end{function}
%    \begin{MacroCode}
\tl_new:N \l_CDR_obey_tl
\tl_set:Nn \l_CDR_obey_tl { __i }
\cs_new:Npn \CDR_line_box:nnn #1 #2 #3 {
\CDR@Debug {\string\CDR_line_box:nnn/\tl_to_str:n{#1}/.../\tl_to_str:n{#3}/}
  \lua_now:e {
    CDR:synctex_target_set( \CDR_int_use:c { \l_CDR_obey_tl } )
  }
  \hbox to \hsize {
    \kern \leftmargin
    {
      \let\CDRIfLR\use_i:nn
      #1
    }
    \hbox to \linewidth {
      \FV@LeftListFrame
      #2
      \hss
      \FV@RightListFrame
    }
    {
      \let\CDRIfLR\use_ii:nn
      #3
    }
  }
  \ignorespaces
}
\cs_new:Npn \CDR_line_box_L:nn #1 #2 {
  \CDR_line_box:nnn { #1 } { #2 } {}
}
\cs_new:Npn \CDR_line_box_R:nn #1 #2 {
\CDR@Debug {STEP:CDR_line_box_R:nn}
  \CDR_line_box:nnn { } {#2} { #1 }
}
\cs_new:Npn \CDR_line_box_N:nn #1 #2 {
\CDR@Debug {STEP:CDR_line_box_N:nn}
  \CDR_line_box:nnn { } { #2 } {}
}
%    \end{MacroCode}
%
% \paragraph{Lines}
%
% \begin{function}{\CDR@Setup}
% \begin{syntax}
% \cs{CDR@Line} \Arg{kv list}
% \end{syntax}
% This is the very first command called when typesetting.
% \end{function}
%    \begin{MacroCode}
\keys_define:nn { CDR@Setup } {
  last         .code:n = \CDR_int_set:cn { __last } { #1 },
  synctex_tag  .code:n = \lua_now:n { CDR:synctex_tag_set( #1 ) },
  synctex_line .code:n = \lua_now:n { CDR:synctex_line_set( #1 ) },
}
\cs_new:Npn \CDR@Setup #1 {
\CDR@Debug {\string\CDR@Setup}
  \keys_set:nn { CDR@Setup } { #1 }
}
%    \end{MacroCode}
% \begin{function}{\CDR@Line}
% \begin{syntax}
% \cs{CDR@Line} \Arg{line index} \Arg{line content}
% \end{syntax}
% This is the very first command called when typesetting.
% Some setup are made for line numbering, in particular the |\CDR_if_visible_at_index:n...|
% family is set here.
% The first line must read |\CDR@Line[last=...]{1}{...}|,
% be it input from any |...pyg.tex| files or directly,
% like for \pkg{fancyvrb} usage.
% The line index refers to the lines in the source, what is displayed is a line number.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR@Line #1 {
\CDR@Debug {\string\CDR@Line}
  \CDR_if_number_on:TF {
    \CDR_int_set:cn { __n } { 1 }
    \CDR_int_set:cn { __i } { 1 }
%    \end{MacroCode}
% Set the first line number.
%    \begin{MacroCode}
    \CDR_int_set:cn { __start } { 1 }
    \CDR_if_tag_eq:cnTF { firstnumber } { last } {
      \clist_map_inline:Nn \g_CDR_tags_clist {
        \clist_map_break:n {
          \CDR_int_set:cc { __start } { ##1 }
\CDR@Debug {START: ##1=\CDR_int_use:c { ##1 } }
        }
      }
    } {
      \CDR_if_tag_eq:cnF { firstnumber } { auto } {
        \CDR_int_set:cn { __start } { \CDR_tag_get:c { firstnumber } }
      }
    }
%    \end{MacroCode}
% Make |__last| absolute only after defining the |\CDR_if_number_single...| conditionals.
%    \begin{MacroCode}
    \CDR_set_conditional:Nn \CDR_if_number_single: {
      \CDR_int_compare_p:cNn { __mini } = { \CDR_int:c { __maxi } }
    }
\CDR@Debug{****** TEST: \CDR_if_number_single:TF { SINGLE } { MULTI } }
    \CDR_int_add:cn { __last } { \CDR_int:c { __start } - 1 }
    \CDR_int_set:cn { __step } { \CDR_tag_get:c { stepnumber } }
\CDR@Debug {CDR_line:nnn:START/STEP/LAST=\CDR_int_use:c { __start }/\CDR_int_use:c { __step } /\CDR_int_use:c { __last }, #1}
%    \end{MacroCode}
% \begin{function}[EXP,pTF]{\CDR_if_visible_at_index:n}
% \begin{syntax}
% \cs{CDR_if_visible_at_index:nTF} \Arg{relative line number} \Arg{true code} \Arg{false code}
% \end{syntax}
% The \metatt{relative line number} is the first braced token after |\CDR@Line| in the
% various colored |...pyg.tex| files.
% Execute \metatt{true code} if the \metatt{relative line number} is visible, \metatt{false code} otherwise.
% The \metatt{relative line number} visibility depends on the value relative to first number and the step.
% This is relavant only when line numbering is enabled.
% Some setup are made for line numbering, in particular the |\CDR_if_visible_at_index:n...|.
% family is set here.
% \end{function}
%    \begin{MacroCode}
    \CDR_set_conditional_alt:Nn \CDR_if_visible_at_index:n {
      \CDR_if_number_visible_p:n { ##1 + \CDR_int:c { __start } - (#1) } 
    }
    \CDR_set_conditional_alt:Nn \CDR_if_number_visible:n {
      ! \CDR_int_compare_p:cNn { __last } < { ##1 } 
    }
    \CDR_int_compare:cNnTF { __step } < 2 {
      \CDR_int_set:cn { __step } { 1 }
      \CDR_set_conditional_alt:Nn \CDR_if_number_main:n {
        \CDR_if_number_visible_p:n { ##1 }
      }
    } {
      \CDR_set_conditional_alt:Nn \CDR_if_number_main:n {
        \int_compare_p:nNn {
          ( ##1 ) / \CDR_int:c { __step }  * \CDR_int:c { __step }
        } = { ##1 }
        && \CDR_if_number_visible_p:n { ##1 }
      }
    }
\CDR@Debug {\string\CDR@Line:STEP_1}
%    \end{MacroCode}
%    \begin{MacroCode}
    \CDR_set_conditional:Nn \CDR_if_no_number: {
      \CDR_int_compare_p:cNn { __start } > {
        \CDR_int:c { __last } / \CDR_int:c { __step } * \CDR_int:c { __step }
      }
    }
\CDR@Debug {\string\CDR@Line:STEP_2}
    \cs_set:Npn \CDR@Line ##1 {
\CDR@Debug {\string\CDR@Line(A), ##1, \CDR_int_use:c{__mini}, \CDR_int_use:c{__maxi}}
      \CDR_int_compare:cNnTF { __mini } > { ##1 } {
        \use_none:nn
      } {
        \CDR_int_compare:cNnTF { __maxi } < { ##1 } {
          \use_none:nn
        } {
          \CDR_int_set:cn { __i } { ##1 }
          \CDR_int_set:cn { __n } { ##1 + \CDR_int:c { __start } - (#1) }
          \tl_set:Nx \@currentlabel { \CDR_int_use:c { __n } }
          {
            \advance\interlinepenalty\widowpenalty
            \bool_if:nT {
              \CDR_int_compare_p:cNn { __n } = { \CDR_int:c { __mini } + 1 } ||
              \CDR_int_compare_p:cNn { __n } = { \CDR_int:c { __maxi } }
            } {
              \advance\interlinepenalty\clubpenalty
            }
            \penalty\interlinepenalty
          }
          \CDR@@Line
        }
      }
    }
 \CDR@Debug {\string\CDR@Line:STEP_3=(#1)}
   \CDR_int_set:cn { __n } { 1 + \CDR_int:c { __start } - (#1) }
 \CDR@Debug {\string\CDR@Line:STEP_4}
   \tl_set:Nx \@currentlabel { \CDR_int_use:c { __n } }
 \CDR@Debug {\string\CDR@Line:STEP_5}
  } {
\CDR@Debug {NUMBER~OFF}
    \cs_set:Npn \CDR@Line ##1 {
\CDR@Debug {\string\CDR@Line(B), ##1, \CDR_int_use:c{__mini}, \CDR_int_use:c{__maxi}}
      \CDR_int_compare:cNnTF { __mini } > { ##1 } {
        \use_none:nn
      } {
        \CDR_int_compare:cNnTF { __maxi } < { ##1 } {
          \use_none:nn
        } {
          \CDR@@Line
        }
      }
    }
  }
\CDR@Debug {\string\CDR@Line == STEP_S, \CDR_int_use:c {__step}, \CDR_int_use:c {__last} }
%    \end{MacroCode}
% Convenient method to branch whether one line number will be displayed or not,
% considering the stepping.
% When numbering is on, each code chunk must have at least one number.
% One solution is to allways display the first one but it is not satisfying
% when lines are numbered stepwise, moreover when the tags should be displayed.
%    \begin{MacroCode}
  \tl_clear:N \l_CDR_a_tl
  \CDR_if_already_tags:TF {
    \tl_put_right:Nn \l_CDR_a_tl { _N }
  } {
    \exp_args:Nx
    \str_case:nnF { \CDR_tag_get:c { show~tags } } {
      { left  } { \tl_put_right:Nn \l_CDR_a_tl { _L } }
      { right } { \tl_put_right:Nn \l_CDR_a_tl { _R } }
      { none  } { \tl_put_right:Nn \l_CDR_a_tl { _N } }
      { dry   } { \tl_put_right:Nn \l_CDR_a_tl { _N } }
      { same  } { \tl_put_right:Nn \l_CDR_a_tl { _S } }
      { mirror  } { \tl_put_right:Nn \l_CDR_a_tl { _M } }
    } { \PackageError
          { coder }
          { Unknown~show~tags~options~:~ \CDR_tag_get:c { show~tags } }
          { See~the~coder~manual }
    }
  }
%    \end{MacroCode}
% By default, the next line is displayed with no tag, but the real content may
% change to save space.
%    \begin{MacroCode}
  \exp_args:Nx
  \str_case:nnF { \CDR_tag_get:c { numbers } } {
    { left  } {
      \tl_put_right:Nn \l_CDR_a_tl { _L }
      \cs_set:Npn \CDR@@Line { \CDR_line_box_L:n }
    }
    { right } {
      \tl_put_right:Nn \l_CDR_a_tl { _R }
      \cs_set:Npn \CDR@@Line { \CDR_line_box_R:n }
    }
    { none  } {
      \tl_put_right:Nn \l_CDR_a_tl { _N }
      \cs_set:Npn \CDR@@Line { \CDR_line_box_N:n }    
    }
  } { \PackageError
        { coder }
        { Unknown~numbers~options~:~ \CDR_tag_get:c { numbers } }
        { See~the~coder~manual }
  }
\CDR@Debug {\string\CDR@Line == BRANCH:CDR_line \l_CDR_a_tl :n}
  \CDR_int_compare:cNnTF { __mini } > { 1 } {
    \use_none:n
  } {
    \CDR_int_compare:cNnTF { __maxi } < { 1 } {
      \use_none:n
    } {
      \use:c { CDR_line \l_CDR_a_tl :n }
     }
  }
}
%    \end{MacroCode}
%
% \subsubsection{\pkg{fancyvrb} only}
%
% \pkg{pygments} is not used, fall back to \pkg{fancyvrb} features.
%
% \begin{function}{CDRBlock_use_fv:c}
% \begin{syntax}
% \cs{CDRBlock@Fv}
% \end{syntax}
% \end{function}
%    \begin{MacroCode}
\tl_new:N \l_CDR_delimiters_tl
\cs_new_protected:Npn \CDRBlock_use_fv:c #1 {
\CDR@Debug {\string\CDRBlock_use_fv:c}
  \CDR_tag_get:cN { format } \l_CDR_vrb_tl
  \CDR_if_no_export:T {
    \CDR_tag_get:cN { no~export~format } \l_CDR_a_tl
    \tl_put_right:NV \l_CDR_vrb_tl \l_CDR_a_tl
  }
  \tl_put_right:Nn \l_CDR_vrb_tl \CDR@Setup
  \cs_set:Npn \CDR:n ##1 {
    \tl_put_right:Nn \l_CDR_vrb_tl { { ##1 } }
  }
  \exp_args:Nx \CDR:n {
    last = \seq_count:c { #1_seq },
    synctex_tag  = \prop_item:cn { #1_prop } { synctex_tag  },
    synctex_line = \prop_item:cn { #1_prop } { synctex_line },
  }
\CDR@Debug{\string\CDRBlock_use_fv:c\space 11}
  \CDR_if_tag_truthy:cTF { texcomments } {
\CDR@Debug{\string\CDRBlock_use_fv:c\space 111}
    \CDR_if_tag_eq:cnTF { lang } { tex } {
\CDR@Debug{\string\CDRBlock_use_fv:c\space 1111}
      \seq_map_indexed_inline:cn { #1_seq } {
        \tl_put_right:Nn \l_CDR_vrb_tl {
          \CDR@Line { ##1 } { ##2 }
        }
      }
    } {
\CDR@Debug{\string\CDRBlock_use_fv:c\space 1112}
      \regex_set:Nx \l_CDR_regex { ^ (.*?) ( \c_percent_str .* ) }
      \cs_set:Npn \CDR:nnn ##1 ##2 ##3 {
        \tl_put_right:Nn \l_CDR_vrb_tl {
          \CDR@Line
            { ##1 }
            { ##2 \CDR@@Comment { ##3 } }
        }
      }
      \seq_map_indexed_inline:cn { #1_seq } {
        \regex_extract_once:NnNTF \l_CDR_regex { ##2 } \l_CDR_seq {
          \exp_args:Nnff
          \CDR:nnn { ##1 }
            { \seq_item:Nn \l_CDR_seq 1 }
            { \seq_item:Nn \l_CDR_seq 2 }
        } {
          \tl_put_right:Nn \l_CDR_vrb_tl {
            \CDR@Line { ##1 } { ##2 }
          }
        }
      }
    }
  } {
\CDR@Debug{\string\CDRBlock_use_fv:c\space 112}
    \CDR_tag_get:cN { escapeinside } \l_CDR_delimiters_tl
    \int_compare:nNnTF { \tl_count:N \l_CDR_delimiters_tl } = 2 {
\CDR@Debug{\string\CDRBlock_use_fv:c\space 1121}
      \regex_set:Nx \l_CDR_regex {
        [ \tl_item:Nn \l_CDR_delimiters_tl { 1 } ]
        (.*?) [ \tl_item:Nn \l_CDR_delimiters_tl { 2 } ]
      }
\CDR@Debug{\string\CDRBlock_use_fv:c\space 1121a}
      \seq_map_indexed_inline:cn { #1_seq } {
        \tl_put_right:Nn \l_CDR_vrb_tl {
          \CDR@Line { ##1 }
        }
        \CDR_rescan_regex_split:NNn
          \l_CDR_regex \l_CDR_export_tl { ##2 }
        \exp_args:NV \CDR:n \l_CDR_export_tl
      }
\CDR@Debug{\string\CDRBlock_use_fv:c\space 1121b}
    } {
      \int_compare:nNnTF { \tl_count:N \l_CDR_delimiters_tl } = 3 {
\CDR@Debug{\string\CDRBlock_use_fv:c\space 11221}
        \regex_set:Nx \l_CDR_regex {
          [ \tl_item:Nn \l_CDR_delimiters_tl { 1 } ]
          (.*?) [ \tl_item:Nn \l_CDR_delimiters_tl { 2 } ]
          .*? [ \tl_item:Nn \l_CDR_delimiters_tl { 3 } ]
        }
        \seq_map_indexed_inline:cn { #1_seq } {
          \tl_put_right:Nn \l_CDR_vrb_tl {
            \CDR@Line { ##1 }
          }
          \CDR_rescan_regex_split:NNn
            \l_CDR_regex \l_CDR_export_tl { ##2 }
          \exp_args:NV \CDR:n \l_CDR_export_tl
        }
      } {
\CDR@Debug{\string\CDRBlock_use_fv:c\space 11222}
        \seq_map_indexed_inline:cn { #1_seq } {
          \tl_put_right:Nn \l_CDR_vrb_tl {
            \CDR@Line { ##1 } { ##2 }
          }
        }
      }
    }
  }
\CDR@Debug{\string\CDRBlock_use_fv:c,\exp_args:NV \tl_to_str:n \l_CDR_vrb_tl}
  \FV@UseVerbatim {
    \l_CDR_vrb_tl
  }
\CDR@Debug {\string\CDRBlock_use_fv:c...DONE}
}
%    \end{MacroCode}
%
% \subsubsection{Utilities}
%
% This is put aside for better clarity.
%
% \begin{function}{\CDR_if_middle_column:, \CDR_if_right_column:}
% \begin{syntax}
% \cs{CDR_int_if_middle_column:TF} \Arg{true code} \Arg{false code}
% \cs{CDR_int_if_right_column:TF} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when in the middle or right column,
% \metatt{false code} otherwise.
% \end{function}
%    \begin{MacroCode}
\prg_set_conditional:Nnn \CDR_if_middle_column: { p, T, F, TF } { \prg_return_false: }
\prg_set_conditional:Nnn \CDR_if_right_column:  { p, T, F, TF } { \prg_return_false: }
%    \end{MacroCode}
%
% Various utility conditionals: their purpose is to clarify the code.
% They are available in the |CDRBlock| environment only.
% \begin{function}[EXP,pTF]{\CDR_if_tags_visible:n}
% \begin{syntax}
% \cs{CDR_if_tags_visible:nTF} \Arg{left$\vert$right} \Arg{true code} \Arg{false code}
% \end{syntax}
% \end{function}
% Whether the tags should be visible, at the left or at the right.
%    \begin{MacroCode}
\prg_set_conditional:Nnn \CDR_if_tags_visible:n { p, T, F, TF } {
  \bool_if:nTF {
    ( \CDR_if_tag_eq_p:cn { show~tags } { ##1 } ||
      \CDR_if_tag_eq_p:cn { show~tags } { same } &&
      \CDR_if_tag_eq_p:cn { numbers } { ##1 }
    ) && ! \CDR_if_already_tags_p:
  } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_tags_setup:N, \CDRBlock_engine_setup:N}
% Utility to setup the tags, the tag inheritance tree and the engine.
% When not provided explicitly with the |tags=...| user interface,
% a code chunk will have the list of tags stored in |\g_CDR_tags_clist|
% by last |\CDRExport|, |\CDRSet| or |\CDRBlock| environment.
% At least one tag must be provided, either implicitly or explicitly.
% \end{function}
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRBlock_tags_setup:N #1 {
\CDR@Debug{ \string \CDRBlock_tags_setup:N, \string #1 }
  \CDR_local_inherit:n { __tags }
  \CDR_local_set_known:N #1
  \CDR_if_tag_exist_here:ccT { __local } { tags } {
    \CDR_tag_get:cN { tags } \l_CDR_clist
    \clist_if_empty:NF \l_CDR_clist {
      \clist_gset_eq:NN \g_CDR_tags_clist \l_CDR_clist
    }
  }
  \clist_if_empty:NT \g_CDR_tags_clist {
    \CDR_tag_get:cN { defaulft~tags } \g_CDR_tags_clist {
      \PackageWarning
        { coder }
        { No~default~tags~provided. }
    }
  }
\CDR@Debug {CDRBlock_tags_setup:N\space\g_CDR_tags_clist}
%    \end{MacroCode}
% Setup the inheritance tree for the |\CDR_tag_get:...| related functions.
%    \begin{MacroCode}
  \CDR_get_inherit:f {
    \g_CDR_tags_clist,
    __block, __tags, __engine, default.block, __pygments.block,
    __fancyvrb.block, __fancyvrb.frame, __fancyvrb.number,
    __pygments, default, __fancyvrb,
  }
%    \end{MacroCode}
% For each \metatt{tag name}, create an \pkg{l3int} variable and initialize it to 1.
%    \begin{MacroCode}
  \clist_map_inline:Nn \g_CDR_tags_clist {
    \CDR_int_if_exist:cF { ##1 } {
      \CDR_int_new:cn { ##1 } { 1 }
    }
  }
}
%    \end{MacroCode}
% Now setup the engine options if any.
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRBlock_engine_setup:N #1 {
\CDR@Debug{ \string \CDRBlock_engine_setup:N, \string #1 }
  \CDR_local_inherit:n { __engine }
  \CDR_local_set_known:N #1
  \CDR_tag_get:cNT { engine } \l_CDR_a_tl {
    \clist_put_left:Nx #1 { \CDRBlock_options_use:V \l_CDR_a_tl }
  }
}
%    \end{MacroCode}
%
% \section{Management}
%
% \begin{variable}{\g_CDR_in_impl_bool}
% Whether we are currently in the implementation section.
%    \begin{MacroCode}
\bool_new:N \g_CDR_in_impl_bool
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}[EXP,pTF]{\CDR_if_show_code:}
%   \begin{syntax}
%     \cs{CDR_if_show_code:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when code should be printed, \meta{false code} otherwise.
%    \begin{MacroCode}
%</sty>
%<*driver-lua>
--[=[!latex:\begin{module}
This is lua driver for the \pkg{coder} package.
Pretty print documentation formatted in \LaTeX\ that is delimited by special
comment markers. The beginning of a documentation block is delimited by
\CDRCode[lang=lua]|^--[(=*)[!latex:|
which must start a line and the next
\CDRCode|--](\metatt{equals})]|
where \metatt{equals} represents the previously capture group.

The delimiters are removed and what is delimited is typeset with \LaTeX{}.

See the \CDRCode|\CDRInput| documentation.
--]=]
-- put here whatever statement you need
-- return a table
return {
  open = function (self, line)
    local equals, i = line:match(
      '^%-%-%[(=*)%[!latex:'--]--]
    )
    if equals then--[--[
      local pattern = '^%]'..equals..'%]'
      self.close = function (this, l)
        return l:match(pattern) ~= nil
      end
      return true
    end
  end,
}
%    \end{MacroCode}
% \end{function}
%
% \subsection{Options}
% The options will inherit the |__tags| \pkg{l3keys} module.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { CDRInput } {
%    \end{MacroCode}
% \begin{description}
%
% \itemtt[\CDRCheckGreen driver=\metatt{driver name}$\vert$\metatt{driver path}]^^A
% When the driver has a path extension, this is the path
% to a driver, otherwise this is a builtin driver name.
% Some builtin drivers are provided
% and generally named after a programming language.
% Initially |raw|, which means that the file is input as one uncommented code snippet.
% Let's hope that no language will ever be named |raw|.
%    \begin{MacroCode}[OK]
  driver .code:n = \CDR_tag_set:,
  driver .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed show code{[=true$\vert$false]}]^^A
% whether code should be displayed.
% Initially |true|.
%    \begin{MacroCode}[OK]
  show~code .code:n = \CDR_tag_boolean_set:x { #1 },
  show~code .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed show doc{[=true$\vert$false]}]^^A
% whether doc should be displayed.
% Initially |true|.
%    \begin{MacroCode}[OK]
  show~doc .code:n = \CDR_tag_boolean_set:x { #1 },
  show~doc .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    driver    = raw,
    show~code = true,
    show~doc  = true,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\AtBeginDocument{
  \CDR_tag_keys_set:nn { CDRInput } { __initialize }
}
%    \end{MacroCode}
% \end{variable}
%
% \section{Section separators}
% \begin{function}{\CDRImplementation,\CDRFinale}
% \begin{syntax}
% \cs{CDRImplementation}
% \cs{CDRFinale}
% \end{syntax}
% \cs{CDRImplementation} start an implementation part
% where all the sectioning commands do nothing,
% whereas \cs{CDRFinale} stop an implementation part.
% \end{function}
% \section{Finale}
%    \begin{MacroCode}
\tl_new:N \l_CDR_input_tl
\NewDocumentCommand\CDRInput { O{} m } {
\CDR@Debug{\string\CDRInput}
  \group_begin:
  \directlua { CDR:synctex_tag_will_catch() }
  \input{#2}
  \tl_set:Nn \l_CDR_input_tl { #2 }
  \CDR_local_inherit:n { CDRInput }
  \CDR_local_set_known:nN { #1 } \l_CDR_kv_clist
  \CDR_get_inherit:n { CDRInput }
  \CDR_tag_get:cN { driver } \l_CDR_a_tl
  \directlua { CDR:input_begin() }
  \CDR_tag_get:cN { show~code } \l_CDR_a_tl
  \directlua { CDR:input_set_boolean('show_code') }
  \CDR_tag_get:cN { show~doc } \l_CDR_a_tl
  \directlua { CDR:input_set_boolean('show_doc') }
  \exp_args:NNNV
  \group_end:
  \clist_set:Nn \l_CDR_kv_clist \l_CDR_kv_clist
  \directlua { CDR:input() }
  \directlua { CDR:input_end() }
}
%    \end{MacroCode}
%    \begin{MacroCode}

\ExplSyntaxOff

%    \end{MacroCode}  
%
% Input a configuration file named \texttt{\jobname.cfg}, if any.
%    \begin{MacroCode}
\AtBeginDocument{
  \InputIfFileExists{coder.cfg}{}{}
}
%</sty>
%    \end{MacroCode}
% \end{implementation}
%\Finale
%
% % ^^A \PrintIndex
