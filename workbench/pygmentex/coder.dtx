% \iffalse meta-comment
% !TEX program  = lualatex
% !TEX encoding  = utf8
%<*internal>
\iffalse
%</internal>
%<*readme>
# The coder package

This package allows to format in \LaTeX\ the documentation put in the code,
as soon as long comments exist. It also allows to work the other way round
by putting code inside the documentation.
This is particularly interesting when different code files share some logic
and should be documented all at once.

The file coder-manual.pdf gives different examples.

The file coder-beamer.pdf gives a demo of what can be achieved with beamer.

This LaTeX package requires LuaTeX and may use syntax coloring based on the pygments package.

----------------------------------------------------------------
coder --- description text
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\def\MetaPrefix{}
\declarepreamble\PreambleRaw
----------------------------------------------------------------
\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/coder
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\def\MetaPrefix{--}
\declarepreamble\PreambleLua

\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/coder
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt

\endpreamble
{
\catcode`\#=11
\global\def\MetaPrefix{#}
}
\declarepreamble\PreamblePy

\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/coder
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt

\endpreamble

\edef\PreamblePy {%
\MetaPrefix!/usr/bin/env python3^^J\MetaPrefix\space -*- coding: utf-8 -*-^^J\PreamblePy
}

\def\MetaPrefix{\DoubleperCent}
\declarepreamble\PreambleSty
\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later

Copyright (C) 2022 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  \jobname.dtx
and the derived files           \jobname.ins,
                                \jobname.pdf,
                                \jobname-util.lua,
                                \jobname-driver-raw.lua,
                                \jobname-driver-c.lua,
                                \jobname-driver-py.lua,
                                \jobname-driver-lua.lua,
                                \jobname-tool.py and
                                \jobname.sty.

\endpreamble
\nopostamble
\usedir{tex/latex/coder}
\usepreamble\PreambleSty
\def\MetaPrefix{\DoubleperCent}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{sty}}
}
\usepreamble\PreambleLua
\def\MetaPrefix{--}
\usedir{scripts/coder}
\generate{
  \file{\jobname-util.lua}{\from{\jobname.dtx}{lua}}
}
\generate{
  \file{\jobname-driver-raw.lua}{\from{\jobname.dtx}{driver-raw}}
}
\generate{
  \file{\jobname-driver-c.lua}{\from{\jobname.dtx}{driver-c}}
}
\generate{
  \file{\jobname-driver-py.lua}{\from{\jobname.dtx}{driver-py}}
}
\generate{
  \file{\jobname-driver-lua.lua}{\from{\jobname.dtx}{driver-lua}}
}
\usepreamble\PreamblePy
{
\catcode`\#=11
\global\def\MetaPrefix{#}
}
\usedir{scripts/coder}
\generate{
  \file{\jobname-tool.py}{\from{\jobname.dtx}{py}}
}
\nopreamble\nopostamble
\usedir{doc/latex/coder}
\generate{
  \file{README.md}{\from{\jobname.dtx}{readme}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/coder}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*driver,sty>
\def\CDRFileDate{2022/02/07}
\def\CDRFileVersion{1.0a}
%</driver,sty>
%<*sty>
\ProvidesExplPackage{coder}
  {\CDRFileDate}
  {\CDRFileVersion}
  {code inside LaTeX, LaTeX inside code}

\NeedsTeXFormat{LaTeX2e}
\ExplSyntaxOff

\RequirePackage{xcolor}
\RequirePackage{luatexbase}
\AddToHook { begindocument / before } {
  \RequirePackage{datetime2}
}
\ExplSyntaxOn
\msg_new:nnn { coder } { :n } { #1 }
\cs_if_exist:NTF\IfFormatAtLeastTF {
  \IfFormatAtLeastTF{2021/06/01} {} {
    \msg_fatal:nnn { coder } { :n } { Please~update~LaTeX.~Emergency~stop }
  }
} {
  \msg_fatal:nnn { coder } { :n } { Please~update~LaTeX.~Emergency~stop }
}
%</sty>
%<*driver>
\ExplSyntaxOff
\documentclass{l3doc}
\RequirePackage{fancyvrb}
\RequirePackage{emoji}
%\RequirePackage{unicode-math}
%\setmathfont{Latin Modern Math}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\newcommand{\lua} {\pkg{lua}}
\newcommand{\CDRSty}{\pkg{\jobname.sty}}
\newcommand{\CDRLua}{\pkg{\jobname-util.lua}}
\newcommand{\CDRPy} {\pkg{\jobname-tool.py}}
\newcommand{\metatt} [1] {\texttt{\meta{#1}}}
\ExplSyntaxOn
\NewDocumentCommand\CDRCheckGreen{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{check-mark-button}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckRed{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{stop-sign}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckOrange{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{white-question-mark}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckProhibited{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{prohibited}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckInternal{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{gear}}
  \ttfamily\hspace{#1}\vphantom{.}
}}

\makeatletter
\@addtoreset{FancyVerbLine}{part}
\ExplSyntaxOn
\define@booleankey{FV}{OK}
  {\def\DCR@possibly@in@progress{\color{gray}}}
  {\def\DCR@possibly@in@progress{\color{red}}}
\define@booleankey{FV}{construction}
  {\def\DCR@possibly@in@progress{\color{red}}}
  {\def\DCR@possibly@in@progress{\color{gray}}}
\fvset{construction}
\def\FVB@MacroCode{
  \@bsphack
  \FV@VerbatimBegin
  \renewcommand{\theFancyVerbLine}{{
    \DCR@possibly@in@progress
    \scriptsize
    \arabic{FancyVerbLine}
  }}
  \FV@Scan
}
\def\FVE@MacroCode{
  \FV@VerbatimEnd
  \@esphack
}
\ExplSyntaxOff
\DefineVerbatimEnvironment{MacroCode}{MacroCode}{
  numbers=left,
  resetmargins=true,
  firstnumber=last,
  gobble=0,
  numbersep=1ex,
  fontsize=\small,
}

\newcommand{\CDRPygVerbatim} {CDR@Pyg@Verbatim}
\makeatother
\NewDocumentCommand \itemtt { o }{^^A
  \IfNoValueTF { #1 } {
    \item
  } {
    \item[\ttfamily#1]
  }
}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%\title{^^A
%  \pkg{\jobname}\\
% \LaTeX\ inside code\\
% code inside \LaTeX}
%\author{^^A
%  Jérôme LAURENS\thanks{E-mail: jerome.laurens@u-bourgogne.fr}^^A
%}
%\date{Released \CDRFileDate\thanks{This file describes version \CDRFileVersion.}}
%
%\maketitle
%
% \begin{documentation}
%
%\changes{v1.0a}{2022/01/20}{First public release}
%
% \begin{abstract}
% Usually, the documentation is put inside the code,
% with a limited formatting.
% \pkg{\jobname} allows to interpret and manage this
% documentation as \LaTeX\ input.
% \pkg{\jobname} also allows to work the other way round
% by putting code inside the documentation.
% This is particularly interesting when different code files share some logic
% and should be documented all at once.
%
% The file \url{coder-manual.pdf} gives different examples. Here is the implementation of the package.
%
% This \LaTeX{} package requires \LuaTeX{} and may use syntax coloring based on the \pkg{pygments}\footnote{The \pkg{\jobname} package has been tested with \pkg{pygments} version 2.11.2} package.
% \end{abstract}
%
% \section{Package dependencies}
% \pkg{luatexbase}, \pkg{datetime2}, \pkg{xcolor} and dependencies of these packages.
%
% \section{Similar technologies}
% \begin{description}
% \item The \pkg{docstrip} utility offers similar features,
% it is on some respect more powerful than \pkg{\jobname} at the cost of
% more technicality and less practicality,
% \item The \pkg{ydoc.cls} and \pkg{skdoc.cls} are
% full document classes with some similar features but
% many more that are unrelated.
% \pkg{\jobname} focuses on code inlining and interfaces very well with \pkg{pygments}
% for a smart and efficient syntax hilighting.
% \item The \pkg{pygmentex} and \pkg{minted} packages were somehow source of inspiration.
% \item The \pkg{listings} and \pkg{fancyvrb} packages must be mentionned.
% \end{description}
%
% \section{Known bugs and limitations}
% \begin{itemize}
% \item
% \pkg{\jobname} does not play well with \pkg{docstrip}.
% \end{itemize}
%
% \end{documentation}
% 
% \begin{implementation}
%
% \section{Presentation}
% \pkg{\jobname} is a triptych of three complementary components
% \begin{enumerate}
% \item \CDRSty, on the \LaTeX{} side,
% \item \CDRLua, to manage some data and call \CDRPy,
% \item \CDRPy, to color code with the help of \pkg{pygments}.
% \end{enumerate}
% \CDRSty{} mainly declares the \cs{CDRCode} command and the |CDRBlock| environment.
% The former allows to insert code chunks as running text whereas the latter allows
% to instert code snippets as blocks.
% For multiple use in \pkg{beamer} for example,
% we have \cs{CDRCodeSave} and \cs{CDRCodeUse}
% as well as |CDRBlockSave| environment and \cs{CDRBlockUse}.
% Moreover, block code chunks can be exported to files, once declared with \cs{CDRBlockExport} command.
% The \cs{CDRSet} command is used to set various parameters,
% including display engines declared with either \cs{CDRCodeEngineNew} or \cs{CDRBlockEngineNew}\footnote{Work in progress}.
% Finally, the \cs{CDRBlockImport} command is used to include source files
% and typeset with \LaTeX\ the embedded documentation.
%
% \subsection{Code flow}
% The normal code flow of syntax highlighting is
% \begin{enumerate}
% \item from \CDRSty{}, \LaTeX{} parses a code snippet as |\CDRCode| argument
% of |CDRBlock| environment body, somehow stores it,
% and calls |CDR.|\metatt{Object}|:pyg_source| where
% \metatt{Object} is one of |Block| or |Code|,
% \item \CDRLua{} reads the content of some command, and stores it in a |json| file,
% together with informations to process this code snippet properly,
% \item \CDRPy{} is then asked by \CDRLua{} to read the |json| file and eventually uses \pkg{pygments} to translate
% the code snippet into dedicated \LaTeX{} coloring commands.
% These are stored in a |*.pyg.tex| file
% named after the md5 digest of the original code chunck,
% a |*.pyg.sty| \LaTeX{} style file is recorded as well.
% On return, \CDRSty{} is able to input both the |*.pyg.sty| and
% the |*.pyg.tex| file, which are finally executed and the code is displayed with colors.
% \CDRPy{} is also partially responsible of code line numbering
% in conjunction with \CDRSty{}.
% \end{enumerate}
%
% The package \CDRSty{} only exchanges with \CDRLua{} using |\directlua|, |tex.print|, |tex.sprint|,
% |token.get_macro| and |token.set_macro|.
% \CDRPy{} in turn only exchanges with \CDRLua{}:
% we put in \CDRPy{} as few \LaTeX{} logic as possible.
% It receives instructions from \CDRSty{} as command line arguments,
% \LaTeX{} options, \pkg{pygments} options and \pkg{fancyvrb} options.
%
% \subsection{File exportation}
% \begin{enumerate}
% \item
% The \cs{CDRBlockExport} command declares a file path, a list of tags and other
% usefull informations like a coding language. These data are saved as export records
% by \CDRLua.
% \item
% When some |tags={...}| have been given to the |CDRBlock| environment,
% the \CDRLua{} records the corresponding code chunk and its associate tags for
% later save. 
% \item
% Once the typesetting process is complete, \CDRLua{}'s |CDR_export_...| methods
% are called to save all the files externally. For each export record,
% \CDRLua{} collects all the chunks with the same tag and save them
% at the proper location.
% \end{enumerate}
%
% \subsection{Display engine}
% The display management is partly delegated to other packages.
% \CDRSty{} provides default engines for running code and code blocks,
% and new engines can be declared with \cs{CDRCodeEngineNew}
% and \cs{CDRBlockEngineNew}.
% 
% \subsection{\LaTeX{} user interface}
% The first required argument of both commands and environment
% is a \metatt{key[=value] controls} list managed by \pkg{l3keys}.
% Each command requires its own \pkg{l3keys} module but some
% \metatt{key[=value] controls} are shared between modules.

% \subsection{Properties and inheritance}
% Properties cover various informations, from the language of the code,
% to the color and font. They are uniquely identified by a path component,
% the \emph{tag}, which is used for inheritance. All tags starting with
% two leading underscore characters are reserved by the package.
% Other tags are at the user disposal.
%
% Each processed code chunk has a list of associate tags.
% Most tag inherits from default ones.
%
% \section{Namespace and conventions}
% \LaTeX{} identifiers related to \pkg{\jobname} start with |CDR|,
% including both commands and evironment.
% \pkg{expl3} identifiers also start with |CDR|, after and eventual leading |c_|, |l_| or |g_|.
% \pkg{l3keys} module path's first component is either |CDR|
% or starts with |CDR@|.
% Commands related to inline code contain |CDRCode| in their name,
% whereas commands related to block code contain |CDRBlock| in
% their names.
% When a name contains |_pyg_| it is related to \pkg{pygments},
% there is a |_vrb_| counterpart used with no \pkg{pygments}.
% Both are equivalent except in a small area.
%
% \lua{} objects (functions and variables) are collected
% in the \texttt{CDR} table automatically created
% while loading \CDRLua{} from \CDRSty{}.
%
% The |c| argument specifier is used here in a more general acception.
% Normaly , it means that the argument is turned to a command sequence name.
% Here, it means that the argument is part of something bigger
% which is turned to a command sequence name.
% As such, there is no need to explictly expand such an argument.
%
% \section{Options}
% Key-value options allow the user, \CDRSty{}, \CDRLua{} and \CDRPy{} to exchange
% data. What the user is allowed to do is illustrated in \url{coder-manual.pdf}.
%
% \part{\CDRLua{} implementation}
% \section{Usage}
% This \texttt{lua} library is loaded by \CDRSty{}
% with instruction |CDR=require("\jobname-util")|.
% In the sequel, the syntax to call class methods and instance methods are
% presented with either a \texttt{CDR.} or a \texttt{CDR:} prefix.
% This is what is used in the library for convenience.
% Of course either a \texttt{self.} or a \texttt{self:} prefix would be possible.
%
% \section{Declarations}
%    \begin{MacroCode}[OK]
%<*lua>
local lfs   = _ENV.lfs
local tex   = _ENV.tex
local token = _ENV.token
local md5   = _ENV.md5
local kpse  = _ENV.kpse
local rep   = string.rep
local json  = require('lualibs-util-jsn')
local ltb = _ENV.luatexbase
local ltb_add_to_callback      = ltb.add_to_callback
local ltb_remove_from_callback = ltb.remove_from_callback
local lpeg  = require("lpeg")
local C       = lpeg.C
local Cg      = lpeg.Cg
local Cp      = lpeg.Cp
local Ct      = lpeg.Ct
local P       = lpeg.P
local V       = lpeg.V
%    \end{MacroCode}
% \section{Module declaration}
%    \begin{MacroCode}[OK]
ltb.provides_module{
  name = 'coder',
  date = token.get_macro('CDRFileDate'),
  version = token.get_macro('CDRFileVersion'),
  description = 'Code inside LaTeX, LaTeX inside code',
}
%    \end{MacroCode}
% \begin{variable}{CDR}
% This is the main object.
% The return module is based on it.
%    \begin{MacroCode}
local CDR = {}
local TEST = {}
%    \end{MacroCode}
% \end{variable}
%
% \section{Utf8 support}
% The \pkg{lpeg} related material will eventually end up
% as a separate library.
%    \begin{MacroCode}[OK]
local utf8  = _ENV.unicode.utf8
%    \end{MacroCode}
%
% \section{General purpose material}
% \begin{variable}{CDR_PY_PATH}
% Location of the \CDRPy{} utility.
% This will cause an error if |kpsewhich| is not available.
% The |PATH| must be properly set up.
%    \begin{MacroCode}[OK]
local PYTHON_PATH, PYGMENTIZE_PATH
local CDR_PY_PATH = kpse.find_file('coder-tool.py')
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{debug_msg, activate_debug}
% \begin{syntax}
% CDR:activate_debug(\meta{boolean})
% debug_msg(...)
% \end{syntax}
% Activate debuging messaging, or not.
% \end{function}
%    \begin{MacroCode}[OK]
local function f_noop (...)
end
local debug_msg = f_noop
local function f_debug_msg (...)
  local s = token.get_macro('CurrentFile')
  if #s == 0 then
    s = tex.jobname
  end
  print('*--* CDR:'..s..':'..tostring(tex.inputlineno)..':', ...)
end
TEST.debug_msg = function(...)
  debug_msg(...)
end
function CDR:activate_debug(yorn)
  if yorn then
    debug_msg = f_debug_msg
  else
    debug_msg = f_noop
  end
end
function CDR:activate_test(yorn)
  if yorn then
    self.TEST = TEST
  else
    self.TEST = nil
  end
end
function CDR.debug(...)
  debug_msg(...)
end
%    \end{MacroCode}
%
% \begin{function}{print_now, sprint_now}
% \begin{syntax}
% CDR.print_now(\meta{tex.print arguments})
% \end{syntax}
% Print now through |tex.runtoks|.
% \end{function}
%    \begin{MacroCode}[OK]
function CDR.print_now(...)
  local args = {...}
  tex.runtoks(function ()
    tex.print(table.unpack(args))
  end)
end
function CDR.sprint_now(...)
  local args = {...}
  tex.runtoks(function ()
    tex.sprint(table.unpack(args))
  end)
end
%    \end{MacroCode}
%
% \begin{function}{run_toks}
% \begin{syntax}
% CDR.run_toks(\meta{tokens}[, \meta{cctab number}])
% \end{syntax}
% Shortcut to |tex.runtoks|.
% The \metatt{tokens} are parsed with category code table
% \metatt{cctab number} or the current one.
% \end{function}
%    \begin{MacroCode}[OK]
function CDR.run_toks(cctab, ...)
  local s = ''
  if type(cctab) == 'string' then
    s = cctab
    cctab = 0
  end
  for _,ss in ipairs({...}) do
    s = s .. ss
  end
  tex.scantoks('CDR@toks',cctab,s);
  tex.runtoks('CDR@toks');
end
%    \end{MacroCode}
%
% \begin{function}{flow_create}
% \begin{syntax}
% local flow
% flow = CDR:flow_create(function(...)
%   \metatt{...}
%   tex.sprint(\metatt{...})
%   flow:go()
%   \metatt{...}
%   tex.sprint(\metatt{...})
%   flow:go()
%   \metatt{...}
% end)
% flow:go()
% \end{syntax}
% This is handy for synchronized TeX vs lua code.
% There are some limitations though.
% \end{function}
%    \begin{MacroCode}[OK]
do
  local flows = {}
  local last = 1.0
  function CDR:flow_go__(key)
debug_msg('FLOW GO ', key)
    local flow = flows[key]
    flow.already__ = 1
    coroutine.resume(flow.co__, table.unpack(flow.args__ or {}))
  end
  function CDR:flow_resume__(key)
    local flow = flows[key]
debug_msg('FLOW RESUME '..key..'/'..flow.already__..'/'..table.concat(flow.args__ or {}, ","))
    coroutine.resume(flow.co__)
  end
  function CDR:flow_terminate__(key)
    local flow = flows[key] 
    flow.key__ = nil
    flow.already__ = -1
    flows[key] = nil
debug_msg('FLOW TERMINATE '..key)
  end
  function CDR:flow_create (f)
    local key = last
    last = last+1.0
debug_msg('2 -> 9: FLOW CREATE '..key)
    local flow = {
      already__ = 0,     
      key__ = key, 
    }
    flows[key] = flow
    flow.co__ = coroutine.create(function (...)
debug_msg('4 -> 9: ENTER '..key..'/'..table.concat({...}, ","))
      local ans = { f(...) }
debug_msg('EXIT '..key..'/')
      tex.sprint([[\directlua]]..'{CDR:flow_terminate__('..key..')}')
      return table.unpack(ans)
    end)
    function flow.go (this, ...)
      if this.key__ == nil then
        tex.sprint([[\PackageError]]
          ..'{coder}'
          ..'{Going a flow twice is not supported}'
          ..'{Internal error, please report}'
        )
        return
      end
      if this.already__>0 then
debug_msg('6 -> 9: GO '..this.key__..'/'..this.already__..'/'..table.concat(this.args__ or {}, ","))
        tex.print([[\directlua]]..'{CDR:flow_resume__('..this.key__..')}')
        coroutine.yield()
      elseif this.already__ < 0 then
debug_msg('? -> 9: GO '..this.key__..'/'..this.already__..'/'..table.concat(this.args__ or {}, ","))
debug_msg('CDR: Already gone '..this.key__..'/')
      elseif this.args__ then
        tex.sprint([[\PackageError]]
          ..'{coder}'
          ..'{Going a flow twice is not supported}'
          ..'{Internal error, please report}'
        )
      else
        this.args__ = { ... }
debug_msg('3 -> WILL GO '..this.key__..'/'..this.already__..'/'..table.concat(this.args__, ","))
        tex.sprint(-1,[[\directlua]]..'{CDR:flow_go__('..this.key__..')}')
      end
    end
    return flow
  end
end
%    \end{MacroCode}
%
% \begin{function}{callback_push}
% \begin{syntax}
% callback_push(\metatt{callback_name},\metatt{callback}, \metatt{description})
% \end{syntax}
% Save the current callback and restore it at the end.
% \end{function}
%    \begin{MacroCode}[OK]
local function callback_push(callback_name, callback, description)
debug_msg('callback_push', callback_name, description)
  local saved = {}
  for _,d in pairs(
    ltb.callback_descriptions(callback_name)
  ) do
    local v = ltb_remove_from_callback(callback_name, d )
    saved[d] = v
    break
  end
  ltb_add_to_callback(callback_name, callback, description)
  local fired
  return function ()
debug_msg('exclusive_callback_pop', callback_name, description)
    if not fired then
      fired = true
      local f, d = ltb_remove_from_callback(callback_name, description )
      for k, v in pairs(saved) do
        ltb_add_to_callback(callback_name, v, k)
      end
      return f, d
    end
  end
end
TEST.callback_push = callback_push
%    \end{MacroCode}
%
% \begin{function}{set_python_path}
% \begin{syntax}
% CDR:set_python_path(\meta{path var})
% \end{syntax}
% \CDRCheckRed Manually set the path of the |python| utility with the contents
% of the \metatt{path var}.
% If the given path does not point to a file or a link then an error is raised.
% On return, print |true| or |false| in the \TeX{} stream to indicate whether
% \pkg{pygments} is available.
% \end{function}
%    \begin{MacroCode}[OK]
function CDR:set_python_path(path_var)
  local path, mode, _, __
  if path_var then
    path = assert(token.get_macro(path_var))
    mode,_,__ = lfs.attributes(path,'mode')
    print('**** CDR mode', path, mode)
  end
  if not mode then
    path = io.popen([[which python]]):read('a'):match("^%s*(.-)%s*$")
    mode,_,__ = lfs.attributes(path,'mode')
    print('**** CDR mode', path, mode)
  end
  if mode == 'file' or mode == 'link' then
    PYTHON_PATH = path
    print('**** CDR python path', PYTHON_PATH)
    path = path:match("^(.+/)")..'pygmentize'
    mode,_,__ = lfs.attributes(path,'mode')
    print('**** CDR path, mode', path, mode)
    PYGMENTIZE_PATH = path
    if mode == 'file' or mode == 'link' then
      tex.sprint('true')
    else
      tex.sprint('false')
    end
  else
    PYTHON_PATH = nil    
  end
end
%    \end{MacroCode}
%
% \begin{variable}{JSON_boolean_true, JSON_boolean_false}
% Special marker to encode booleans in |JSON| files.
% These are table which |__cls__| field is either |BooleanTrue| or |BooleanFalse|.
% \end{variable}
%    \begin{MacroCode}
local JSON_boolean_true = {
  __cls__ = 'BooleanTrue',
}
local JSON_boolean_false = {
  __cls__ = 'BooleanFalse',
}
%    \end{MacroCode}
%
% \begin{function}{is_truthy}
% \begin{syntax}
% if CDR.is_truthy(\meta{what}) then
%   \meta{true code}
% else
%   \meta{false code}
% end
% \end{syntax}
% Execute \metatt{true code} if \metatt{what} is |JSON_boolean_true| or the string ``true'',
% \metatt{false code} otherwise.
% When unqualified, this is an upvalue for the clients.
% \end{function}
%    \begin{MacroCode}[OK]
local function is_truthy(s)
  return s == JSON_boolean_true or s == 'true'
end
CDR.is_truthy = is_truthy
%    \end{MacroCode}
%
% \begin{function}{escape}
% \begin{syntax}
% <variable> = CDR.escape(<string>)
% \end{syntax}
% \CDRCheckRed Escape the given string to be used by the shell.
% \end{function}
%    \begin{MacroCode}[OK]
function CDR.escape(s)
  s = s:gsub(' ','\\ ')
  s = s:gsub('\\','\\\\')
  s = s:gsub('\r','\\r')
  s = s:gsub('\n','\\n')
  s = s:gsub('"','\\"')
  s = s:gsub("'","\\'")
  return s
end
%    \end{MacroCode}
%
% \begin{function}{make_directory}
% \begin{syntax}
% \meta{variable} = CDR.make_directory(\meta{string path})
% \end{syntax}
% Make a directory at the given path.
% \end{function}
%    \begin{MacroCode}[OK]
function CDR.make_directory(path)
  local mode,_,__ = lfs.attributes(path,"mode")
  if mode == "directory" then
    return true
  elseif mode ~= nil then
    return nil,path.." exist and is not a directory",1
  end
  if os["type"] == "windows" then
    path = path:gsub("/", "\\")
    _,_,__ = os.execute(
      "if not exist "  .. path .. "\\nul " .. "mkdir " .. ("%q"):format(path)
    )
  else
    _,_,__ = os.execute("mkdir -p "..("%q"):format(path))
  end
  mode = lfs.attributes(path,"mode")
  if mode == "directory" then
    return true
  end
  return nil,path.." exist and is not a directory",1
end
%    \end{MacroCode}
% \begin{variable}{dir_p}
% The directory where the auxiliary \pkg{pygments} related files are saved for later use,
% in general \metatt{jobname}|.pygd/|.
% \end{variable}
% \begin{variable}{json_p}
% The path of the JSON file used to communicate with \CDRPy{},
% in general\\\metatt{jobname}|.pygd/|\metatt{jobname}|.pyg.json|.
% \end{variable}
%    \begin{MacroCode}[OK]
local dir_p, json_p
local jobname = tex.jobname
dir_p = './'..jobname..'.pygd/'
if CDR.make_directory(dir_p) == nil then
debug_msg('No directory', dir_p)
  CDR.can_clean = false
  dir_p = './'
  json_p = dir_p..jobname..'.pyg.json'
else
  CDR.can_clean = true
  json_p = dir_p..'input.pyg.json'
end
%    \end{MacroCode}
% \begin{variable}{CDR.dir_p}
% \end{variable}
%    \begin{MacroCode}[OK]
CDR.dir_p = dir_p
CDR.json_p = json_p
%    \end{MacroCode}
% \begin{function}{safe_equals}
% \begin{syntax}
% <variable> = safe_equals(<string>)
% \end{syntax}
% Class method.
% Returns an \meta{=...=} string as \metatt{ans} exactly composed of sufficently many \texttt{=} signs
% such that \meta{string} contains neither sequence \texttt{[\meta{ans}[}
% nor \texttt{]\meta{ans}]}.
% \end{function}
%    \begin{MacroCode}[OK]
local eq_pattern = P({ Cp() * P('=')^1 * Cp() + P(1) * V(1) })
local function safe_equals(s)
  local i, j = 0, 0
  local max = 0
  while true do
    i, j = eq_pattern:match(s, j)
    if i == nil then
      return rep('=', max + 1)
    end
    i = j - i
    if i > max then
      max = i
    end
  end
end
%    \end{MacroCode}
%
% \begin{function}{load_exec}
% \begin{syntax}
% CDR:load_exec(\meta{lua code chunk})
% \end{syntax}
% Class method. Loads the given \metatt{lua code chunk} and execute it.
% On error, messages are printed.
% \end{function}
%    \begin{MacroCode}[OK]
function CDR:load_exec(chunk)
  local env = setmetatable({ self = self, tex = tex }, _ENV)
  local func, err = load(chunk, 'coder-tool', 't', env)
  if func then
    local ok
    ok, err = pcall(func)
    if not ok then
      print("coder-util.lua Execution error:", err)
      print('chunk:', chunk)
    end
  else
    print("coder-util.lua Compilation error:", err)
    print('chunk:', chunk)
  end
end
%    \end{MacroCode}
%
% \begin{function}{load_exec_output}
% \begin{syntax}
% CDR:load_exec_output(\meta{lua code chunk})
% \end{syntax}
% Instance method to parse the \metatt{lua code chunk} sring for commands and execute them.
% The patterns being searched are enclosed within opening |<<<<<| and closing |>>>>>|,
% each containing 5 characters,
% \begin{description}
% \item[\texttt{?TEX}:\metatt{TeX instructions}] the \metatt{TeX instructions} are executed
% asynchronously once the control comes back to \TeX{}.
% \item[\texttt{!LUA}:\metatt{!Lua instructions}] the \metatt{!Lua instructions} are executed
% synchronously. When not properly designed, these instruction may cause a
% forever loop on execution, for example, they must not use \texttt{CDR:if_code_ngn}.
% \item[\texttt{?LUA}:\metatt{?Lua instructions}] these \metatt{?Lua instructions} are executed
% asynchronously once the control comes back to \TeX{} through a call to \cs{directlua},
% which means that they will wait until any previous asynchronous \metatt{?TeX instructions}
% or \metatt{?Lua instructions} completes.
% \end{description}
% \end{function}
%    \begin{MacroCode}[OK]
local parse_pattern
do
  local tag = P('!') + '*' + '?'
  local stp = '>>>>>'
  local cmd = (P(1) - stp)^0
  parse_pattern = P({
    P('<<<<<') * Cg(tag) * 'LUA:' * Cg(cmd) * stp * Cp() + 1 * V(1)
  })
end
function CDR:load_exec_output(s)
  local i, tag, cmd
  i = 1
  while true do
    tag, cmd, i = parse_pattern:match(s, i)
    if tag == '!' then
      self:load_exec(cmd)
    elseif tag == '*' then
      local eqs = safe_equals(cmd)
      cmd = '['..eqs..'['..cmd..']'..eqs..']'
      tex.print([[%
\directlua{CDR:load_exec(]]..cmd..[[)}%
]])
    elseif tag == '?' then
      print('\nDEBUG/coder: '..cmd)
    else
      return
    end
  end
end
%    \end{MacroCode}
%
% \section{Storage}
%
% \subsection{Code}
% \begin{variable}{inline_by_id}
% Storage for the |CDRCode| and |CDRCodeSave| command body. 
%    \begin{MacroCode}
local inline_by_id = {}
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{Block_list_all}
% \begin{syntax}
% CDR:Block_list_all()
% \end{syntax}
% Debug diagnostic. 
% \end{function}
%    \begin{MacroCode}
function CDR:Code_list_all()
  print('**** CDR INFO: known Codes ***********')
  for k, v in pairs(inline_by_id) do
    print(k, '->', v)
  end
  print('**************************************')
end
%    \end{MacroCode}
%
% \subsection{Block}
% \begin{variable}{lines_by_id}
% Storage for the |CDRBlock| and |CDRBlockSave| environments body. 
%    \begin{MacroCode}
local lines_by_id = {}
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{Block_list_all}
% \begin{syntax}
% CDR:Block_list_all()
% \end{syntax}
% Debug diagnostic. 
% \end{function}
%    \begin{MacroCode}
function CDR:Block_list_all()
  print('**** CDR INFO: known Blocks **********')
  for k, v in pairs(lines_by_id) do
    print(k, '->', v .. 'lines')
  end
  print('**************************************')
end
%    \end{MacroCode}
%
% \section{Objects and metatables}
%
% \subsection{Object}
%
% \begin{variable}{Object}
% The |Code| and |Block| are descendants of |Object|,
% they inherit its methods ad attributes.
% |Object| defines dynamic attributes
% |id|, |id_short| and |delimiters|.
% |id| is retrieved from the content of the |\l_CDR_id_tl|
% macro and cached for next usage.
% The same holds for the other ones.
% \end{variable}
%
%    \begin{MacroCode}
local Object = setmetatable({}, {
  __index = function (self, k)
    local ans
    if k == 'id' then
      ans = token.get_macro('l_CDR_id_tl')
    elseif k == 'delimiters' then
      ans = token.get_macro('l_CDR_delimiters_tl')
    elseif k == 'id_short' then
      ans = token.get_macro('l_CDR_id_short_tl')
    end
-- debug_msg('Object MT __index', k, ans)
    return ans
  end,
})
Object.__index = Object
TEST.Object = Object
%    \end{MacroCode}
%
% \subsection{Code}
%
% \begin{variable}{CDR.Code}
% The |Code| contains attributes and methods to properly
% deal with |CDRCode|, |CDRCodeSave|,
% |CDRCodeUse| and |CDRCodeExe| commands.
% Its metatable is the local |Code| table.
% \end{variable}
%
%    \begin{MacroCode}
local Code = setmetatable({}, {
  __index = Object
})
TEST.Code = Code
function Code:__index (k)
-- debug_msg('Code:__index', k)
  if k == 'inline' then
    return inline_by_id[self.id]
  elseif k == '.arguments' then
    local ans = {
      __cls__ = 'Arguments',
      source  = '',
      cache   = JSON_boolean_true,
      debug   = JSON_boolean_false,
      pygopts = {
        __cls__ = 'PygOpts',
        lang    = 'tex',
        style   = 'default',
        mathescape   = JSON_boolean_false,
        escapeinside = self.delimiters,
      },
      texopts = {
        __cls__ = 'TeXOpts',
        tags    = '',
        is_inline = JSON_boolean_true,
        pyg_sty_p = '',
        synctex_tag  = 0,
        synctex_line = 0,
      },
    }
    rawset(self, k, ans)
    return ans
  end
  return Code[k]
end
function Code:__newindex (k, v)
-- debug_msg('Code:__newindex', k, v)
  if k == 'inline' then
-- debug_msg('Setting inline')
    inline_by_id[self.id] = v
  else
    rawset(self, k, v)
  end
end
%    \end{MacroCode}
%
% \subsubsection{Inline}
% \begin{function}{inline_save}
% \begin{syntax}
% CDR:inline_save()
% \end{syntax}
% Save the content of the |\l_CDR_peek_tl| macro
% at some place associate with the current \metatt{id}.
% \end{function}
%    \begin{MacroCode}
function Code:inline_save ()
  inline_by_id[self.id] = token.get_macro('l_CDR_peek_tl')
debug_msg('Code:inline_save', self.id, '->', inline_by_id[self.id])
end
%    \end{MacroCode}
%
% \begin{function}{Code.sprint_known}
% \begin{syntax}
% CDR.Code:sprint_known()
% \end{syntax}
% % Print something to the \TeX\ stream when there is some code
% for the current \metatt{id}, nothing otherwise.
% \end{function}
%    \begin{MacroCode}
function Code:sprint_known()
  if self.inline then
    tex.sprint('T')
  end
end
%    \end{MacroCode}
%
% \begin{function}{Code.inline_to_ltx}
% \begin{syntax}
% CDR.Code:inline_to_ltx(\metatt{mode})
% \end{syntax}
% Export the inline source to \LaTeX{} to feed various
% macro named |\l_CDR_id_tl|.
% Assignments are local.
%
% When \metatt{mode} is |"unescaped"|,
% spaces and tabs are active,
% every other character is a letter.
% When \metatt{mode} is |"string"|,
% every character is a letter.
% In other cases, the current catcode regime applies.
% \end{function}
%    \begin{MacroCode}
local sprint_active_f = function(s)
  tex.sprint(CDR.active_cctab, s)
end
local sprint_escape_f = function(s)
  tex.sprint(CDR.escape_cctab, s)
end
function Code:sprint_inline ()
  self:escape_inside_maker{
    active_f   = sprint_active_f,
    escape_f   = sprint_escape_f,
    alter_f    = f_noop,
  } ( self.inline or '' )
end
function Code:inline_to_ltx (mode)
  local cctab
  if mode == 'string' then
    cctab = CDR.string_cctab
  elseif mode == 'active' then
    cctab = CDR.active_cctab
  else
    cctab = -1
  end
  token.set_macro(
    cctab,
    self.id,
    self.inline or ''
  )
end
%    \end{MacroCode}
%
% \begin{function}{sprint_inline_string, sprint_inline_active, sprint_inline_escape}
% \begin{syntax}
% CDR.Code:sprint_inline_\metatt{variant}()
% \end{syntax}
% Prints the code to the \TeX\ stream using
% |CDR.|\metatt{variant}|_cctab| catcode table.
% \end{function}
%    \begin{MacroCode}
function Code:sprint_inline_string ()
  tex.sprint(CDR.string_cctab, self.inline or '')
end
function Code:sprint_inline_active ()
  tex.sprint(CDR.string_active, self.inline or '')
end
function Code:sprint_inline_escaped ()
  tex.sprint(CDR.string_escaped, self.inline or '')
end
%    \end{MacroCode}
%
% \begin{function}{Code.peek_active_begin, Code.peek_active_end, Code.status}
% \begin{syntax}
% CDR.Code:peek_active_begin(\meta{identifier})
% CDR.Code:peek_active_end()
% CDR.Code:status()
% \end{syntax}
% Set the peeker and its associate closure for further peeking.
% These functions are balancing each other.
% Implementation detail: the |peek_active_end| is defined dynamically.
% \end{function}
% The only purpose is to catch a new line very early. This is achieved by using callbacks.
% The |status| will print something to the \TeX\ stream in case of error.
%    \begin{MacroCode}
function Code:peek_active_begin ( delimiter )
  local pop = callback_push (
    'process_input_buffer',
    function (input)
      if input then
        function self.status(this)
          tex.print('error')
        end
        return delimiter..input
      end
    end,
    'CDRCode',
    1
  )
  self.peek_active_end = function (this)
    pop()    
  end
end
function Code:peek_active_end ()
  error('Build time error: unexpected Code.peek_active_end')
end
Code.status = f_noop
%    \end{MacroCode}
% 
% \begin{function}{Code_new, Code_free}
% \begin{syntax}
% CDR.Code_new()
% CDR.Code_free()
% \end{syntax}
% These functions are balancing each other
% and must be called accordingly.
% This is reentrant, usefull for |\CDRCodeExe| command.
% \end{function}
%    \begin{MacroCode}
function CDR:Code_new()
  self.Code = setmetatable({
    ['..Code'] = self.Code,
    ['..Code_free'] = rawget(self, 'Code_free'),
  }, Code)
  self.Code_free = function (this)
    this.Code_free = this.Code['Code_free']
    this.Code = this.Code['..Code']
  end
end
function Code_free (self)
  error('Build time error: unexpected Code_free')
end
%    \end{MacroCode}
% 
% \subsection{Block}
%
% \begin{variable}{CDR.Block}
% The |Block| contains attributes and methods to properly
% deal with |CDRBlock| and |CDRBlockSave| environments,
% as well as |CDRBlockUse| and |CDRBlockExe| commands. 
% Its metatable is the local |Block| table.
% \end{variable}
%
%    \begin{MacroCode}
local Block = setmetatable({}, {
  __index = Object,
})
TEST.Block = Block
function Block:__index(k)
  local ans
  if k == 'lines' then
    ans = lines_by_id[self.id]
-- debug_msg('Block MT __index', k, self.id, ans)
    return ans
  elseif k == 'env' then
    ans = token.get_macro('@currenvir')
-- debug_msg('Block MT __index', k, ans)
    rawset(self, k, ans)
    return ans
  elseif k == 'gobble' then
    ans = token.get_macro('l_CDR_gobble_tl')
    return ans
  elseif k == '.arguments' then
    ans = {
      __cls__ = 'Arguments',
      cache = JSON_boolean_false,
      debug = JSON_boolean_false,
      pygopts = {
        __cls__ = 'PygOpts',
        lang = 'tex',
        style = 'default',
        texcomments= self.tex_comments
          and JSON_boolean_true
          or JSON_boolean_false,
        mathescape = JSON_boolean_false,
        escapeinside = self.delimiters,
      },
      texopts = {
        __cls__ = 'TeXOpts',
        tags  = self['.tags clist'],
        is_inline = JSON_boolean_false,
        pyg_sty_p = '',
        synctex_tag= 0,
        synctex_line = 0,
      },
    }
    rawset(self, k, ans)
    return ans
  end
  return Block[k]
end
function Block:__newindex(k, v)
-- debug_msg('Block:__newindex', k, v)
  if k == 'lines' then
-- debug_msg('Setting lines')
    lines_by_id[self.id] = v
  else
    rawset(self, k, v)
  end
end
%    \end{MacroCode}
%
% \begin{function}{Block_new, Block_free}
% \begin{syntax}
% CDR:Block_new()
% CDR:Block_free()
% \end{syntax}
% These functions are balancing each other
% and must be called accordingly.
% This is reentrant, usefull for |CDRBlockExe| command.
% \end{function}
%    \begin{MacroCode}
function CDR:Block_new()
  self.Block = setmetatable({
    ['..Block'] = self.Block,
    ['..Block_free'] = rawget(self, 'Block_free'),
  }, Block)
  self.Block_free = function (this)
    this.Block_free = this.Block['..Block_free']
    this.Block = this.Block['..Block']
  end
end
function CDR:Block_free()
  error('Buid time error: unexpected Block_free')
end
%    \end{MacroCode}
%
% \subsubsection{Save}
%
% \begin{function}{save_begin, save_end}
% \begin{syntax}
% CDR.Block:save_begin()
% CDR.Block:save_end()
% \end{syntax}
% Set the scanner and its associate closure for further scanning.
% These functions are balancing each other.
% Implementation detail: the |save_end| is defined dynamically.
% \end{function}
%
% We expect to catch different situations while scanning.
% \begin{multicols}{2}
% \begin{description}
% \item[No body, no options]\leavevmode
% \begin{Verbatim}
% \begin{CDRBlock}
% \end{CDRBlock}
% \end{Verbatim}
% \item[No body, one line options]\leavevmode
% \begin{Verbatim}
% \begin{CDRBlock}[...]
% \end{CDRBlock}
% \end{Verbatim}
% \item[No body, many line options]\leavevmode
% \begin{Verbatim}
% \begin{CDRBlock}[
%   ...]
% \end{CDRBlock}
% \end{Verbatim}
% \item[No options]\leavevmode
% \begin{Verbatim}
% \begin{CDRBlock}
% body
% \end{CDRBlock}
% \end{Verbatim}
% \item[One line options]\leavevmode
% \begin{Verbatim}
% \begin{CDRBlock}[...]
% body
% \end{CDRBlock}
% \end{Verbatim}
% \item[Many line options]\leavevmode
% \begin{Verbatim}
% \begin{CDRBlock}[
%   ...]
% body
% \end{CDRBlock}
% \end{Verbatim}
%
% \end{description}
% \end{multicols}
%
% |CDRBlock| and |CDRBlockSave| environments globally
% save their body on the \CDRLua\ side.
% This makes sense because these are strings
% and not tokens with a category code.
% In order to do some error checking,
% we determine whether there are options.
% For that, we will
% define the environments with no options at all,
% then we peek the next character and test for a `['.
% If there is one on the same line, we switch to the
% |in_options| mode. If there is nothing on the same line,
% then the callback will provide a fake |\relax| line
% and record the real input for later use.
% If there is actually any black character after the
% |\begin{CDRBlock}| or |\begin{CDRBlockSave}|
% on the same line, an error is raised.
% On error recovery, scanning is peeking until
% the next line. Once we have peeked a |[|,
% |\CDRBlock@Read@Options| is called,
% where lines are required until a balancing |]|
% is found.
% Then we want to raise an error if there
% is some black material after this closing bracket.
% The peeker exits the |in_options| mode and is
% not yet in the |in_body| mode.
% As soon as the callback is asked for a new line,
% it enters the |in_body| mode.
% The controller is in safe mode as soon as the callback is called.
%    \begin{MacroCode}
function Block:save_begin ()
  local env = assert(self.env)
debug_msg('Block:save_begin, environment name:', env)
  local lines = {}
  self.lines = lines
  assert(lines == self.lines)
  local f_current
  local pop = callback_push (
    'process_input_buffer',
    function (input)
      if input then
        return f_current(input)
      else
        return ([[\PackageError{coder}{Missing `\end{%s}'}{See %s documentation }]]):format(env, env)
      end
    end,
    'CDRBlock',
    1
  )
  if debug_msg ~= f_debug_msg then
    ltb_add_to_callback (
      'process_input_buffer',
      function (input)
        debug_msg('BUFFER:', '<'..input..'>')
        return input
      end,
      'CDRBlockDebug',
      1
    )
  end
  local function remove_from_callback ()
    if ltb.in_callback('process_input_buffer', 'CDRBlockDebug') then
      ltb_remove_from_callback(
        'process_input_buffer',
        'CDRBlockDebug'
      )
    end
    pop()
  end
%    \end{MacroCode}
% |f_current| is the state of the |process_input_buffer| callback.
% It is defined by one of next functions.
% State changes are below.
%    \begin{MacroCode}
  local f_start, f_options, f_body, f_line
%    \end{MacroCode}
% The start state of the callback called iff there is
% no option after de |\begin{...}| instruction.
% It stores the real |input| and return a fake |x%| line.
% The return line must consist of a raw token.
% The real input will be managed in the |in_body| method
% which must be called afterwards.
% This is only called through |f_current|: it is called
% first and only once.
%    \begin{MacroCode}
  f_line = function (input)
    lines[#lines+1] = input
    return [[\relax]]    
  end
  f_start = function (input)
debug_msg('CALLBACK:IN_START', '<'..input..'>')
    f_current = f_line
    token.set_char('l_CDR_before_eol_bool', 0)
    if input:match([[^%s*\end%s*]]
      ..'{'..env..'}') then
%    \end{MacroCode}
% No option, no body: terminante environment.
%    \begin{MacroCode}
debug_msg('WILL remove_from_callback')
      remove_from_callback()
debug_msg('SCAN:end', '<'..input..'>')
      return input
    else
debug_msg('CALLBACK:START', '<'..input..'>')
      return f_line(input)
    end
  end
  f_current = f_start
%    \end{MacroCode}
% The state of the callback iff there are real options.
% Raise an error if the environment is closed too early.
% Switching to and from this state is made from the
% \LaTeX{} side.
%    \begin{MacroCode}
  f_options = function (input)
debug_msg('CALLBACK:IN_OPTIONS', '<'..input..'>')
    local d, v, b = input:match([[^%s*(\\end)%s*]]
      ..'({'..env..'})'..[[([^%]*)]])
    if d then
      remove_from_callback()--[
debug_msg('CALLBACK:END', '<'..input..'>')
      return ']'
        ..d..v
        ..[[\PackageError{coder}]]
        ..[[{Unterminated\space options}]]
        ..'{'..[[a\space]]--}[
        ..']'
        ..[[\space is\space missing\space]]
        ..[[before\space\end]]..'{'..env..'}'--{
        ..'}'
        ..b
    else
      return input
    end
  end
%    \end{MacroCode}
% Scanning the body of the environment:
% if this is the closing instruction, stop processing input,
% otherwise store it and return a fake |%| instead.
% after real options.
%    \begin{MacroCode}
  f_body = function (input)
debug_msg('CALLBACK:IN_BODY', '<'..input..'>')
    token.set_char('l_CDR_before_eol_bool', 0)
    if input:match([[^%s*\end%s*]]
      ..'{'..env..'}') then
debug_msg('WILL remove_from_callback 2', [[\relax]]..input)
      remove_from_callback()
      return [[\relax]]..input
    else
      lines[#lines+1] = input
      return [[\relax]]
    end
  end
  self.enter_body = function (this)
debug_msg('Block:enter_body')
    debug_msg('Block.enter_body')
    f_current = f_body
  end
%    \end{MacroCode}
% Must be called before reading the options
% to manage an eventual |last_input|.
%    \begin{MacroCode}  
  self.enter_options = function (this)
debug_msg('Block:enter_options')
    f_current = f_options
  end
%    \end{MacroCode}
% Options where scanned, only comments are allowed
% on this line.
% We switch back to some default state.
%    \begin{MacroCode}
  self.exit_options = function (this)
debug_msg('Block:exit_options')
    f_current = f_body
  end
  self.save_end = function (this)
    debug_msg('Block:save_end... DONE')
  end
debug_msg('Block:save_begin... DONE')
end
function Block:save_end ()
  error('Buid time error: unexpected save_end')
end
%    \end{MacroCode}
% The default state:
%    \begin{MacroCode}
function Block:enter_body ()
  error('Buid time error: unexpected enter_body')
end
function Block:enter_options ()
  error('Buid time error: unexpected enter_options')
end
function Block:exit_options ()
  error('Buid time error: unexpected exit_options')
end
%    \end{MacroCode}
%
% \begin{function}{Block.sprint_known}
% \begin{syntax}
% CDR.Block:sprint_known()
% \end{syntax}
% Print something to the \TeX\ stream when there is some lines
% of code for the current \metatt{id}, nothing otherwise.
% \end{function}
%    \begin{MacroCode}
function Block:sprint_known ()
  if self.lines then
    tex.sprint('T')
  end
end
function Block:sprint_count ()
  local lines = self.lines
  local ans = lines and #lines or -1
  tex.sprint(''..ans)
end
%    \end{MacroCode}
%
% \subsubsection{preprocess}
%
% \begin{function}{pre_setup}
% \begin{syntax}
% CDR.Block:pre_setup()
% \end{syntax}
% The reader is asked for some line,
% but sometimes a pre treatment is necessary.
% \end{function}
%    \begin{MacroCode}
function Block:pre_setup ()
  local gobble = self.gobble
  local escape_inside = self:escape_inside_maker{
    active_f   = sprint_active_f,
    escape_f   = sprint_escape_f,
    alter_f    = f_noop,
  }
  self.sprint_line_ltx2 = function(this, n)
    CDR.sprint_escape([[\color{magenta!50!black}\bfseries ABCD]])
    CDR.sprint_string([[FAKE]])
  end
  self.sprint_line_ltx = function(this, n)
    local l = this.lines[n]
    l = utf8.sub(l, 1+gobble)
    if #l == 0 then
      return
    end
    escape_inside(l)
  end
end
%    \end{MacroCode}
%
% \begin{function}{print_line_raw,print_line_active,print_line_escape,sprint_line_ltx,sprint_comment_ltx}
% \begin{syntax}
% CDR.Block:print_line_\metatt{variant}(\metatt{integer})
% \end{syntax}
% Print to the \TeX\ stream the line at the given index.
% When \metatt{variant} is `|raw|', every character is a letter.
% When variant is `|active|', horizontal spaces and tabs
% are active while every other character is a letter.
% When variant is `|escape|', what is `|escaped inside|'
% follows the current catcode régime, whereas what is
% outside follows the `|active|' variant.
%
% When no prior |pre_setup| call, the `|escape|' variant is
% unavailable (and raise an error).
% \end{function}
%    \begin{MacroCode}
function Block:print_line_raw (n)
  tex.print(CDR.string_cctab, self.lines[n])
end
function Block:print_line_active (n)
  tex.print(CDR.active_cctab, self.lines[n])
end
function Block:print_line_escape (n)
  error('Build time error: unexpected print_line')
end
function Block:sprint_line_ltx (n)
  error('Build time error: unexpected sprint_line_ltx')
end
function Block:sprint_comment_ltx ()
  error('Build time error: unexpected sprint_comment_ltx')
end
%    \end{MacroCode}
%
% \subsubsection{Execute}
% 
% \begin{function}{exe_makeatletter, exe_makeatother,exeExplSyntaxOn, exeExplSyntaxOff}
% \begin{syntax}
% CDR.Block:exe_makeatletter(\metatt{truthy value})
% \end{syntax}
% Same syntax for both functions.
% Set up the context of execution.
% Calls are balanced based on the normal category code.
% The real catcode regime before the execution is ignored,
% and may not be recovered afterwards.
% \end{function}
%    \begin{MacroCode}[OK]
function Block:exe_makeatletter (torf)
  if torf ~= false then
    tex.print([[\makeatletter]])
    self.exe_makeatother = function (this)
      tex.print([[\makeatother]])
    end
  end
end
function Block:exe_makeatother ()
end
function Block:exeExplSyntaxOn (yorn)
  if yorn ~= false then
    tex.print([[\ExplSyntaxOn]])
    self.exeExplSyntaxOff = function (this)
      tex.print([[\ExplSyntaxOff]])
    end
  end
end
function Block:exeExplSyntaxOff ()
end
%    \end{MacroCode}
%
% \begin{function}{input_virtual_file}
% \begin{syntax}
% input_virtual_file(\metatt{reader_f}, \metatt{close_f})
% \end{syntax}
% Input a virtual file.
% The \metatt{reader_f} and \metatt{close_f} functions
% are the standard functions for |'open_read_file'|.
% Their |env| argument is set up appropriately.
% Should the |close| function be overriden, it must end
% with a call to |env:did_close()| to properly restore the state.
%
% In general, this is the last instruction of a |\directlua| argument.
% \end{function}
%    \begin{MacroCode}[OK]
local function input_virtual_file (reader_f, close_f)
  local pop_frf = callback_push(
    'find_read_file',
    function (id_number, asked_name)
      return asked_name
    end,
    'CDRInputVirtualFile'
  )
  local pop_orf
  pop_orf = callback_push(
    'open_read_file',
    function (file_name)
debug_msg('CDRInputVirtualFile open_read_file', file_name)
      return {
        reader = function(env)
          if env.close == nil then
            env.close = function (this)
debug_msg('CDRInputVirtualFile close', file_name)
              if close_f then
                close_f(this)
              end
              this:did_close()
            end
          end
          return reader_f(env)
        end,
        did_close = function (env)
          pop_orf()
          pop_frf()
        end,
      }
    end,
    'CDRInputVirtualFile'
  )
  tex.print([[\input{...}]])
end
%    \end{MacroCode}
%
% \begin{function}{exe_begin, exe_end}
% \begin{syntax}
% CDR.Block:exe_begin(\metatt{makeatletter}, \metatt{ExplSyntaxOn})
% CDR.Block:exe_end()
% \end{syntax}
% Execute the block code stored under the current \meta{id}.
% Initialize |CDR.Block:exe_begin()|,
% do some management then terminate the process with
% |CDR.Block:exe_end()|.
% Implementation detail: Use a fake file to execute these commands.
% \end{function}
%    \begin{MacroCode}[OK]
function Block:exe_begin ()
  self.exe_end = function (this)
    if #this.lines == 0 then
      return
    end
    local i = 0
    local lines = { table.unpack(this.lines) }
    input_virtual_file(
      function(env)
        i = i+1
        return lines[i]
      end
    )
  end
end
function Block:exe_end ()
  error('Build time error: unexpected exe_end')
end
%    \end{MacroCode}
%
% \section{Hiligting with \pkg{pygments}}
%
% \subsection{Common}
%
% \begin{function}{pyg_set, pyg_set_var}
% \begin{syntax}
% CDR.\metatt{Object}:pyg_set(\metatt{kvargs})
% CDR.\metatt{Object}:pyg_set_var(\metatt{key}, \metatt{value_var})
% \end{syntax}
% \metatt{Object} is one of |Code| of |Block|.
% \metatt{kvargs} is a comma separated |key=value| list.
% Build a configuration table named |.arguments| with all data necessary for the processing.
% It will be saved as a |JSON| file and used to launch
% \CDRPy{} with the proper arguments.
% \end{function}
%    \begin{MacroCode}
function Object:pyg_set(kvargs)
  assert(kvargs, 'Missing required table argument')
  local args = self['.arguments']
  for key, value in pairs(kvargs) do
    local t = args
    if t[key] == nil then
      t = args.pygopts
      if t[key] == nil then
        t = args.texopts
        assert(t[key])
      end
    end
debug_msg('pyg_set', key, value)
    if t[key] == JSON_boolean_true or t[key] == JSON_boolean_false then
      t[key] = value == 'true' and JSON_boolean_true or JSON_boolean_false
    else
      t[key] = tostring(value)
    end
  end
end
function Object:pyg_set_var(key, var)
  self:pyg_set{
    [key] = assert(token.get_macro(var or 'l_CDR_a_tl'))
  }
end
%    \end{MacroCode}
%
% \begin{function}{pyg_source}
% \begin{syntax}
% CDR.\metatt{Object}:pyg_source(\meta{sty}, \meta{src})
% \end{syntax}
% Hilight the currently entered block if \metatt{src} is |true|,
% build the style definitions if \metatt{sty} is |true|.
% Build a configuration table with all data necessary for the processing,
% save it as a |JSON| file and launch \CDRPy{} with the proper arguments.
% Set the |\l_CDR_pyg_sty_tl| and |\l_CDR_pyg_tex_tl| macros on return,
% depending on \metatt{src} and \metatt{sty}.
% \end{function}
%    \begin{MacroCode}
function Object:pyg_source(sty, src)
debug_msg('pyg_source', sty, src)
  if not PYTHON_PATH then
    return
  end
  local args = self['.arguments']
  local texopts = args.texopts
  local pygopts = args.pygopts
  local inline = is_truthy(texopts.is_inline)
  local use_cache = is_truthy(args.cache)
  local use_py = false
  local cmd = PYTHON_PATH..' '..CDR_PY_PATH
  local debug = is_truthy(args.debug)
  if debug then
    cmd = cmd..' --debug'
  end
  local pyg_sty_p
  if sty then
    pyg_sty_p = CDR.dir_p..pygopts.style..'.pyg.sty'
    token.set_macro(-2, 'l_CDR_pyg_sty_tl', pyg_sty_p)
debug_msg('pyg_source: sty', token.get_macro('l_CDR_pyg_sty_tl'))
    texopts.pyg_sty_p = pyg_sty_p
    local mode,_,__ = lfs.attributes(pyg_sty_p, 'mode')
    if not mode or not use_cache then
      use_py = true
      if debug then
        print('PYTHON STYLE:')
      end
      cmd = cmd..(' --create_style')
    end
    CDR:cache_record(pyg_sty_p)
  end
  local pyg_tex_p
  if src then
    local ds = self.delimiters
    local n = utf8.len(ds)
    local l = n>0 and utf8.sub(ds, 1, 1) or ''
    local m = n>1 and utf8.sub(ds, 2, 2) or ''
    local r = n>2 and utf8.sub(ds, 3, 3) or nil
    local gobble = self.gobble
    local s
    local escape_inside = self:escape_inside_maker{
      active_f = function (ss)
        s = s .. ss
      end,
      escape_f = function (ss)
        s = s .. l .. ss .. (r or m )
      end
    }
    local source
    if inline then
      s = ''
      escape_inside(self.inline or '')
      source = s
      args.source = source
    else
      local lines = {}
      local gobble = self.gobble
      for _,l in ipairs(lines_by_id[self.id]) do
        s = ''
        escape_inside(utf8.sub(l, 1+gobble))
        lines[#lines+1] = s
      end
      source = table.concat(lines, '\n')
debug_msg('pyg_source', '<'..self.id..'>', lines, #lines)
    end
    local hash = md5.sumhexa( ('%s:%s:%s'
      ):format(
        source,
        inline and 'code' or 'block',
        pygopts.style
      )
    )
    local base = CDR.dir_p..hash
    pyg_tex_p = base..'.pyg.tex'
    token.set_macro(-2, 'l_CDR_pyg_tex_tl', pyg_tex_p)
debug_msg('pyg_source: sty', token.get_macro('l_CDR_pyg_tex_tl'))
    local mode,_,__ = lfs.attributes(pyg_tex_p,'mode')
    if not mode or not use_cache then
      use_py = true
      if debug then
        print('PYTHON SOURCE:', inline)
      end
      if not inline then
        local tex_p = base..'.tex'
        local f = assert(io.open(tex_p, 'w'))
        local ok, err = f:write(source)
        f:close()
        if not ok then
          print('File error('..tex_p..'): '..err)
        end
        if debug then
          print('OUTPUT: '..tex_p)
        end
      end
      cmd = cmd..(' --base=%q'):format(base)
    end
  end
  if use_py then
debug_msg('JSON', json_p, json.tostring(args, true))
    local f = assert(io.open(json_p, 'w'))
    local ok, err = f:write(json.tostring(args, true))
    f:close()
    if not ok then
      print('File error('..json_p..'): '..err)
    end
    cmd = cmd..('  %q'):format(json_p)
    if debug then
      print('CDR>'..cmd)
    end
    local o = io.popen(cmd):read('a')
    CDR:load_exec_output(o)
    if debug then
      print('PYTHON', o)
    end
  elseif debug then
    print('SAVED>'..cmd)
  end  
  CDR:cache_record(
    sty and pyg_sty_p or nil,
    src  and pyg_tex_p or nil
  )
end
%    \end{MacroCode}
%
% \subsection{Code}
%
% \begin{function}{Code.pyg_setup}
% \begin{syntax}
% CDR.Code:pyg_setup()
% \end{syntax}
% Hilight the code in \pkg{str} variable named \metatt{code var name}.
% Build a configuration table with all data necessary for the processing,
% save it as a |JSON| file and launch \CDRPy{} with the proper arguments.
% \end{function}
%    \begin{MacroCode}
function Code:pyg_setup()
  self.pyg_json_written = false
end
%    \end{MacroCode}
%
% \begin{function}{pyg_teardown}
% \begin{syntax}
% CDR.Code:pyg_teardown()
% \end{syntax}
% Restore the Sync\TeX\ state.
% \end{function}
%    \begin{MacroCode}
function Code:pyg_teardown()
  self:synctex_restore()
end

%    \end{MacroCode}
%
% \subsection{Block}
%
% \begin{function}{Block.pyg_setup, Block.pyg_teardown}
% \begin{syntax}
% CDR.Block:pyg_setup(\meta{tags clist var})
% \end{syntax}
% Records the contents of the \metatt{tags clist var} \LaTeX{} variable
% to prepare block hilighting.
% This is called at the end of the environment when we can know that the current line
% is exactly the first after the last line of code.
% \end{function}
%    \begin{MacroCode}
function Block:pyg_setup (tags_clist_var)
debug_msg('Block:pyg_setup')
  self['.tags clist'] = assert(
    token.get_macro(assert(tags_clist_var))
  )
  self.pyg_json_written = false
end
%    \end{MacroCode}
%
% \begin{variable}{records_by_tag}
% Global storage for exportation.
% \end{variable}
%    \begin{MacroCode}[OK]
local records_by_tag = {}
%    \end{MacroCode}
%
% \begin{function}{escape_inside}
% \begin{syntax}
% escape_inside(\meta{text}, \meta{delimiters})
% \end{syntax}
% Return a copy of \meta{text} where what was escaped is remove, including the delimiters.
% \meta{text} needs not be a line.
% Private function (upvalue)
% \end{function}
%    \begin{MacroCode}[OK]
local function escape_inside_old (text, delimiters)
  local i = 1
  local t = {}
  local r
  if delimiters:len() == 2 then
    r = '(.-)['..delimiters:sub(1,1)..'].-['
      ..delimiters:sub(2,2)..']()'
    for a, next_i in text:gmatch(r) do
      t[#t+1] = a
      i = next_i
    end
  elseif delimiters:len() == 3 then
    r = '(.-)['..delimiters:sub(1,1)..'].-['
      ..delimiters:sub(2,2)..'](.-)['
      ..delimiters:sub(3,3)..']()'
    for a, b, next_i in text:gmatch(r) do
      t[#t+1] = a
      t[#t+1] = b
      i = next_i
    end
  end
  if i > 1 then
    t[#t+1] = text:sub(i,-1)
    return table.concat(t,'')    
  end
  return text
end
%    \end{MacroCode}
%
% \begin{function}{escape_inside_maker}
% \begin{syntax}
% CDR.Object:escape_inside\{\meta{kvargs}\}
% \end{syntax}
% Return a function that parses some text and applies filters
% to its parts. Attributes of \metatt{kvargs}.
% \begin{description}
% \item[delimiters, escape_f, alter_f] for the escape inside feature.
% What is between the 2 first chars of |delimiters| is extracted
% and the |escape_f| filter is applied.
% What is between the 2 last chars is extracted and the
% |alter_f| filter is applied, if there are 3 characters.
% \item [active_f] this filter is applied to the text outside
% the delimiters and before the comments.
% \end{description}
% \end{function}
%    \begin{MacroCode}[OK]
function Object:escape_inside_maker (kvargs)
  local p_1 = P(1)
  local pattern
  local escape_f  = kvargs.escape_f
  local do_escape = escape_f and function (s)
debug_msg('do_escape =', s)
    if #s>0 then
      return { escape_f, s }
    end
  end or f_noop
  local alter_f   = kvargs.alter_f
  local do_alter = alter_f and function (s)
debug_msg('do_alter =', s)
    if #s>0 then
      return { alter_f, s }
    end
  end or f_noop
  local active_f  = kvargs.active_f
  local do_active = active_f and function (s)
debug_msg('do_active =', s)
    if #s>0 then
      return { active_f, s }
    end
  end or f_noop
  local ds = self.delimiters
  local n = utf8.len(ds)
  if n>0 then
    local p_l = assert(P(utf8.sub(ds, 1, 1)))
    local p_u = C((p_1 - p_l)^0) / do_active
    local p_e
    if n>1 then
      local p_m = P(utf8.sub(ds, 2, 2))
      if n > 2 then
        local p_r = P(utf8.sub(ds, 3, 3))
        p_e = p_l
            * C((p_1 - p_m - p_r)^0) / do_escape
            * ( p_m * C((p_1 - p_r)^0) / do_alter )^-1
            * p_r^-1
      else
        p_e = p_l
            * C((p_1 - p_m)^0) / do_escape
            * p_m^-1
      end
      pattern = p_u * ( p_e * p_u )^0
    else
      p_e = p_l * C(p_1^0) / do_escape
      pattern = p_u * p_e^0
    end
  else
    pattern = C(p_1^0) / do_active
  end
  pattern = Ct( pattern )
  return function (l)
    local t = pattern:match(l)
debug_msg(t, #t)
    for _,v in ipairs(t) do
      v[1](v[2])
    end
  end
end
%    \end{MacroCode}
%
% \begin{function}{Block.pyg_teardown}
% \begin{syntax}
% CDR.Block:pyg_teardown()
% \end{syntax}
% Records the contents of the \metatt{tags clist var} \LaTeX{} variable
% to prepare block hilighting.
% \end{function}
%    \begin{MacroCode}[OK]
function Block:pyg_teardown()
  local ll = self.lines
  if #ll > 0 then
    local s
    local append_f = function (text)
      s = s..text
    end
    local escape_inside = self:escape_inside_maker {
      active_f   = append_f,
      escape_f   = f_noop,
      alter_f    = append_f,
    }
    local code
    local t = {}
    for _,l in ipairs(ll) do
      s = ''
      t[#t+1] = escape_inside(l)
    end
    code = table.concat(t,'\n')
    t = {
      already = {},
      code = code
    }
    for tag in self['.tags clist']:gmatch('([^,]+)') do
      local tt = records_by_tag[tag] or {}
      records_by_tag[tag] = tt
      tt[#tt+1] = t
    end
  end
end
%    \end{MacroCode}
%
% \section{Exportation}
%
% For each file to be exported, \CDRSty{} calls |export_file|
% to initialize the exportation. Then it calls |export_file_info| to
% share the |tags|, |raw|, |preamble|, |postamble| data.
% Finally, |export_complete| is called to complete the exportation.
% \begin{function}{export_file}
% \begin{syntax}
% CDR:export_file(\meta{file name var})
% \end{syntax}
% This is called at export time.
% \metatt{file name var} is the name of an \pkg{str} variable
% containing the file name.
% \end{function}
%    \begin{MacroCode}[OK]
function CDR:export_file(file_name_var)
  local name = assert(token.get_macro(assert(file_name_var)))
  local export = {
    preamble = {},
    postamble = {},
  }
%    \end{MacroCode}
% \begin{function}{export_file_info, append_file_info}
% \begin{syntax}
% CDR:export_file_info(\meta{key}, \meta{value name var})
% CDR:append_file_info(\meta{key}, \meta{value name var})
% \end{syntax}
% This is called at export time.
% \metatt{value name var} is the name of an \pkg{str} variable
% containing the value.
% It must follow a call to |export_file|.
% \end{function}
%    \begin{MacroCode}[OK]
  function self.export_file_info(_, key, value)
    value = assert(token.get_macro(assert(value)))
    if export[key] == JSON_boolean_true or export[key] == JSON_boolean_false then
      export[key] = (value == 'true') and JSON_boolean_true or JSON_boolean_false
    else
      export[key] = value
    end
  end
  function self.append_file_info(_, key, value)
    local t = export[key]
    value = assert(token.get_macro(assert(value)))
    t[#t+1] = value
  end
%    \end{MacroCode}
% \begin{function}{export_complete}
% \begin{syntax}
% CDR:export_complete()
% \end{syntax}
% This is called at export time.
% \end{function}
%    \begin{MacroCode}[OK]
  function self.export_complete(this)
    local raw  = export.raw  == 'true'
    local once = export.once == 'true'
    local tags = export.tags
    local tt = {}
    local s, _
print('**** CDR', tags, raw, once)
    if not raw then
      s = export.preamble
      for _,t in ipairs(s) do
        tt[#tt+1] = t
      end
    end
    for tag in string.gmatch(export.tags, '([^,]+)') do
      local Rs = records_by_tag[tag]
      if Rs then
        for _,R in ipairs(Rs) do
          if not R.already[name] or not once then
            tt[#tt+1] = R.code
          end
          if once then
            R.already[name] = true
          end
        end
      end
    end
    if not raw then
      s = export.postamble
      for _,t in ipairs(s) do
        tt[#tt+1] = t
      end
    end
print('**** CDR', name, #tt)
    if #tt>0 then
      if #tt[#tt] > 0 then
        tt[#tt+1] = ''
      end
      local fh = assert(io.open(name,'w'))
      fh:write(table.concat(tt, '\n'))
      fh:close()
    end
    this.export_file_info = nil
    this.append_file_info = nil
    this.export_complete = nil
  end
end
%    \end{MacroCode}
%
% \section{\texorpdfstring{Sync\TeX}{SyncTeX}}
%
% \begin{function}{synctex_tag_set}
% \begin{syntax}
% CDR.\metatt{Object}:synctex_tag_set(\meta{new tag})
% \end{syntax}
% Set the Sync\TeX\ tag, does nothing if the argument is not positive.
% When \metatt{Object} is not provided,
% `|Code|' or `|Block|' is given according to the context.
% \end{function}
%    \begin{MacroCode}
function Object:synctex_tag_set(tag)
debug_msg('Object.synctex_tag_set', tag)
  if assert(tag, 'Unexpected nil tag') > 0 then
    self.synctex_tag  = tag
  end
end
function CDR:synctex_tag_set(tag)
  if CDR.Block then
    CDR.Block:synctex_tag_set(tag)
  elseif CDR.Code then
    CDR.Code:synctex_tag_set(tag)
  end
end
%    \end{MacroCode}
%
% \begin{function}{synctex_line_set}
% \begin{syntax}
% CDR.\metatt{Object}:synctex_line_set(\meta{new line})
% CDR:synctex_line_set(\meta{new line})
% \end{syntax}
% Set the Sync\TeX\ line, does nothing if the argument is not positive.
% When \metatt{Object} is not provided,
% `|Code|' or `|Block|' is given according to the context.
% \end{function}
%    \begin{MacroCode}
function Object:synctex_line_set(line)
debug_msg('Object.synctex_line_set', line)
  if line >= 0 then
    self.synctex_line  = line
  end
end
function CDR:synctex_line_set(tag)
  if CDR.Block then
    CDR.Block:synctex_line_set(tag)
  elseif CDR.Code then
    CDR.Code:synctex_line_set(tag)
  end
end
%    \end{MacroCode}
%
% \begin{function}{synctex_save}
% \begin{syntax}
% CDR.\metatt{Object}:synctex_save()
% \end{syntax}
% Save the Sync\TeX\ state.
% Change the mode to 1.
% This is not a stack management.
% \end{function}
%    \begin{MacroCode}
function Object:synctex_save(offset)
  self:synctex_tag_set(tex.get_synctex_tag())
  self:synctex_line_set(tex.inputlineno+(offset or 0))
  self.synctex_mode = tex.get_synctex_mode()
  tex.set_synctex_mode(1)
end
%    \end{MacroCode}
%
% \begin{function}{synctex_restore}
% \begin{syntax}
% CDR.\metatt{Object}:synctex_restore()
% \end{syntax}
% Save the Sync\TeX\ state.
% \end{function}
%    \begin{MacroCode}
function Object:synctex_restore()
  tex.force_synctex_tag(self.synctex_tag)
  tex.force_synctex_line(self.synctex_line)
  tex.set_synctex_mode(self.synctex_mode)
  self.synctex_tag = 0
  self.synctex_line = 0
end
%    \end{MacroCode}
%
% \begin{function}{synctex_target_set}
% \begin{syntax}
% CDR.\metatt{Object}:synctex_state_set(\meta{line number})
% \end{syntax}
% Save the Sync\TeX\ state.
% \end{function}
%    \begin{MacroCode}
function Object:synctex_target_set(line_number)
debug_msg('Object.synctex_target_set', self.synctex_tag, self.synctex_line, line_number )
  tex.force_synctex_tag( self.synctex_tag )
  tex.force_synctex_line(self.synctex_line + line_number )
end
%    \end{MacroCode}
%
% Global storage for Sync\TeX\ anchors.
% Some Sync\TeX\ tag and lines may be used
% instead of the default ones, particularly when
% \pkg{pygments} is in use.
%
% \begin{function}{synctex_store, synctex_get, synctex_sprint_tag, synctex_sprint_line}
% \begin{syntax}
% CDR.\metatt{Object}:synctex_store(\meta{offset})
% value = CDR.\metatt{Object}:synctex_get\{'tag'$\vert$'line'\}
% CDR.\metatt{Object}:synctex_sprint_tag()
% CDR.\metatt{Object}:synctex_sprint_line()
% \end{syntax}
% Instance methods.
% In both cases, the unique argument is a table.
% The \meta{id} is a unique string identifier:
% dot syntax may help to ensure its uniqueness.
% When no \meta{id} is provided, the void string
% is used instead.
% |synctex_store_set| stores the values given
% for keys |tag| and |line|.
% |synctex_get| returns the value
% previously stored for the argument's item
% indexed 1.
% |synctex_sprint_tag| and
% |synctex_sprint_line| are straightforward,
% the \metatt{id} is the current id.
% \end{function}
%    \begin{MacroCode}[OK]
local synctex_storage = {}
function Object:synctex_store(offset)
  self:synctex_save( offset or 0 )
  local storage = synctex_storage[self.id] or {}
  synctex_storage[self.id] = storage
  storage.tag = self.synctex_tag
  storage.line = self.synctex_line
  self:synctex_restore()
end
function Object:synctex_get(key)
  local storage = synctex_storage[self.id] or {}
  local ans = storage[key]
  if ans then
    return ans
  end
  local f = ({
    tag  = tex.get_synctex_tag,
    line = tex.get_synctex_line,
  })[key]
  if f then
    return f()
  end
  return 0
end
function Object:synctex_sprint_tag()
  tex.sprint(self:synctex_get('tag'))
end
function Object:synctex_sprint_line()
  tex.sprint(self:synctex_get('line'))
end
%    \end{MacroCode}
%
% \section{Caching}
% We save some computation time by pygmentizing files only when necessary.
% The \CDRPy{} is expected to create a |*.pyg.sty| file for a style
% and a |*.pyg.tex| file for hilighted code.
% These files are cached during one whole \LaTeX{} run and possibly between
% different \LaTeX{} runs. Lua keeps track
% of both the style files created and hilighted code files created.
% \begin{function}{cache_clean_all, cache_record, cache_clean_unused}
% \begin{syntax}
% CDR:cache_clean_all()
% CDR:cache_record(\meta{style name.pyg.sty}, \meta{digest.pyg.tex})
% CDR:cache_clean_unused()
% \end{syntax}
% Instance methods.
% |cache_clean_all| removes any file in the cache directory named \texttt{\meta{jobname}.pygd}.
% This is automatically executed at the beginning of the document processing
% when there is no aux file.
% This can also be executed on demand with |\directlua{CDR:cache_clean_all()}|.
% The |cache_record| method stores both \metatt{style name.pyg.sty} and \metatt{digest.pyg.tex}.
% These are file names relative to the \texttt{\meta{jobname}.pygd} directory.
% |cache_clean_unused| removes any file in the cache directory \texttt{\meta{jobname}.pygd}
% except the ones that were previously recorded. This is executed at the end of the
% document processing.
% \end{function}
%    \begin{MacroCode}[OK]
function CDR:cache_clean_all()
  if not self.can_clean then
    return
  end
  local to_remove = {}
  for f in lfs.dir(dir_p) do
    to_remove[f] = true
  end
  for k,_ in pairs(to_remove) do
    os.remove(dir_p .. k)
  end
end
local style_set = {}
local colored_set = {}
function CDR:cache_record(pyg_sty_p, pyg_tex_p)
  if pyg_sty_p then
    style_set  [pyg_sty_p] = true
  end
  if pyg_tex_p then
    colored_set[pyg_tex_p] = true
  end
end
function CDR:cache_clean_unused()
  if not self.can_clean then
    return
  end
debug_msg('CACHE CLEAN UNUSED', dir_p)
  local to_remove = {}
  for f in lfs.dir(dir_p) do
    f = dir_p .. f
    if not style_set[f] and not colored_set[f] then
      to_remove[f] = true
    end 
  end
  for f,_ in pairs(to_remove) do
debug_msg('OS.REMOVE', f)
    os.remove(f)
  end
end
%    \end{MacroCode}
%
% \section{Import}
%
% \begin{function}{import_driver_get}
% \begin{syntax}
% CDR:import_driver_get(\metatt{name})
% \end{syntax}
% Get the driver with the given name.
% \end{function}
%    \begin{MacroCode}[OK]
function CDR:import_driver_get(args)
  local name = args.driver
debug_msg('import_driver_get', name)
  local path
  if name:match('%.lua$') then
    path = kpse.find_file(name)
  else
    path = kpse.find_file('coder-driver-'..name..'.lua')
  end
  local f, err = loadfile(path)
  if not f then
    tex.print([[\PackageError{coder}]]..'{Bad driver '
      ..name..'}{'..err..'}'
    )
    return
  end
  local status, driver = pcall(f)
  if status then
    if driver.setup then
      driver:setup(args)
    end
    driver.debug_msg = debug_msg
    return driver
  end
  tex.print([[\PackageError{coder}]]..'{Syntax error in '
    ..path..'}{'..driver..'}'
  )
end
%    \end{MacroCode}
%
% \begin{function}{synctex_tag_catch}
% \begin{syntax}
% CDR.Block:synctex_tag_catch(\metatt{path})
% \end{syntax}
% This must be called at the Lua\TeX\ level.
% at the end, the |synctex_tag_catched| of the receiver
% will contain the Sync\TeX\ tag for that file.
% \end{function}
%    \begin{MacroCode}[OK]
function Block:synctex_tag_catch(path)
debug_msg('synctex_tag_catch...', path)
  local pop = callback_push(
    'open_read_file',
    function (file_name)
debug_msg('synctex_tag_catch open_read_file', file_name)
      return {
        reader = function ()
debug_msg('synctex_tag_catch reader', tex.get_synctex_tag())
          self.synctex_tag_catched = tex.get_synctex_tag()
        end,
      }
    end,
    'CDRTagCatch'
  )
debug_msg('synctex_tag_catch... runtoks BEFORE INPUT')
  tex.runtoks(function ()
    debug_msg('BEFORE INPUT')
  end)
  CDR.run_toks('\\input{'..path..'}');
debug_msg('synctex_tag_catch... runtoks AFTER INPUT')
  tex.runtoks(function ()
    debug_msg('AFTER INPUT')
  end)
  pop()
debug_msg('synctex_tag_catched', self.synctex_tag_catched)
end
%    \end{MacroCode}
%
% \begin{function}{import_begin,
%   import_set_boolean,
%   import_set_integer,
%   import,
% }
% \begin{syntax}
% CDR.Block:import_begin(\metatt{tl source variable}, \metatt{tl driver variable})
% CDR.Block:import_set_boolean(\metatt{key}, \metatt{tl variable})
% CDR.Block:import_set_integer(\metatt{key}, \metatt{tl variable})
% CDR.Block:import()
% \end{syntax}
% These are the helpers to import a source file.
% The driver, source and various options are stored,
% then the process is launched by \CDRSty\ with
% instruction |CDR.Block:import()| which
% forwards to |import_process|.
% Implementation detail: all functions but the first are
% implemented dynamically. Local function helpers are named |fi_...|.
% \end{function}
%    \begin{MacroCode}[OK]
function Block:import_begin()
debug_msg('import_begin.......................................')
  token.set_macro('l_CDR_status_tl','')
  local args = {
    source = assert(token.get_macro('l_CDR_input_tl')),
    driver = assert(token.get_macro('l_CDR_driver_tl')),
    first_line = 1,
    last_line  = 0,
    show_code  = true,
    show_doc   = true,
  }
%    \end{MacroCode}
% Error checking:
%    \begin{MacroCode}[OK]
debug_msg('import_begin... DRIVER?')
  local d = CDR:import_driver_get(args)
  if not d then
    token.set_macro('l_CDR_status_tl', 'FAILED')
    return
  end
%    \end{MacroCode}
% We read the file all at once in memory
% because we must know in advance the number
% of lines.
%    \begin{MacroCode}[OK]  
  local lines = {}
  local source = args.source
  local f = io.open(source)
  if not f then
    source = kpse.find_file(source)
    if source then
      f = io.open(source)
    end
    if not f then
      token.set_macro('l_CDR_status_tl', 'FAILED')
      tex.print([[\PackageError{coder}]]..'{No source '
      ..args.source..
      '}'..[[{See \string\CDRBlockImport.}]])
      return
    end
  end
  for l in f:lines() do
    lines[#lines+1] = l
  end
  f:close()
debug_msg('\\CDRBlockImport raw file:', source, #lines)
  self.import_set_boolean = nil
  self:synctex_save()
  self.synctex_save = f_noop
  self.synctex_restore = f_noop
  local n = 0
  local MT = {
    append = function (this, line)
      this.lines[#this.lines+1] = line
    end
  }
  local current
  local all = {}
  local function fi_code_new ()
    current = setmetatable({
      is_code = true,
      n = n,
      lines = {},
    }, { __index = MT
    })
    all[#all+1] = current
  end
  local function fi_doc_new ()
    current = setmetatable({
      is_doc = true,
      lines = {},
    }, { __index = MT
    })
    all[#all+1] = current
  end
%    \end{MacroCode}
%    \begin{MacroCode}
  self:synctex_tag_set(self.synctex_tag_catched)
  self:synctex_line_set(0)
%    \end{MacroCode}
% This is \LaTeX\ inside code, so we start in code mode.
%    \begin{MacroCode}[OK]
  local flow
  local make_reader = function ()
    if #all == 0 then
      if args.first_line <= 0 then
        args.first_line = #lines + args.first_line
      end
      if args.last_line <= 0 then
        args.last_line = #lines + args.last_line
      end
debug_msg('\\CDRBlockImport make_reader', #lines,  args.first_line, args.last_line)
      fi_code_new()
      local depth = 0
      for i = args.first_line, args.last_line do
debug_msg('\\CDRBlockImport reader original', i, lines[i], d.open, d.close)
        n = i
        local l = lines[i]
        if d.open and d:open(l) then
debug_msg('OPEN')
          depth = depth + 1
          if current.is_code then
            fi_doc_new()
          end
        elseif d.close and d:close(l) then
debug_msg('CLOSE')
          if depth > 0 then
            depth = depth - 1
          else
            tex.print([[\PackageError{coder}]]..'{No source '
              ..args.source..
              '}'..[[{See \string\CDRBlockImport.}]])
            flow:go()
          end
          if depth == 0 then
            fi_code_new()
          end
        else
debug_msg('CONTINUE')
          current:append(l)
        end
      end
      if depth>0 then
        tex.sprint([[\PackageError{coder}]]
          ..'{Unbalanced comments in '
          ..args.source..
          '}'..[[{See \string\CDRBlockImport.}]])
        flow:go()
      end
%    \end{MacroCode}
% Remove the tables with only void lines.
%    \begin{MacroCode}[OK]
      local t = {}
      for _,tt in ipairs(all) do
        for _,line in ipairs(tt.lines) do
          if #line > 0 then
            t[#t+1] = tt
            break
          end
        end
      end
      all = t
%    \end{MacroCode}
% Merge consecutive docs.
%    \begin{MacroCode}[OK]
      current = table.remove(all, 1)
      if current then
        t = { current }
        while #all > 0 do
          local tt = table.remove(all, 1)
          if not current.is_doc == not tt.is_doc then
            for _,line in ipairs(tt.lines) do
              current.lines[#current.lines+1] = line
            end
          else
            current = tt
            t[#t+1] = tt
          end
        end
        all = t
      end
      t = {}
      for _,tt in ipairs(all) do
        if tt.is_code then
          t[#t+1] = [[\begin{CDRBlock}]]
            ..'[first number='..(tt.n+1)..',obey lines]'
        end
        for _,line in ipairs(tt.lines) do
          t[#t+1] = line
        end
        if tt.is_code then
          t[#t+1] = [[\end{CDRBlock}]]       
        end
      end      
      all = t
      for i,l in ipairs(all) do
        debug_msg('\\CDRBlockImport READER', i, l)
      end
    end
    local i = 0
    local close_expected
    return function (env)
      i = i+1
      if i>#all then
debug_msg('\\CDRBlockImport time to close', i, #all)
        assert(not close_expected, 'close MISSED')
        close_expected = true
      end
      debug_msg('\\CDRBlockImport reader', i, #all)
      return all[i]
    end
  end
  local pop = f_noop
  pop = callback_push (
    'open_read_file',
    function (file_name)
debug_msg('\\CDRBlockImport open_read_file', file_name)
      local close_f = function (env)
debug_msg('\\CDRBlockImport close', file_name)
        if d.teardown then
          d:teardown()
        end
        pop()
        pop = f_noop
        self.synctex_restore = nil
        self:synctex_restore()
      end
      local reader = make_reader()
debug_msg('\\CDRBlockImport READER ****************', #all)
      return {
        reader = function (env)
debug_msg('\\CDRBlockImport READER 1st, set close function and pop')
          env.close = close_f
          env.reader = reader
          pop()
          pop = f_noop
          return reader(env)
        end,
      }
    end,
    'CDRBlockImport'
  )
  function self.import_set_boolean(this, key, var)
    args[key] = assert(token.get_macro(var or 'l_CDR_a_tl')) == 'true'
debug_msg('import_set_boolean', key, args[key])
  end
  function self.import_set_integer(this, key, var)
    args[key] = tonumber(token.get_macro(var or 'l_CDR_a_tl'))
debug_msg('import_set_integer', key, args[key])
  end
debug_msg('import_begin...DONE')
end
function Block:import ()
  error('Build time error: unexpected import call.')
end
function Block:import_set_boolean ()
  error('Build time error: unexpected import_set_boolean call.')
end
function Block:import_set_integer ()
  error('Build time error: unexpected import_set_integer call.')
end
%    \end{MacroCode}
%
% \subsection{Scan}
%
% Here we scan from the \pkg{lua} side as far as possible.
%
% \begin{variable}{CDR.string_cctab}
% Store the catcode table number to be used by
% |token.set_macro|.
% Must be set as early as possible. 
% \end{variable}
%
% \begin{function}{CDR.print_string, CDR.sprint_string}
% Use |tex.print| or |tex.sprint| with the |CDR.string_cctab|.
% \end{function}
%    \begin{MacroCode}[OK]
CDR.print_string = function(...)
debug_msg('CDR.print_string', ...)
  tex.print(CDR.string_cctab, ...)
end
CDR.sprint_string = function(...)
debug_msg('CDR.sprint_string', ...)
  tex.sprint(CDR.string_cctab, ...)
end
%    \end{MacroCode}
%
% \begin{variable}{CDR.atletter_cctab}
% Store the catcode table number to be used by
% |token.set_macro|.
% Must be set as early as possible. 
% \end{variable}
%
% \begin{variable}{CDR.escape_cctab}
% Store the catcode regime in use at the begining of the document.
% \end{variable}
%
% \begin{function}{CDR.print_escape, CDR.sprint_escape}
% Use |tex.print| or |tex.sprint| with the |CDR.escape_cctab|.
% \end{function}
%    \begin{MacroCode}[OK]
CDR.print_escape = function(...)
debug_msg('CDR.print_escape', ...)
  tex.print(CDR.escape_cctab, ...)
end
CDR.sprint_escape = function(...)
debug_msg('CDR.sprint_escape', ...)
  tex.sprint(CDR.escape_cctab, ...)
end
%    \end{MacroCode}
%
% \section{Return the module}
%
% \begin{variable}{_DESCRIPTION}
% Short text description of the module.
%    \begin{MacroCode}[OK]
CDR._DESCRIPTION = [[Global coder utilities on the lua side]]
%    \end{MacroCode}
% \end{variable}
%
%    \begin{MacroCode}
return setmetatable(CDR, {
  __index = function (self, k)
    local ans
    if k == '_VERSION' then
      ans = token.get_macro('CDRFileVersion')
    elseif k == 'date' then
      ans = token.get_macro('CDRFileDate')
    end
    if ans ~= nil then
      rawset(self, k, ans)
      return ans
    end
  end
})
%    \end{MacroCode}
%    \begin{MacroCode}
%</lua>
%    \end{MacroCode}
%
% \part{\CDRPy{} implementation}
%
% The standard header is managed specially because of the way \pkg{docstrip} automatically 
% adds some header when extracting stuff from an archive.
% The next two lines are added by \pkg{docstrip} at the top of the preamble.
% 
%    \begin{MacroCode}[OK]
%<*py>
#! /usr/bin/env python3
# -*- coding: utf-8 -*-
%</py>
%    \end{MacroCode}
%
% \section{Usage}
% Run: \texttt{\CDRPy{} -h}.
%
% \section{Header and global declarations}
% 
%    \begin{MacroCode}[OK]
%<*py>
__version__ = '0.10'
__YEAR__  = '2022'
__docformat__ = 'restructuredtext'

import sys
import os
import argparse
import re
from pathlib import Path
import json
from pygments import highlight as hilight
from pygments.formatters.latex import LatexEmbeddedLexer, LatexFormatter
from pygments.lexers import get_lexer_by_name
from pygments.util import ClassNotFound
%    \end{MacroCode}
%
% \section{\texttt{Options} classes}
% |Object| is used to turn a dictionary into a full fledged object.
% The real class is given by the |__cls__| key.
%  
%    \begin{MacroCode}[OK]
class BaseOpts(object):
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
  def __init__(self, d={}):
    for k, v in d.items():
      setattr(self, k, v)
%    \end{MacroCode}
%
% \subsection{\texttt{TeXOpts} class}
%
%    \begin{MacroCode}
class TeXOpts(BaseOpts):
  tags      = ''
  is_inline  = True
  pyg_sty_p = None
  synctex_tag  = 0
  synctex_line = 0
  tabsize = 4
%    \end{MacroCode}
% The templates are provided by \CDRSty{}.
% The style template wraps the style definitions provided by \pkg{pygments}.
% It may include the style name
%    \begin{MacroCode}
  sty_template=r'''% !TeX root=...
\makeatletter
\CDR@StyleDefine{<placeholder:style_name>}{%
  \CDR@Debug{Loading style <placeholder:style_name>...}%
  <placeholder:style_defs>%
  \CDR@Debug{... DONE}%
}%
\makeatother'''
  def __init__(self, *args, **kvargs):
    super().__init__(*args, **kvargs)
    self.pyg_sty_p = Path(self.pyg_sty_p or '')
    self.tabsize = abs(int(self.tabsize))
%    \end{MacroCode}
%
% \subsection{\texttt{PygOpts} class}
% \pkg{pygments} |LaTeXFormatter| options.
% Some of them may be deliberately unused.
% In particular, line numbering is governed by \pkg{fancyvrb} options.
% The description of these options is in a forthcoming section.
%    \begin{MacroCode}
class PygOpts(BaseOpts):
  style = 'default'
  nobackground = False
  linenos = False
  linenostart = 1
  linenostep = 1
  commandprefix = 'Py'
  texcomments = False
  mathescape =  False
  escapeinside = ""
  envname = 'Verbatim'
  lang = 'tex'
  gobble = 0
  def __init__(self, *args, **kvargs):
    super().__init__(*args, **kvargs)
    self.linenostart = abs(int(self.linenostart))
    self.linenostep  = abs(int(self.linenostep))
    self.gobble  = abs(int(self.gobble))
%    \end{MacroCode}
%
% \subsection{\texttt{Arguments}class}
%
%    \begin{MacroCode}
class Arguments(BaseOpts):
  cache  = False
  debug  = False
  source = ""
  style  = "default"
  json   = ""
  directory = "."
  texopts = TeXOpts()
  pygopts = PygOpts()
%    \end{MacroCode}
% \section{\texttt{Controller} main class}
%    \begin{MacroCode}[OK]
class Controller:
%    \end{MacroCode}
%
% \subsection{Static methods}
%
% \begin{function}{object_hook}
% Helper for json parsing.
% \end{function}
%    \begin{MacroCode}[OK]
  @staticmethod
  def object_hook(d):
    __cls__ = d.get('__cls__', 'Arguments')
    if __cls__ == 'PygOpts':
      return PygOpts(d)
    elif __cls__ == 'TeXOpts':
      return TeXOpts(d)
    elif __cls__ == 'BooleanTrue':
      return True
    elif __cls__ == 'BooleanFalse':
      return False
    else:
      return Arguments(d)
%    \end{MacroCode}
%
% \begin{function}{lua_command,lua_command_now,lua_debug}
% \begin{syntax}
% self.lua_command(\meta{asynchronous lua command})
% self.lua_command_now(\meta{synchronous lua command})
% \end{syntax}
% Wraps the given command between markers. It will be in the output of the
% \CDRPy{}, further captured by \CDRLua{}
% and either forwarded to \TeX{} ot executed synchronously.
% \end{function}
%    \begin{MacroCode}[OK]
  @staticmethod
  def lua_command(cmd):
    print(f'<<<<<*LUA:{cmd}>>>>>')
  @staticmethod
  def lua_command_now(cmd):
    print(f'<<<<<!LUA:{cmd}>>>>>')
  @staticmethod
  def lua_debug(msg):
    print(f'<<<<<?LUA:{msg}>>>>>')
%    \end{MacroCode}
%
% \begin{function}{lua_text_escape}
% \begin{syntax}
% self.lua_text_escape(\meta{text})
% \end{syntax}
% Wraps the given command between |[=...=[| and |]=...=]|
% with as many equal signs as necessary to ensure a correct |lua| syntax.
% \end{function}
%    \begin{MacroCode}[OK]
  @staticmethod
  def lua_text_escape(s):
    k = 0
    for m in re.findall('=+', s):
      if len(m) > k: k = len(m)
    k = (k + 1) * "="
    return f'[{k}[{s}]{k}]'
%    \end{MacroCode}
%
% \subsection{Computed properties}
%
% \begin{variable}{self.json_p}
% The full path to the \texttt{json} file containing all the data used for the processing.
% \end{variable}
%    \begin{MacroCode}[OK]
  _json_p = None
  @property
  def json_p(self):
    p = self._json_p
    if p:
      return p
    else:
      p = self.arguments.json
      if p:
        p = Path(p).resolve()
    self._json_p = p
    return p
%    \end{MacroCode}
%
% \begin{variable}{self.parser}
% The correctly set up \texttt{argarse} instance. 
% \end{variable}
%    \begin{MacroCode}[OK]
  @property
  def parser(self):
    parser = argparse.ArgumentParser(
      prog=sys.argv[0],
      description='''
Writes to the output file a set of LaTeX macros describing
the syntax hilighting of the input file as given by pygments.
'''
    )
    parser.add_argument(
      "-v", "--version",
      help="Print the version and exit",
      action='version',
      version=f'coder-tool version {__version__},'
      ' (c) {__YEAR__} by Jérôme LAURENS.'
    )
    parser.add_argument(
      "--debug",
      action='store_true',
      default=None,
      help="display informations useful for debugging"
    )
    parser.add_argument(
      "--create_style",
      action='store_true',
      default=None,
      help="create the style definitions"
    )
    parser.add_argument(
      "--base",
      action='store',
      default=None,
      help="the path of the file to be colored, with no extension"
    )
    parser.add_argument(
      "json",
      metavar="<json data file>",
      help="""
file name with extension, contains processing information.
"""
    )
    return parser

%    \end{MacroCode}
%
% \subsection{Methods}
% \subsubsection{\texorpdfstring{\texttt{__init__}}{init}}
% \begin{function}{__init__}
% Constructor. Reads the command line arguments.
% \end{function}
%    \begin{MacroCode}[OK]
  def __init__(self, argv = sys.argv):
    argv = argv[1:] if re.match(".*coder\-tool\.py$", argv[0]) else argv
    ns = self.parser.parse_args(
      argv if len(argv) else ['-h']
    )
    with open(ns.json, 'r') as f:
      self.arguments = json.load(
        f,
        object_hook = Controller.object_hook
      )
    args = self.arguments
    args.json = ns.json
    texopts = self.texopts = args.texopts
    pygopts = self.pygopts = args.pygopts
    self.formatter = LatexFormatter(
      style = pygopts.style,
      nobackground = pygopts.nobackground,
      commandprefix = pygopts.commandprefix,
      texcomments  = pygopts.texcomments,
      mathescape   = pygopts.mathescape,
      escapeinside = pygopts.escapeinside,
      envname = 'CDR@Pyg@Verbatim',
    )

    try:
      lexer = self.lexer = get_lexer_by_name(pygopts.lang)
    except ClassNotFound as err:
      sys.stderr.write('Error: ')
      sys.stderr.write(str(err))

    escapeinside = pygopts.escapeinside
    # When using the LaTeX formatter and the option `escapeinside` is
    # specified, we need a special lexer which collects escaped text
    # before running the chosen language lexer.
    if len(escapeinside) == 2:
      left  = escapeinside[0]
      right = escapeinside[1]
      lexer = self.lexer = LatexEmbeddedLexer(left, right, lexer)
    elif len(escapeinside) == 3:
      left   = escapeinside[0]
      middle = escapeinside[1]
      right  = escapeinside[2]
      lexer  = self.lexer = LatexEmbeddedLexer(left, right, lexer)

    gobble = pygopts.gobble
    if gobble:
      lexer.add_filter('gobble', n=gobble)
    tabsize = texopts.tabsize
    if tabsize:
      lexer.tabsize = tabsize
    lexer.encoding = ''
    args.base = ns.base
    args.create_style = ns.create_style
    if ns.debug:
      args.debug = True
    # IN PROGRESS: support for extra keywords
    # EXTRA_KEYWORDS = set(('foo', 'bar', 'foobar', 'barfoo', 'spam', 'eggs'))
    # def over(self, text):
    #   for index, token, value in lexer.__class__.get_tokens_unprocessed(self, text):
    #     if token is Name and value in EXTRA_KEYWORDS:
    #       yield index, Keyword.Pseudo, value
    #   else:
    #       yield index, token, value
    # lexer.get_tokens_unprocessed = over.__get__(lexer)

%    \end{MacroCode}
%
% \subsubsection{\texttt{create\texorpdfstring{_}{-}style}}
% \begin{function}{self.create_style}
% \begin{syntax}
% self.create_style()
% \end{syntax}
% Where the \meta{style} is created.
% Does quite nothing if the style is already available.
% \end{function}
%    \begin{MacroCode}[OK]
  def create_style(self):
    args = self.arguments
    if not args.create_style:
      return
    texopts = args.texopts
    pyg_sty_p = texopts.pyg_sty_p
    if args.cache and pyg_sty_p.exists():
      return
    style = self.pygopts.style
    formatter = self.formatter
    style_defs = formatter.get_style_defs() \
      .replace(r'\makeatletter', '') \
      .replace(r'\makeatother', '') \
      .replace('\n', '%\n')
    sty = self.texopts.sty_template.replace(
      '<placeholder:style_name>',
      style,
    ).replace(
      '<placeholder:style_defs>', 
      style_defs,
    ).replace(
      '{}%',
      '{%}\n}%{'
    ).replace(
      '[}%',
      '[%]\n}%'
    ).replace(
      '{]}%',
      '{%[\n]}%'
    )
    with pyg_sty_p.open(mode='w',encoding='utf-8') as f:  
      f.write(sty)
    if args.debug:
      print('STYLE', os.path.relpath(pyg_sty_p))
%    \end{MacroCode}
%
% \subsubsection{\texttt{pygmentize}}
% \begin{function}{self.pygmentize}
% \begin{syntax}
% \meta{code variable} = self.pygmentize(\meta{code}[, inline=\meta{yorn}])
% \end{syntax}
% Where the \meta{code} is hilighted by \pkg{pygments}.
% \end{function}
%    \begin{MacroCode}[OK]
  def pygmentize(self, source):
    source = hilight(source, self.lexer, self.formatter)
    m = re.match(
      r'\\begin{CDR@Pyg@Verbatim}.*?\n(.*?)\n\\end{CDR@Pyg@Verbatim}\s*\Z',
      source,
      flags=re.S
    )
    assert(m)
    hilighted = m.group(1)
    texopts = self.texopts
    if texopts.is_inline:
      s = r'\CDR@Setup{'
      if texopts.synctex_tag:
        s += f'synctex_tag={texopts.synctex_tag},'
      if texopts.synctex_line:
        s += f'synctex_line={texopts.synctex_line},'
      s+='}'
      return s + hilighted +r'\ignorespaces'
    lines = hilighted.split('\n')
    ans_code = []
    last = 0
    for line in lines:
      last += 1
      ans_code.append(rf'''\CDR@Line{{{last}}}{{{line}}}''')
    if last:
      s = r'\CDR@Setup{'
      s += f'last={last},'
      if texopts.synctex_tag:
        s += f'synctex_tag={texopts.synctex_tag},'
      if texopts.synctex_line:
        s += f'synctex_line={texopts.synctex_line},'
      s+='}'
      ans_code.insert(0, s)
    hilighted = '\n'.join(ans_code)
    return hilighted
%    \end{MacroCode}
%
% \subsubsection{\texorpdfstring{\texttt{create_pygmented}}{create-pygmented}}
% \begin{function}{self.create_pygmented}
% \begin{syntax}
% self.create_pygmented()
% \end{syntax}
% Call \texttt{self.pygmentize} and save the resulting pygmented code
% at the proper location.
% \end{function}
%    \begin{MacroCode}[OK]
  def create_pygmented(self):
    args = self.arguments
    base = args.base
    if not base:
      return False
    source = args.source
    if not source:
      tex_p = Path(base).with_suffix('.tex')
      with open(tex_p, 'r') as f:
        source = f.read()
    if args.debug:
      print('SOURCE', source)
    pyg_tex_p = Path(base).with_suffix('.pyg.tex')
    hilighted = self.pygmentize(source)
    with pyg_tex_p.open(mode='w',encoding='utf-8') as f:
      f.write(hilighted)
    if args.debug:
      print('HILIGHTED', os.path.relpath(pyg_tex_p), hilighted)
%    \end{MacroCode}
%
% \subsection{Main entry}
%
%    \begin{MacroCode}[OK]
if __name__ == '__main__':
  try:
    ctrl = Controller()
    x = ctrl.create_style() or ctrl.create_pygmented()
    print(f'{sys.argv[0]}: done')    
    sys.exit(x)
  except KeyboardInterrupt:
    sys.exit(1)
%</py>
%    \end{MacroCode}
%
% \part{\CDRSty{} implementation}
%    \begin{MacroCode}
%<*sty>
\makeatletter
%    \end{MacroCode}
%
% \section{Setup}
%
% \subsection{\string\CDRMeta}
% 
% \begin{function}{\CDRMeta,\CDRMeta*,\CDRMetaFormat}
% \begin{syntax}
% \cs{CDRMeta} \Arg{description}
% \cs{CDRMeta*} \Arg{description}
% \cs{CDRMetaFormat}
% \end{syntax}
% Typeset the \meta{description} with \cs{CDRMetaFormat}
% and enclosed between the angle brackets $\langle$ and $\rangle$.
% The starred version is typeset in tt when not in tt,
% and in default font oherwise.
% \cs{CDRMetaFormat} can be redefined by the user to add color for example.
% \end{function}
%    \begin{MacroCode}
\DeclareDocumentCommand \CDRMeta { s m }
  { \CDR_meta:nn {#1} { #2 } }
\cs_new_protected:Npn \CDR_meta:nn #1 #2 {
  \tl_set:Nn \l_CDR_a_tl {#2}
  \tl_map_inline:nn {
    3 4 7 8 { 11 } { 12 } { 13 }
  } {
    \tl_set_rescan:Nnn \l_CDR_b_tl {
      \char_set_catcode:nn { `_ } {##1}
    } { _ }
    \exp_args:NNV
    \tl_replace_all:Nnn \l_CDR_a_tl \l_CDR_b_tl
      { \CDRMeta_sub:n }
  }
  \exp_args:NnV \CDRMeta_angle:nn { #1 } \l_CDR_a_tl
}
\cs_new_protected:Npn \CDRMeta_sub:n #1 {
  \ensuremath { \sb {#1} }
}
\cs_new_protected:Npn \CDRMetaFormat:n #1 {
  \CDRMetaFormat
  \IfBooleanTF { #1 } {
    \group_begin:
    \ttfamily
    \exp_args:NNNV
    \group_end:
    \exp_args:NnV
    \tl_if_eq:nnTF\f@family\f@family {
      \fontfamily{\familydefault}\selectfont
    } {
      \ttfamily
    }
  } { }
}
\cs_new_protected:Npn \CDRMeta_angle:nn #1 #2 {
  \ensuremath \langle
  \mode_if_math:T { \nfss@text }
  {
    \CDRMetaFormat:n { #1 }
    \edef \CDR: {
      \hyphenchar \the \font \the \hyphenchar \font
    }
    \hyphenchar \font \m@ne
    \language \l@nohyphenation
    #2 \/
    \CDR:
  }
  \ensuremath \rangle
}
\tl_const:Nn \CDRMetaFormat { \slshape }
%    \end{MacroCode}
%
%
% \subsection{Utilities}
%
% \begin{function}{\CDR_set_conditional:Nn}
% \begin{syntax}
% \cs{CDR_set_conditional:Nn} \meta{core name} \Arg{condition}
% \end{syntax}
% Wrapper over |\prg_set_conditional:Nnn|.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_set_conditional:Nn #1 #2 {
  \bool_if:nTF { #2 } {
    \prg_set_conditional:Nnn #1 { p, T, F, TF } { \prg_return_true: }
  } {
    \prg_set_conditional:Nnn #1 { p, T, F, TF } { \prg_return_false: }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_set_conditional_alt:Nn}
% \begin{syntax}
% \cs{CDR_set_conditional_alt:Nnnn} \meta{core name} \Arg{condition}
% \end{syntax}
% Wrapper over |\prg_set_conditional:Nnn|.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_set_conditional_alt:Nn #1 #2 {
  \prg_set_conditional:Nnn #1 { p, T, F, TF } {
    \bool_if:nTF { #2 } { \prg_return_true: } { \prg_return_false: }
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP,pTF]
%   {\CDR_has_pygments:}
%   \begin{syntax}
%     \cs{CDR_has_pygments:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \metatt{true code} when \pkg{pygments} is available,
% \meta{false code} otherwise.
% \emph{Implementation detail}: we define the conditionals to raise and set
% them later by a call to |\CDR_pygments_setup:n|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
  \PackageError { coder } { Internal~error(pygments~path) } { Please~report~error }
}
%    \end{MacroCode}
%
% \begin{function} { \CDR_pygments_setup:n }
%   \begin{syntax}
%     \cs{CDR_pygments_setup:n} \Arg{boolean string}
%   \end{syntax}
% Set up the conditional set |\CDR_has_pygments...| according to \metatt{boolean string}. When this string is |true|, then \pkg{\jobname} has pygments, it has not otherwise.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_pygments_setup:n #1 {
  \cs_undefine:N \CDR_has_pygments:T
  \cs_undefine:N \CDR_has_pygments:F
  \cs_undefine:N \CDR_has_pygments:TF
  \cs_undefine:N \CDR_has_pygments_p:
  \str_if_eq:nnTF { #1 } { true } {
    \prg_new_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
      \prg_return_true:
    }
  } {
    \prg_new_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
      \prg_return_false:
    }
  }
}
\cctab_const:Nn \c_CDR_escape_cctab { }
\directlua {
  CDR = require("coder-util");
  CDR.string_cctab = \the\catcodetable@string;
  CDR.atletter_cctab = \the\catcodetable@atletter;
  CDR.escape_cctab = \the\c_CDR_escape_cctab;
  CDR.code_cctab = \the\c_code_cctab;
CDR.debug('string_cctab', CDR.string_cctab);
CDR.debug('atletter_cctab', CDR.atletter_cctab);
CDR.debug('escape_cctab', CDR.escape_cctab);
CDR.debug('code_cctab', CDR.escape_cctab);
}
%    \end{MacroCode}
% The shared token register.
%    \begin{MacroCode}
\newtoks\CDR@toks
%    \end{MacroCode}
% Catch the current catcode table after all packages are loaded.
%    \begin{MacroCode}
\exp_args:Nx \CDR_pygments_setup:n {
  \directlua { CDR:set_python_path() }
}
\cs_new:Npn \CDR_pygments_setup: {
  \sys_get_shell:nnNTF {which~pygmentize} { \cc_select:N \c_str_cctab } \l_CDR_a_tl {
    \tl_if_in:NnTF \l_CDR_a_tl { pygmentize } {
      \prg_set_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
        \prg_return_true:
      }  
    } {
      \prg_set_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
        \prg_return_false:
      }  
    }
  } {
    \typeout {Shell~escape~is~not~available}
  }
}
%    \end{MacroCode}
%
%    \begin{MacroCode}
\NewDocumentCommand \CDRTest {} {
  \par\noindent
  Engine~is~\c_sys_engine_str(\c_sys_engine_exec_str)
  \sys_if_engine_luatex:F {:~\textcolor{red}{change~to~required~Lua\TeX}.}
  \par\noindent
  \sys_if_shell:TF {
    System~calls~enabled~(\texttt{--shell-escape}~mode)
  } {
    \sys_if_shell_restricted:TF {
      Restricted~system~calls~enabled~(\verb|--restricted-shell| mode):~check~your~\texttt{texmf.mf}~for~\textff{python}~availability.
    } {
      System~calls~disabled:~\tetcolor{red}{use~\texttt{--shell-escape}}
    }
  }
  \par\noindent
  Path~to~\textsf{python}:~\texttt{\directlua{tex.print(PYTHON_PATH)}}
  \par\noindent
  Path~to~\textsf{pygmentize}:~\texttt{\directlua{tex.print(PYGMENTIZE_PATH)}}
  \par\noindent
  \CDR_has_pygments:TF { Pygments~is~available } { Pygments~is~not~available
}:~\CDRCode|\textit{text}|
  \par\noindent
}
%    \end{MacroCode}
% Undocumented debug utility.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRDebugOn {
  \cs_set:Npn \CDR@Debug ##1 {
    \tl_if_empty:NTF \CurrentFile {
      \typeout { ****~CDR:\jobname :\the\inputlineno :\space##1}
    } {
      \typeout { ****~CDR:\CurrentFile :\the\inputlineno :\space##1}
    }
  }
  \directlua { CDR:activate_debug(true) }
}
\cs_new:Npn \CDRDebugOff {
  \cs_set_eq:NN \CDR@Debug \use_none:n
  \directlua { CDR:activate_debug(false) }
}
%    \end{MacroCode}
% \section{Messages}
%    \begin{MacroCode}[OK]
\msg_new:nnn { coder } { unknown-choice } {
  #1~given~value~`#3'~not~in~#2
}
%    \end{MacroCode}
% \section{Constants}
% \begin{variable}{\c_CDRTags,\c_CDR_Tag}
% Paths of \pkg{L3keys} modules.\\
% These are root path components used throughout the pakage.
% The latter is a subpath of the former.
%    \begin{MacroCode}[OK]
\str_const:Nn \c_CDR_Tag { CDR@Tag }
\str_const:Nx \c_CDRTags { \c_CDR_Tag / tags }
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\c_CDRTag_get}
% Root identifier for tag properties, used throughout the pakage.
% \vspace{1\baselineskip}
%    \begin{MacroCode}[OK]
\str_const:Nn \c_CDRTag_get { CDR@tag@get }
%    \end{MacroCode}
% \end{variable}
%
% \section{Implementation details}
% As far as possible, macro making assignments
% to variables are protected.
% All variables following \pkg{expl3} naming conventions are
% implementation details and therefore must be considered private.
%
% Many functions have useful hooks for debugging or testing.
%
% \begin{function}{\CDR@Debug}
% \begin{syntax}
% \cs{CDR@Debug} \Arg{argument}
% \end{syntax}
% The default implementation just gobbles its argument.
% During development or testing, this may call |\typeout|.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR@Debug { \use_none:n }
%    \end{MacroCode}
% \end{function}
%
% \section{Variables}
%
% \subsection{Internal scratch variables}
% These local variables are used in a very limited scope.
% \begin{variable}{\l_CDR_bool}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\bool_new:N \l_CDR_bool
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_[a|b]_tl}
% Local scratch variables.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_a_tl
\tl_new:N \l_CDR_b_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_str}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\str_new:N \l_CDR_str
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_seq}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\seq_new:N \l_CDR_seq
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_prop}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\prop_new:N \l_CDR_prop
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_clist}
% The comma separated list of current chunks.
%    \begin{MacroCode}[OK]
\clist_new:N \l_CDR_clist
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\l_CDR_ior}
% Input file identifier
%    \begin{MacroCode}[OK]
\ior_new:N \l_CDR_ior
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\l_CDR_kv_clist}
% keyval storage.
%    \begin{MacroCode}
\clist_new:N \l_CDR_kv_clist
%    \end{MacroCode}
% \end{variable}
%
% \subsection{Counters}
%
% \begin{function}{\CDR_int_new:cn}
% \begin{syntax}
% \cs{CDR_int_new:cn} \Arg{tag name} \Arg{value}
% \end{syntax}
% Create an integer after \metatt{tag name} and
% set it globally to \metatt{value}.
%    \begin{MacroCode}
\cs_new:Npn \CDR_int_new:cn #1 #2 {
  \int_new:c { CDR@int.#1 }
  \int_gset:cn { CDR@int.#1 } { #2 }
}
%    \end{MacroCode}
% \end{function}
% \begin{variable}{default}
% Generic and named line number counter.
%    \begin{MacroCode}[OK]
\CDR_int_new:cn { default } { 1 }
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{__p}
% Generic and named line number counter.
% Used for physical line numbering.
%    \begin{MacroCode}[OK]
\CDR_int_new:cn { __p } { 1 }
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\l_CDR_p_tl, \CDRLine_physical_set:n}
% \begin{syntax}
% \cs{CDRLine_physical_set:n} \Arg{integer}
% \end{syntax}
% Setter, used to set the associate |\l_CDR_p_tl| variable accordingly.
% \end{function}
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_p_tl
\cs_new:Npn \CDRLine_physical_set:n #1 {
  \CDR_int_set:cn { __p }  { #1 }
  \tl_set:Nx \l_CDR_p_tl { \CDR_int_use:c { __p } }
  \CDR@Debug{physical:~\l_CDR_p_tl}
}
%    \end{MacroCode}
%
% \begin{variable}{__l}
% Generic and named line number counter.
% Used for logical line numbering, used for display.
%    \begin{MacroCode}[OK]
\CDR_int_new:cn { __l } { 1 }
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\l_CDR_l_tl, \CDRLine_logical_set:n}
% \begin{syntax}
% \cs{CDRLine_logical_set:n} \Arg{integer}
% \end{syntax}
% Setter, used to set the associate |\l_CDR_l_tl| variable accordingly.
% \end{function}
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_l_tl
\cs_new:Npn \CDRLine_logical_set:n #1 {
  \CDR_int_set:cn { __l }  { #1 }
  \tl_set:Nx \l_CDR_l_tl { \CDR_int_use:c { __l } }
  \CDR@Debug{logical:~\l_CDR_p_tl}
}
%    \end{MacroCode}
%
% \begin{variable}{__line}
% Generic and named line number counter.
%    \begin{MacroCode}[OK]
\CDR_int_new:cn { __line } { 1 }
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}[EXP]{\CDR_int:c}
% \begin{syntax}
% \cs{CDR_int:c} \Arg{tag name}
% \end{syntax}
% Use the integer named after \metatt{tag name}.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int:c #1 {
  \use:c { CDR@int.#1 }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[EXP]{\CDR_int_use:c}
% \begin{syntax}
% \cs{CDR_int_use:n} \Arg{tag name}
% \end{syntax}
% Use the value of the integer named after \metatt{tag name}.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_use:c #1 {
  \int_use:c { CDR@int.#1 }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {\CDR_int_if_exist:c}
%   \begin{syntax}
%     \cs{CDR_int_if_exist:cTF} \Arg{tag name} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \metatt{true code} when
% an integer named after \metatt{tag name} exists,
% \metatt{false code} otherwise.
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_int_if_exist:c { p, T, F, TF } {
  \int_if_exist:cTF { CDR@int.#1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[EXP,pTF]
%   {\CDR_int_compare:cNn}
%   \begin{syntax}
%     \cs{CDR_int_compare:cNnTF} \Arg{tag name} \meta{operator} \Arg{intexpr_2} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Forwards to |\int_compare...| with |\CDR_int_use:c { #1 }|.
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_int_compare:cNn { p, T, F, TF } {
  \int_compare:nNnTF { \CDR_int:c { #1 } } #2 { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_int_set:cn,\CDR_int_gset:cn}
% \begin{syntax}
% \cs{CDR_int_set:cn} \Arg{tag name} \Arg{value}
% \end{syntax}
% Set the integer named after \metatt{tag name} to the \metatt{value}. \cs{CDR_int_gset:cn} makes a global change.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_set:cn #1 #2 {
  \int_set:cn { CDR@int.#1 } { #2 }
}
\cs_new:Npn \CDR_int_gset:cn #1 #2 {
  \int_gset:cn { CDR@int.#1 } { #2 }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_int_set:cc,\CDR_int_gset:cc}
% \begin{syntax}
% \cs{CDR_int_set:cc} \Arg{tag name} \Arg{other tag name}
% \end{syntax}
% Set the integer named after \metatt{tag name} to the value of
% the integer named after \metatt{other tag name}.
% \cs{CDR_int_gset:cc} makes a global change.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_set:cc #1 #2 {
  \CDR_int_set:cn { #1 } { \CDR_int:c { #2 } }
}
\cs_new:Npn \CDR_int_gset:cc #1 #2 {
  \CDR_int_gset:cn { #1 } { \CDR_int:c { #2 } }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_int_add:cn,\CDR_int_gadd:cn}
% \begin{syntax}
% \cs{CDR_int_add:cn} \Arg{tag name} \Arg{value}
% \end{syntax}
% Add the \metatt{value} to the integer named after \metatt{tag name}.
% \cs{CDR_int_gadd:cn} makes a global change.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_add:cn #1 #2 {
  \int_add:cn { CDR@int.#1 } { #2 }
}
\cs_new:Npn \CDR_int_gadd:cn #1 #2 {
  \int_gadd:cn { CDR@int.#1 } { #2 }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_int_add:cc,\CDR_int_gadd:cc}
% \begin{syntax}
% \cs{CDR_int_add:cn} \Arg{tag name} \Arg{other tag name}
% \end{syntax}
% Add to the integer named after \metatt{tag name} the value of
% the integer named after \metatt{other tag name}.
% \cs{CDR_int_gadd:cc} makes a global change.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_add:cc #1 #2 {
  \CDR_int_add:cn { #1 } { \CDR_int:c { #2 } }
}
\cs_new:Npn \CDR_int_gadd:cc #1 #2 {
  \CDR_int_gadd:cn { #1 } { \CDR_int:c { #2 } }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_int_sub:cn,\CDR_int_gsub:cn}
% \begin{syntax}
% \cs{CDR_int_sub:cn} \Arg{tag name} \Arg{value}
% \end{syntax}
% Substract the \metatt{value} from the integer named after \metatt{tag name}. \cs{CDR_int_gsub:n} makes a global change.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_int_sub:cn #1 #2 {
  \int_sub:cn { CDR@int.#1 } { #2 }
}
\cs_new:Npn \CDR_int_gsub:cn #1 #2 {
  \int_gsub:cn { CDR@int.#1 } { #2 }
}
%    \end{MacroCode}
%
% \subsection{Utilities}
%
% \begin{variable}{\g_CDR_tags_clist, \g_CDR_all_tags_clist, \g_CDR_last_tags_clist}
% Store the current list of tags used by |\CDRCode| and the
% |CDRBlock| environment, or declared by |\CDRBlockExport|.
% All the tags are recorded, if there is an only one, it is not shown
% in block code chunks.
% The |\g_CDR_last_tags_clist| variable contains the last list of tags that was displayed.
%    \begin{MacroCode}[OK]
\clist_new:N \g_CDR_tags_clist
\clist_new:N \g_CDR_all_tags_clist
\clist_new:N \g_CDR_last_tags_clist
\AddToHook { shipout/before } {
  \clist_gclear:N \g_CDR_last_tags_clist
}
%    \end{MacroCode}
% \end{variable}
%
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_clist_if_eq:NN { p, T, F, TF } {
  \tl_if_eq:NNTF #1 #2 {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \subsection{White spaces}
%
% \begin{variable}{\c_CDR_active_cctab}
% Catcode table used to make the white space active.
% This is used to display spaces and tabs
% in verbatim context.
%    \begin{MacroCode}[OK]
\cctab_const:Nn \c_CDR_active_cctab {
  \cctab_select:N \c_str_cctab
  \char_set_catcode_active:n { `\^^I }  
  \char_set_catcode_active:n { `\    }
}
\directlua {
  CDR.active_cctab = \int_eval:n { 
    \c_CDR_active_cctab
  };
  CDR.code_cctab = \int_eval:n { 
    \c_code_cctab
  };
}
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDR_whitespace_define:}
% \begin{syntax}
% \cs{CDR_whitespace_define:}
% \end{syntax}
% Set the behavior of the white space characters
% in situations where they are active.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_set:Npn \CDR_whitespace_define: {%
\CDR@Debug{\string\CDR_whitespace_define:}%
  \char_set_active_eq:nN { `\^^I } \CDR@Tab
  \char_set_active_eq:nN { `\    } \CDR@Space
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_make_escape_inside:nNNN}
% \begin{syntax}
% \cs{CDR_make_escape_inside:nNNN} \Arg{delimiters} \Arg{unescape:n} \Arg{escape:n} \Arg{alt escaped:n}
% \end{syntax}
% Build the |\CDR_escape_inside:Nn| function based on the
% |escape inside| delimiters.
% \meta{unescape:n} is a function with one argument that is applied to the
% unescaped parts.
% Typically a rescan.
% \meta{escape:n} is a function with one argument that is applied to the
% escaped parts that are delimited by the two first delimiters.
% Typically a |\CDR_rescan_escape:n| or a |\use_none:n|.
% \meta{alt escaped:n} is a function with one parameter that is applied to the
% parts between the two last delimiters, when 3 delimiters are given.
% Typically a |\use:n| or |\use_none:n|.
% \end{function}
%    \begin{MacroCode}
\regex_new:N \l_CDR_scpnsd_regex
\seq_new:N   \l_CDR_scpnsd_seq
\tl_new:N    \l_CDR_scpnsd_tl
\cs_new_protected_nopar:Npn \CDR_make_escape_inside:nNNN #1 #2 #3 #4 {
\CDR@Debug{\string\CDR_make_escape_inside:nNNN}
  \cs_set:Npn \CDR_make_escape_inside_:NNn ##1 ##2 ##3 {
    \tl_put_right:Nn ##1 { ##2 { ##3 } }
  }
  \int_case:nnF { \tl_count:n { #1 } } {
    { 2 } {
      \regex_set:Nx \l_CDR_scpnsd_regex {
        [ \tl_item:nn { #1 } { 1 } ]
        (.*?)
        [ \tl_item:nn { #1 } { 2 } ]
      }
      \cs_set:Npn \CDR_escape_inside:Nn ##1 ##2 {
        \tl_clear:N ##1
        \regex_split:NnN \l_CDR_scpnsd_regex { ##2 } \l_CDR_scpnsd_seq
        \seq_if_empty:NTF \l_CDR_scpnsd_seq {
          \CDR_make_escape_inside_:NNn ##1 #2 { ##2 }
        } {
          \seq_pop_left:NN \l_CDR_scpnsd_seq \l_CDR_scpnsd_tl
          \exp_args:NNNV
          \CDR_make_escape_inside_:NNn ##1 #2 \l_CDR_scpnsd_tl
          \bool_while_do:nn { ! \seq_if_empty_p:N \l_CDR_scpnsd_seq } {
            \seq_pop_left:NN \l_CDR_scpnsd_seq \l_CDR_scpnsd_tl
            \exp_args:NNNV
            \CDR_make_escape_inside_:NNn ##1 #3 \l_CDR_scpnsd_tl
            \seq_pop_left:NN \l_CDR_scpnsd_seq \l_CDR_scpnsd_tl
            \exp_args:NNNV
            \CDR_make_escape_inside_:NNn ##1 #2 \l_CDR_scpnsd_tl
          }
        }  
      }
    }
    { 3 } {
      \regex_set:Nx \l_CDR_scpnsd_regex {
        [ \tl_item:nn { #1 } { 1 } ]
        (.*?) (?: [ \tl_item:nn { #1 } { 2 } ] (.*?) )?
        [ \tl_item:nn { #1 } { 3 } ]
      }
      \cs_set:Npn \CDR_escape_inside:Nn ##1 ##2 {
        \tl_clear:N ##1
        \regex_split:NnN \l_CDR_scpnsd_regex { ##2 } \l_CDR_scpnsd_seq
        \seq_if_empty:NTF \l_CDR_scpnsd_seq {
          \CDR_make_escape_inside_:NNn ##1 #2 { ##2 }
        } {
          \seq_pop_left:NN \l_CDR_scpnsd_seq \l_CDR_scpnsd_tl
          \exp_args:NNNV
          \CDR_make_escape_inside_:NNn ##1 #2 \l_CDR_scpnsd_tl
          \bool_while_do:nn { ! \seq_if_empty_p:N \l_CDR_scpnsd_seq } {
            \seq_pop_left:NN \l_CDR_scpnsd_seq \l_CDR_scpnsd_tl
            \exp_args:NNNV
            \CDR_make_escape_inside_:NNn ##1 #3 \l_CDR_scpnsd_tl
            \seq_pop_left:NN \l_CDR_scpnsd_seq \l_CDR_scpnsd_tl
            \exp_args:NNNV
            \CDR_make_escape_inside_:NNn ##1 #4 \l_CDR_scpnsd_tl
            \seq_pop_left:NN \l_CDR_scpnsd_seq \l_CDR_scpnsd_tl
            \exp_args:NNNV
            \CDR_make_escape_inside_:NNn ##1 #2 \l_CDR_scpnsd_tl
          }
        }  
      }
    }
  } {
    \cs_set:Npn \CDR_escape_inside:Nn ##1 ##2 {
      \CDR_make_escape_inside_:NNn ##1 #2 { ##2 }
    }
  }
}
%    \end{MacroCode}
%
% \section{Tag properties}
% The tag properties concern the code chunks.
% They are set from different paths, such that
% |\l_keys_path_str| must
% be properly parsed for that purpose.
% Commands in this section and the next ones contain |CDRTag|.
%
% The \metatt{tag names} starting with a double underscore are reserved by the package.
%
% \subsection{Helpers}
%
% \begin{function}[EXP]{\CDRTag_get_path:cc, \CDRTag_get_path:c}
% \begin{syntax}
% \cs{CDRTag_get_path:cc} \Arg{tag name} \Arg{relative key path}
% \cs{CDRTag_get_path:c} \Arg{relative key path}
% \end{syntax}
% Internal: return a unique key based on the arguments.
% Used to store and retrieve values.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRTag_get_path:cc #1 #2 {
  \c_CDRTag_get @ #1 / #2
}
\cs_new:Npn \CDRTag_get_path:c {
  \CDRTag_get_path:cc { __local }
}
%    \end{MacroCode}
%
% \subsection{Set}
% \begin{function}{\CDRTag_set:ccn,\CDRTag_set:ccV}
% \begin{syntax}
% \cs{CDRTag_set:ccn} \Arg{tag name} \Arg{relative key path} \Arg{value}
% \end{syntax}
% Store \metatt{value}, which is further retrieved with the instruction
% |\CDRTag_get:cc {|\metatt{tag name}|}| \linebreak[3]|{|\metatt{relative key path}|}|.
% Only \metatt{tag name} and \metatt{relative key path}
% containing no |@| character are supported.
% All the affectations are made at the current \TeX{} group level.
% \emph{Nota Bene:} |\cs_generate_variant:Nn| is buggy when there is a `c' argument.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDRTag_set:ccn #1 #2 #3 {
  \cs_set:cpn { \CDRTag_get_path:cc { #1 } { #2 } } { \exp_not:n { #3 } }
}
\cs_new_protected:Npn \CDRTag_set:ccV #1 #2 #3 {
  \exp_args:NnnV
  \CDRTag_set:ccn { #1 } { #2 } #3
}
%    \end{MacroCode}
%
% \begin{function}{\CDRTag_set_n:ccn, \CDRTag_set_nn:ccn, \CDRTag_set_nnn:ccn}
% \begin{syntax}
% \cs{CDRTag_set_n:ccn} \Arg{tag name} \Arg{relative key path} \Arg{value}
% \end{syntax}
% Store \metatt{value}, which is further retrieved with the instruction
% |\CDRTag_get:cc {|\metatt{tag name}|}| \linebreak[3]|{|\metatt{relative key path}|}|.
% The value is the body of a function with one arguments
% in the |_n| variant,
% two in the |_nn| variant and with three arguments in the |_nnn|
% variant.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDRTag_set_n:ccn #1 #2 #3 {
  \cs_set:cpn {
    \CDRTag_get_path:cc { #1 } { #2 }
  } ##1 { #3 }
}
\cs_new_protected:Npn \CDRTag_set_nn:ccn #1 #2 #3 {
  \cs_set:cpn {
    \CDRTag_get_path:cc { #1 } { #2 }
  } ##1 ##2 { #3 }
}
\cs_new_protected:Npn \CDRTag_set_nnn:ccn #1 #2 #3 {
  \cs_set:cpn {
    \CDRTag_get_path:cc { #1 } { #2 }
  } ##1 ##2 ##3 { #3 }
}
%    \end{MacroCode}
%
% \begin{variable}{\c_CDRTag_regex}
% To parse a \pkg{l3keys} full key path.
%    \begin{MacroCode}[OK]
\tl_set:Nn \l_CDR_a_tl { /([^/]*)/(.*)$ } \use_none:n { $ }
\tl_put_left:NV \l_CDR_a_tl \c_CDRTags
\tl_put_left:Nn \l_CDR_a_tl { ^ }
\exp_args:NNV
\regex_const:Nn \c_CDRTag_regex \l_CDR_a_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDRTag_set:n, \CDRTag_set_n:n, \CDRTag_set_nn:n, \CDRTag_set_nnn:n}
% \begin{syntax}
% \cs{CDRTag_set:n} \Arg{value}
% \end{syntax}
% The value is provided but not the \meta{dir} nor the \meta{relative key path},
% both are guessed from |\l_keys_path_str|.
% More precisely, |\l_keys_path_str| is expected to read something like
% \cs{c_CDRTags}|/|\metatt{tag name}|/|\metatt{relative key path},
% an error is raised on the contrary.
% This is meant to be called from |\keys_define:nn| argument.
% Implementation detail: the last argument is parsed by the last command.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDRTag_set:n {
  \exp_args:NnV
  \regex_extract_once:NnNTF \c_CDRTag_regex
      \l_keys_path_str \l_CDR_seq {
    \CDRTag_set:ccn
      { \seq_item:Nn \l_CDR_seq 2 }
      { \seq_item:Nn \l_CDR_seq 3 }
  } {
    \PackageWarning
      { coder }
      { Unexpected~key~path~`\l_keys_path_str' }
    \use_none:n
  }
}
\cs_new_protected:Npn \CDRTag_set_n:n {
  \exp_args:NnV
  \regex_extract_once:NnNTF \c_CDRTag_regex
      \l_keys_path_str \l_CDR_seq {
    \CDRTag_set_n:ccn
      { \seq_item:Nn \l_CDR_seq 2 }
      { \seq_item:Nn \l_CDR_seq 3 }
  } {
    \PackageWarning
      { coder }
      { Unexpected~key~path~`\l_keys_path_str' }
    \use_none:n
  }
}
\cs_new_protected:Npn \CDRTag_set_nn:n {
  \exp_args:NnV
  \regex_extract_once:NnNTF \c_CDRTag_regex
      \l_keys_path_str \l_CDR_seq {
    \CDRTag_set_nn:ccn
      { \seq_item:Nn \l_CDR_seq 2 }
      { \seq_item:Nn \l_CDR_seq 3 }
  } {
    \PackageWarning
      { coder }
      { Unexpected~key~path~`\l_keys_path_str' }
    \use_none:n
  }
}
\cs_new_protected:Npn \CDRTag_set_nnn:n {
  \exp_args:NnV
  \regex_extract_once:NnNTF \c_CDRTag_regex
      \l_keys_path_str \l_CDR_seq {
    \CDRTag_set_nnn:ccn
      { \seq_item:Nn \l_CDR_seq 2 }
      { \seq_item:Nn \l_CDR_seq 3 }
  } {
    \PackageWarning
      { coder }
      { Unexpected~key~path~`\l_keys_path_str' }
    \use_none:n
  }
}
%    \end{MacroCode}
% \begin{function}{\CDRTag_set:, \CDRTag_set_n:, \CDRTag_set_nn:, \CDRTag_set_nnn:}
% \begin{syntax}
% \cs{CDRTag_set:}
% \end{syntax}
% None of \meta{dir}, \meta{relative key path} and \metatt{value} are provided.
% The latter is guessed from |\l_keys_value_tl|, and |CDRTag_set:n| is called.
% This is meant to be call from |\keys_define:nn| argument.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDRTag_set: {
  \exp_args:NV
  \CDRTag_set:n \l_keys_value_tl
}
\cs_new_protected:Npn \CDRTag_set_n: {
  \exp_args:NV
  \CDRTag_set_n:n \l_keys_value_tl
}
\cs_new_protected:Npn \CDRTag_set_nn: {
  \exp_args:NV
  \CDRTag_set_nn:n \l_keys_value_tl
}
\cs_new_protected:Npn \CDRTag_set_nnn: {
  \exp_args:NV
  \CDRTag_set_nnn:n \l_keys_value_tl
}
%    \end{MacroCode}
% \begin{function}{\CDRTag_set:cn}
% \begin{syntax}
% \cs{CDRTag_set:cn} \Arg{key path} \Arg{value}
% \end{syntax}
% When the last component of |\l_keys_path_str| should not be used
% to store the \metatt{value}, but \metatt{key path} should be used instead.
% This last component is replaced and |\CDRTag_set:n| is called afterwards.
% Implementation detail: the second argument is parsed by the last command
% of the expansion.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRTag_set:cn #1 {
  \exp_args:NnV
  \regex_extract_once:NnNTF \c_CDRTag_regex
      \l_keys_path_str \l_CDR_seq {
    \CDRTag_set:ccn
      { \seq_item:Nn \l_CDR_seq 2 }
      { #1 }
  } {
    \PackageWarning
      { coder }
      { Unexpected~key~path~`\l_keys_path_str' }
    \use_none:n
  }
}
%    \end{MacroCode}
% \begin{function}{\CDRTag_choices:}
% \begin{syntax}
% \cs{CDRTag_choices:}
% \end{syntax}
% Ensure that the |\l_keys_path_str| is set properly.
% This is where a syntax like |\keys_set:nn {...} { choice/a }|
% is managed.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_generate_conditional_variant:Nnn \str_if_eq:nn { Vn } { p, T, F, TF }
\prg_generate_conditional_variant:Nnn \tl_if_empty:n { x } { p, T, F, TF }

\regex_const:Nn \c_CDR_root_regex { ^(.*)/.*$ } \use_none:n { $ }
\cs_new:Npn \CDRTag_choices: {
  \str_if_eq:nnT \l_keys_key_tl \l_keys_choice_tl {
    \exp_args:NnV
    \regex_extract_once:NnNT \c_CDR_root_regex
        \l_keys_path_str \l_CDR_seq {
      \str_set:Nx \l_keys_path_str {
        \seq_item:Nn \l_CDR_seq 2
      }
    }
  }
}
%    \end{MacroCode}
% \begin{function}{\CDRTag_choices_set:}
% \begin{syntax}
% \cs{CDRTag_choices_set:}
% \end{syntax}
% Calls |\CDRTag_set:n| with the content of |\l_keys_choice_tl| as value.
% Before, ensure that the |\l_keys_path_str| is set properly.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDRTag_choices_set: {
  \CDRTag_choices:
  \exp_args:NV
  \CDRTag_set:n \l_keys_choice_tl
}
%    \end{MacroCode}
%
% \begin{function}[EXP,pTF]{ \CDRTag_if_truthy:cc, \CDRTag_if_truthy:c }
% \begin{syntax}
% \cs{CDRTag_if_truthy:ccTF} \Arg{tag name} \Arg{relative key path} \Arg{true code} \Arg{false code}
% \cs{CDRTag_if_truthy:cTF} \Arg{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when the property for \metatt{tag name}
% and \metatt{relative key path} is a truthy value,
% \metatt{false code} otherwise.
% A truthy value is a text which is not ``false'' in a case insensitive comparison.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRTag_if_truthy:cc { p, T,  F, TF } {
  \exp_args:Ne
  \str_compare:nNnTF {
    \exp_args:Ne \str_lowercase:n { \CDRTag_get:cc { #1 } { #2 } }
  } = { true } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDRTag_if_truthy:c { p, T,  F, TF } {
  \exp_args:Ne
  \str_compare:nNnTF {
    \exp_args:Ne \str_lowercase:n { \CDRTag_get:c { #1 } }
  } = { true } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP,pTF]{ \CDRTag_if_eq:ccn, \CDRTag_if_eq:cn }
% \begin{syntax}
% \cs{CDRTag_if_eq:ccnTF} \Arg{tag name} \Arg{relative key path} \Arg{value} \Arg{true code} \Arg{false code}
% \cs{CDRTag_if_eq:cnTF} \Arg{relative key path} \Arg{value} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when the property for \metatt{tag name}
% and \metatt{relative key path} is equal to \metatt{value},
% \metatt{false code} otherwise.
% The comparison to \metatt{value} is based on |\str_compare:...|.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRTag_if_eq:ccn { p, T,  F, TF } {
  \exp_args:Nf
  \str_compare:nNnTF { \CDRTag_get:cc { #1 } { #2 } } = { #3 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDRTag_if_eq:cn { p, T,  F, TF } {
  \exp_args:Nf
  \str_compare:nNnTF { \CDRTag_get:cc { __local } { #1 } } = { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP,pTF]{ \CDR_if_truthy:n }
% \begin{syntax}
% \cs{CDR_if_truthy:nTF} \Arg{token list} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when \metatt{token list} is a truthy value,
% \metatt{false code} otherwise.
% A truthy value is a text which leading character, if any,
% is none of ``fFnN''.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_truthy:n { p, T,  F, TF } {
  \exp_args:Ne
  \str_compare:nNnTF { \exp_args:Ne \str_lowercase:n { #1 } } = { true } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRTag_boolean_set:n}
% \begin{syntax}
% \cs{CDRTag_boolean_set:n} \Arg{choice}
% \end{syntax}
% Calls |\CDRTag_set:n| with |true| if the argument is truthy,
% |false| otherwise.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDRTag_boolean_set:n #1 {
  \CDR_if_truthy:nTF { #1 } {
    \CDRTag_set:n { true }
  } {
    \CDRTag_set:n { false }
  }
}
\cs_generate_variant:Nn \CDRTag_boolean_set:n { x }
%    \end{MacroCode}
%
% \subsection{Retrieving tag properties}
% Internally, all tag properties are collected with a full key path like
% |\c_CDRTag_get/|\metatt{tag name}|/|\metatt{relative key path}.
% When typesetting some code with either the \cs{CDRCode} command or the
% |CDRBlock| environment, all properties defined locally are collected under
% the reserved |\c_CDRTag_get/__local/|\metatt{relative path} full key paths.
% The \pkg{l3keys} module |\c_CDRTag_get/__local| is modified in \TeX{} groups only.
% For running text code chunks, this module inherits from
% \begin{enumerate}
% \item |\c_CDRTag_get/|\metatt{tag name} for the provided \metatt{tag name},
% \item |\c_CDRTag_get/default.code|
% \item |\c_CDRTag_get/default|
% \item |\c_CDRTag_get/__pygments|
% \item |\c_CDRTag_get/__fancyvrb.all| when no using \pkg{pygments}
% \end{enumerate}
% For text block code chunks, this module inherits from
% \begin{enumerate}
% \item |\c_CDRTag_get/|\metatt{name_1}, ..., |\c_CDRTag_get/|\metatt{name_n}
% for each tag name of the ordered tags list
% \item |\c_CDRTag_get/default.block|
% \item |\c_CDRTag_get/default|
% \item |\c_CDRTag_get/__pygments|
% \item |\c_CDRTag_get/__fancyvrb.block|
% \item |\c_CDRTag_get/__fancyvrb.all| when no using \pkg{pygments}
% \end{enumerate}
%
% \begin{function}[pTF,EXP]{\CDRTag_if_exist_here:cc}
% \begin{syntax}
% \cs{CDRTag_if_exist_here:ccTF} \Arg{tag name} \meta{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% If the \metatt{relative key path} is known within \metatt{tag name},
% the \metatt{true code} is executed,
% otherwise, the \metatt{false code} is executed.
% No inheritance.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRTag_if_exist_here:cc { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRTag_get_path:cc { #1 } { #2 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \begin{function}[pTF,EXP]{\CDRTag_if_exist:cc, \CDRTag_if_exist:c}
% \begin{syntax}
% \cs{CDRTag_if_exist:ccTF} \Arg{tag name} \meta{relative key path} \Arg{true code} \Arg{false code}
% \cs{CDRTag_if_exist:cTF} \meta{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% If the \metatt{relative key path} is known within \metatt{tag name},
% the \metatt{true code} is executed,
% otherwise, the \metatt{false code} is executed if none of the  parents has the \metatt{relative key path} on its own.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRTag_if_exist:cc { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRTag_get_path:cc { #1 } { #2 } } {
    \prg_return_true:
  } {
    \seq_if_exist:cTF { \CDRTag_parent_seq:c { #1 } } {
      \seq_map_tokens:cn
        { \CDRTag_parent_seq:c { #1 } }
        { \CDRTag_if_exist_f:cn { #2 } }
    } {
      \prg_return_false:
    }
  }
}
\prg_new_conditional:Nnn \CDRTag_if_exist:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRTag_get_path:c { #1 } } {
    \prg_return_true:
  } {
    \seq_if_exist:cTF { \CDRTag_parent_seq:c { __local } } {
      \seq_map_tokens:cn
        { \CDRTag_parent_seq:c { __local } }
        { \CDRTag_if_exist_f:cn { #1 } }
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \CDRTag_if_exist_f:cn #1 #2 {
  \quark_if_no_value:nTF { #2 } {
    \seq_map_break:n {
      \prg_return_false:
    }
  } {
    \CDRTag_if_exist:ccT { #2 } { #1 } {
      \seq_map_break:n {
        \prg_return_true:
      }
    }
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP]{\CDRTag_get:cc, \CDRTag_get:c}
% \begin{syntax}
% \cs{CDRTag_get:cc} \Arg{tag name} \Arg{relative key path}
% \cs{CDRTag_get:c} \Arg{relative key path}
% \end{syntax}
% The property value stored for \metatt{tag name}
% and \metatt{relative key path}.
% Takes care of inheritance.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRTag_get:cc #1 #2 {
  \CDRTag_if_exist_here:ccTF { #1 } { #2 } {
    \use:c { \CDRTag_get_path:cc { #1 } { #2 } }
  } {
    \seq_if_exist:cT { \CDRTag_parent_seq:c { #1 } } {
      \seq_map_tokens:cn
        { \CDRTag_parent_seq:c { #1 } }
        { \CDRT@g_get:cn { #2 } }
    }
  }
}
\cs_new:Npn \CDRT@g_get:cn #1 #2 {
  \quark_if_no_value:nF { #2 } {
    \CDRTag_if_exist_here:ccT { #2 } { #1 } {
      \seq_map_break:n {
        \use:c { \CDRTag_get_path:cc { #2 } { #1 } }  
      }
    }
  }
}
\cs_new:Npn \CDRTag_get:c {
  \CDRTag_get:cc { __local }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRTag_get:ccN, \CDRTag_get:cN}
% \begin{syntax}
% \cs{CDRTag_get:ccN} \Arg{tag name} \Arg{relative key path} \Arg{tl variable}
% \cs{CDRTag_get:cN} \Arg{relative key path} \Arg{tl variable}
% \end{syntax}
% Put in \metatt{tl variable} the property value stored
% for the |__local| \metatt{tag name} and \metatt{relative key path}.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDRTag_get:ccN #1 #2 #3 {
  \tl_set:Nf #3 { \CDRTag_get:cc { #1 } { #2 } }
}
\cs_new_protected:Npn \CDRTag_get:cN {
  \CDRTag_get:ccN { __local }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[EXP]{\CDRTag_get_all:c}
% \begin{syntax}
% \cs{CDRTag_get_all:c} \Arg{relative key path}
% \end{syntax}
% Successfully calls |\CDRTag_get:cc| for
% \metatt{relative key path} and each parent of the
% |__local| tag.
% This assumes that inheritance is properly setup.
% Implemetation detail: use of |\l_CDR_seq|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRTag_get_all:c #1 {
  \seq_if_exist:cT { \CDRTag_parent_seq:c { #1 } } {
    \seq_set_eq:Nc \l_CDR_seq { \CDRTag_parent_seq:c { #1 } }
    \seq_reverse:N \l_CDR_seq
    \seq_map_inline:Nn \l_CDR_seq {
      \use:c { \CDRTag_get_path:cc { ##1 } { #1 } }
    }
  }
  \use:c { \CDRTag_get_path:cc { __local } { #1 } }
  \CDRTag_get:c { #1 * }
}
%    \end{MacroCode}
%
% \begin{function}[TF]{\CDRTag_get:ccN, \CDRTag_get:cN}
% \begin{syntax}
% \cs{CDRTag_get:ccNTF} \Arg{tag name} \Arg{relative key path} \meta{tl var} \Arg{true code} \Arg{false code}
% \cs{CDRTag_get:cNTF} \Arg{relative key path} \meta{tl var} \Arg{true code} \Arg{false code}
% \end{syntax}
% Getter with branching.
% If the \metatt{relative key path} is knwon,
% save the value into \metatt{tl var} and
% execute \meta{true code}.
% Otherwise, execute \metatt{false code}.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_protected_conditional:Nnn \CDRTag_get:ccN { T, F, TF } {
  \CDRTag_if_exist:ccTF { #1 } { #2 } {
    \CDRTag_get:ccN { #1 } { #2 } #3
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_protected_conditional:Nnn \CDRTag_get:cN { T, F, TF } {
  \CDRTag_if_exist:cTF { #1 } {
    \CDRTag_get:cN { #1 } #2
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \subsection{Inheritance}
% When a child inherits from a parent, all the keys of the parent
% that are not inherited are made available to the child
% (inheritance does not jump over generations).
% \begin{function}[EXP]{\CDRTag_parent_seq:c}
% \begin{syntax}
% \cs{CDRTag_parent_seq:c} \Arg{tag name}
% \end{syntax}
% Return the name of the sequence variable containing the list of the parents. Each child has its own sequence of parents assigned locally.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRTag_parent_seq:c #1 {
  l_CDR:parent.tag @ #1 _seq
}
%    \end{MacroCode}
% \begin{function}{\CDRTag_get_inherit:cn, \CDRTag_get_inherit:cf,\CDRTag_get_inherit:n, \CDRTag_get_inherit:f}
% \begin{syntax}
% \cs{CDRTag_get_inherit:cn} \Arg{child name} \Arg{parent names comma list}
% \end{syntax}
% Setup the behavior of the |\CDRTag_get:...| commands.
% Set the parents of \metatt{child name} to the
% given list.
% When the \metatt{child name} is not provided, it defaults to |__local|.
% Implementation detail: uses |\l_CDR_a_tl|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRTag_get_inherit:cn #1 #2 {
  \tl_set:Nx \l_CDR_a_tl { \CDRTag_parent_seq:c { #1 } }
  \seq_set_from_clist:cn { \l_CDR_a_tl } { #2 }
  \seq_remove_duplicates:c { \l_CDR_a_tl }
  \seq_remove_all:cn { \l_CDR_a_tl } {}
  \seq_put_right:cn { \l_CDR_a_tl } { \q_no_value }
}
\cs_new:Npn \CDRTag_get_inherit:cf {
  \exp_args:Nnf \CDRTag_get_inherit:cn
}
\cs_new:Npn \CDRTag_parents:c #1 {
  \seq_map_inline:cn { \CDRTag_parent_seq:c { #1 } } {
    \quark_if_no_value:nF { ##1 } {
      ##1,
    }
  }
}
\cs_new:Npn \CDRTag_get_inherit:n {
  \CDRTag_get_inherit:cn { __local }
}
\cs_new:Npn \CDRTag_get_inherit:f {
  \CDRTag_get_inherit:cf { __local }
}
%    \end{MacroCode}
% \section{Cache management}
% If there is no \metatt{jobname}|.aux| file, there should be no cached files either,
% \CDRLua{} is asked to clean all of them, if any.
%    \begin{MacroCode}[OK]
\AddToHook { begindocument/before } {
  \IfFileExists {./\jobname.aux} {} {
    \directlua { CDR:cache_clean_all() }
  }
}
%    \end{MacroCode}
% At the end of the document, \CDRLua{} is asked to clean all
% unused cached files that could come from a previous process.
%    \begin{MacroCode}[OK]
\AddToHook { enddocument/end } {
  \directlua { CDR:cache_clean_unused() }
}
%    \end{MacroCode}
%
% \section{Utilities}
% \begin{function}{\CDR_clist_map_inline:Nnn}
% \begin{syntax}
% \cs{CDR_clist_map_inline:Nnn} \meta{clist var} \Arg{empty code} \Arg{non empty code}
% \end{syntax}
% Execute \metatt{empty code} when the list is empty, otherwise
% call |\clist_map_inline:Nn| with \metatt{non empty code}.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_clist_map_inline:Nnn #1 #2 {
  \clist_if_empty:NTF #1 {
    #2
    \use_none:n
  } {
    \clist_map_inline:Nn #1
  }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[EXP,pTF]{\CDR_if_block:}
% \begin{syntax}
% \cs{CDR_if_block:TF} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when inside a code block,
% \metatt{false code} when inside an inline code.
% Raises an error otherwise.
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_block: { p, T, F, TF } {
  \PackageError
    { coder }
    { Conditional~not~available }
    { Internal~error:~report~bug }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDR_process_record:}
% Record the current line or not.
% The default implementation does nothing and is meant to
% be defines locally.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_process_record: {}
%    \end{MacroCode}
% \end{function}
%
% \section{\pkg{l3keys} modules for code chunks}
%
% All these modules are initialized at the beginning
% of the document body using the |__initialize| meta key.
%
% \subsection{Utilities}
%
% \begin{function}[EXP]{\CDRTag_module:n}
% \begin{syntax}
% \cs{CDRTag_module:n} \Arg{module base}
% \end{syntax}
% The \metatt{module} is uniquely based on \metatt{module base}.
% This should be |f| expanded when used as |n| argument of \pkg{l3keys} functions.
%    \begin{MacroCode}[OK]
\cs_set:Npn \CDRTag_module:n #1 {
  \str_if_eq:nnTF { #1 } { .. } {
    \c_CDR_Tag
  } {
    \tl_if_empty:nTF { #1 } { \c_CDRTags } { \c_CDRTags / #1 }
  }
}
%    \end{MacroCode}
% \end{function}
% \begin{function}{\CDRTag_keys_define:nn}
% \begin{syntax}
% \cs{CDRTag_keys_define:nn} \Arg{module base} \Arg{keyval list}
% \end{syntax}
% The \metatt{module} is uniquely based on \metatt{module base} before
% forwarding to |\keys_define:nn|.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRTag_keys_define:nn #1 {
  \exp_args:Nf
  \keys_define:nn { \CDRTag_module:n { #1 } }
}
%    \end{MacroCode}
% \end{function}
% \begin{function}[EXP,TF]{\CDRTag_keys_if_exist:nn}
% \begin{syntax}
% \cs{CDRTag_keys_if_exist:nnTF} \Arg{module base} \Arg{key} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} if there is a \metatt{key} for the given \metatt{module base},
% \metatt{false code} otherwise.
% If \metatt{module base} is empty, \metatt{key} is the module base used.
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRTag_keys_if_exist:nn { p, T, F, TF } {
  \exp_args:Nf
  \keys_if_exist:nnTF { \CDRTag_module:n { #1 } } { #2 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDRTag_keys_set:nn}
% \begin{syntax}
% \cs{CDRTag_keys_set:nn} \Arg{module base} \Arg{keyval list}
% \end{syntax}
% The \metatt{module} is uniquely based on \metatt{module base} before
% forwarding to |\keys_set:nn|.
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDRTag_keys_set:nn #1 {
  \exp_args:Nf
  \keys_set:nn { \CDRTag_module:n { #1 } }
}
\cs_generate_variant:Nn \CDRTag_keys_set:nn { nV }
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\CDRTag_keys_set:nn}
% \begin{syntax}
% \cs{CDRTag_keys_set:nn} \Arg{module base} \Arg{keyval list}
% \end{syntax}
% The \metatt{module} is uniquely based on \metatt{module base} before
% forwarding to |\keys_set:nn|.
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_local_set:n {
  \CDRTag_keys_set:nn { __local }
}
\cs_generate_variant:Nn \CDR_local_set:n { V }
%    \end{MacroCode}
% \end{function}
%
% \subsubsection{Handling unknown tags}
% While using |\keys_set:nn| and variants, each time a full key path matching the pattern
% |\c_CDRTag/|\metatt{tag name}|/|\metatt{relative key path}
% is not recognized, we assume that the client implicitly wants a tag
% with the given \metatt{tag name} to be defined. For that purpose, we collect
% unknown keys with |\keys_set_known:nnnN| then process them to find
% each \metatt{tag name} and define
% the new tag accordingly.
% A similar situation occurs for display engine options where the
% full key path reads
% |\c_CDRTag/|\metatt{tag name}|/|\metatt{engine name}| engine options|
% where \metatt{engine name} is not known in advance.
%
% \begin{function}{\CDRTag_keys_inherit:nn}
% \begin{syntax}
% \cs{CDRTag_keys_inherit:nn} \Arg{tag name} \Arg{parents comma list}
% \end{syntax}
% Set the inheritance: \metatt{tag name} inherits from each parent, which is a tag name.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDRTag_keys_inherit__:nnn #1 #2 #3 {
  \keys_define:nn { #1 } { #2 .inherit:n = { #1 / #3 } }
}
\cs_new_protected_nopar:Npn \CDRTag_keys_inherit_:nnn #1 #2 #3 {
  \exp_args:Nnx
  \use:n { \CDRTag_keys_inherit__:nnn { #1 } { #2 } } {
    \clist_use:nn { #3 } { ,#1/ }
  }
}
\cs_new_protected_nopar:Npn \CDRTag_keys_inherit:nn {
  \exp_args:Nf
  \CDRTag_keys_inherit_:nnn { \CDRTag_module:n { } }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_local_inherit:n}
% \begin{syntax}
% Wrapper over |\CDRTag_keys_inherit:nn| where \metatt{tag name} is
% given by \cs{CDRTag_module:n}|{__local}|.
% \end{syntax}
% Set the inheritance: \metatt{tag name} inherits from each parent, which is a tag name.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDR_local_inherit:n {
  \CDRTag_keys_inherit:nn { __local }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRTag_keys_set_known:nnN, \CDRTag_keys_set_known:nVN, \CDRTag_keys_set_known:nN, \CDRTag_keys_set_known:N}
% \begin{syntax}
% \cs{CDRTag_keys_set_known:nnN} \Arg{tag name} \Arg{key[=value] items} \meta{clist var}
% \cs{CDRTag_keys_set_known:nN} \Arg{tag name} \meta{clist var}
% \end{syntax}
% These are wrappers over the |\keys_set_known:nnnN| function
% where the module argument is given by |\CDRTag_module:n{|\metatt{tag name}|}|.
% \emph{Implementation detail} the remaining arguments are absorbed by the last macro.
% When \metatt{key[=value] items} is omitted, it is the content of \metatt{clist var}.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDRTag_keys_set_known__:nnN #1 #2 {
  \keys_set_known:nnnN { #1 } { #2 } { #1 }
}
\cs_new_protected_nopar:Npn \CDRTag_keys_set_known:nnN #1 {
  \exp_args:Nf
  \CDRTag_keys_set_known__:nnN { \CDRTag_module:n { #1 } }
}
\cs_generate_variant:Nn \CDRTag_keys_set_known:nnN { nV }
\cs_new_protected_nopar:Npn \CDRTag_keys_set_known:nN #1 #2 {
  \CDRTag_keys_set_known:nVN { #1 } #2 #2
}
%    \end{MacroCode}
%
% \begin{function}{\CDRTag_keys_set_known:nnN, \CDRTag_keys_set_known:nVN, \CDRTag_keys_set_known:nN, \CDRTag_keys_set_known:N}
% \begin{syntax}
% \cs{CDR_local_set_known:nN} \Arg{key[=value] items} \meta{clist var}
% \cs{CDR_local_set_known:N} \meta{clist var}
% \end{syntax}
% These are wrappers over the |\CDRTag_keys_set_known:...|
% functions where the module is given by |\CDRTag_module:n{|__local|}|.
% When \metatt{key[=value] items} is omitted, it is the content of \metatt{clist var}.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDR_local_set_known:nN {
  \CDRTag_keys_set_known:nnN { __local }
}
\cs_generate_variant:Nn \CDR_local_set_known:nN { V }
\cs_new_protected_nopar:Npn \CDR_local_set_known:N #1 {
  \CDR_local_set_known:VN #1 #1
}
%    \end{MacroCode}
%
% \begin{variable}{\c_CDR_provide_regex}
% To parse a \pkg{l3keys} full key path.
%    \begin{MacroCode}[OK]
\tl_set:Nn \l_CDR_a_tl { /([^/]*)(?:/(.*))?$ } \use_none:n { $ }
\exp_args:NNf
\tl_put_left:Nn \l_CDR_a_tl { \CDRTag_module:n {} }
\tl_put_left:Nn \l_CDR_a_tl { ^ }
\exp_args:NNV
\regex_const:Nn \c_CDR_provide_regex \l_CDR_a_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDRTag_expand_kv:n}
% \begin{syntax}
% \cs{CDRTag_expand_kv:N} \Arg{key-value list variable}
% \end{syntax}
% Expands the keys matching |tags/|\meta{tag names list}.
% The list a comma separated list, except that the pipe character replaces the comma.
% Implementation detail: uses |\l_CDR_clist|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDRTag_expand_kv:N #1 {
\CDR@Debug{\string\CDRTag_expand_kv:N}
  \clist_clear:N \l_CDR_clist
  \cs_set:Npn \@CDR:n {
    \clist_put_right:Nn \l_CDR_clist
  }
  \cs_set:Npn \@CDR:nn ##1 ##2 { \use_none:n { $ }
    \regex_extract_once:nnNTF { ^ tags/([^/]+)(/([^/]+))? $} { ##1 } \l_CDR_seq {
      \tl_set:Nx \l_CDR_a_tl { \seq_item:Nn \l_CDR_seq 4 }
      \cs_set:Npn \@@CDR:nn ####1 ####2 {
        \clist_put_right:Nn \l_CDR_clist {
          tags / ####1 / ####2 = { ##2 }
        }
      }
      \seq_map_inline:Nn \l_CDR_seq {
        \CDR@Debug{====CAPTURE ####1}
      }
      \exp_args:Nnx
      \regex_split:nnNTF { [|] } { \seq_item:Nn \l_CDR_seq 2 } \l_CDR_seq {
        \tl_if_empty:NTF \l_CDR_a_tl {
          \seq_map_inline:Nn \l_CDR_seq {
            \clist_put_right:Nn \l_CDR_clist { tags/####1 = { ##2 } }
          }
        } {
          \seq_map_inline:Nn \l_CDR_seq {
            \exp_args:NnV \@@CDR:nn { ####1 } \l_CDR_a_tl
          }
        }
      } {
        \clist_put_right:Nn \l_CDR_clist { ##1 = { ##2 } } 
      }
    } {
      \clist_put_right:Nn \l_CDR_clist { ##1 = { ##2 } } 
    }
  }
  \exp_args:NnnV
  \keyval_parse:nnn {
    \@CDR:n
  } {
    \@CDR:nn
  } #1
  \clist_map_inline:Nn \l_CDR_clist {
    \exp_args:Nx \CDR@Debug {KV:\tl_to_str:n{##1}}
  }
  \clist_set_eq:NN #1 \l_CDR_clist
\CDR@Debug{\string\CDRTag_expand_kv:N...DONE}
}
%    \end{MacroCode}
%
% \begin{function}{\CDRTag_provide_from_kv:n}
% \begin{syntax}
% \cs{CDRTag_provide:n} \Arg{deep comma list}
% \cs{CDRTag_provide_from_kv:n} \Arg{key-value list}
% \end{syntax}
% \metatt{deep comma list} has format
% |tag/|\metatt{tag name comma list}.
% Parse the \metatt{key-value list} for full key path matching
% |tag/|\metatt{tag name}|/|\metatt{relative key path},
% then ensure that \cs{c_CDRTag}|/|\metatt{tag name} is a known full key path.
% For that purpose, we use |\keyval_parse:nnn| with two |\CDRTag_provide:| helper.
%
% Notice that a tag name should contain no `/'.
% Implementation detail: uses |\l_CDR_a_tl|.
% \end{function}
%    \begin{MacroCode}[OK]
\regex_const:Nn \c_CDR_engine_regex { ^[^/]+\sengine\soptions$ } \use_none:n { $ }
\cs_new_protected_nopar:Npn \CDRTag_provide:n #1 {
\CDR@Debug { \string\CDRTag_provide:n~#1 }
  \exp_args:NNf
  \regex_extract_once:NnNTF \c_CDR_provide_regex {
    \CDRTag_module:n { .. } / #1
  } \l_CDR_seq {
    \tl_set:Nx \l_CDR_a_tl { \seq_item:Nn \l_CDR_seq 3 }
    \exp_args:Nx
    \clist_map_inline:nn {
      \seq_item:Nn \l_CDR_seq 2
    } {
      \CDRTag_keys_if_exist:nnF { } { ##1 } {
        \CDRTag_keys_inherit:nn { ##1 } {
          __pygments,
          default.block, default.code, default, __tags, __engine,
          __fancyvrb.block,
          __numbering, __fancyvrb.all,
        }
        \CDRTag_keys_define:nn { } {
          ##1 .code:n = \CDRTag_keys_set:nn { ##1 } { ####1 },
          ##1 .value_required:n = true,
        }
\CDR@Debug{\string\CDRTag_provide:n~\CDRTag_module:n {##1} = ...}
      }
      \exp_args:NnV
      \CDRTag_keys_if_exist:nnF { ##1 } \l_CDR_a_tl {
        \exp_args:NNV
        \regex_match:NnT \c_CDR_engine_regex \l_CDR_a_tl {
          \exp_args:Nnf
          \CDRTag_keys_define:nn { ##1 } {
            \use:n { \l_CDR_a_tl } .code:n = \CDRTag_set:n { ####1 },
          }
          \exp_args:Nnf
          \CDRTag_keys_define:nn { ##1 } {
            \use:n { \l_CDR_a_tl } .value_required:n = true,
          }
\CDR@Debug{\string\CDRTag_provide:n:~\CDRTag_module:n { ##1 } / \l_CDR_a_tl = ...}
        }
      }
    }
  } {
    \regex_match:NnTF \c_CDR_engine_regex { #1 } {
      \CDRTag_keys_define:nn { default } {
        #1 .code:n = \CDRTag_set:n { ##1 },
        #1 .value_required:n = true,
      }
\CDR@Debug{\string\CDRTag_provide:n~C:\CDRTag_module:n { default } / #1 = ...}
    } {
\CDR@Debug{\string\CDRTag_provide:n\space did~nothing~new.}
    }
  }
}
\cs_new:Npn \CDRTag_provide:nn #1 #2 {
  \CDRTag_provide:n { #1 }
}
\cs_new:Npn \CDRTag_provide_from_kv:n {
  \keyval_parse:nnn {
    \CDRTag_provide:n
  } {
    \CDRTag_provide:nn
  }
}
\cs_generate_variant:Nn \CDRTag_provide_from_kv:n { V }
%    \end{MacroCode}
%
%
% \subsection{\pkg{pygments}}
% These are \pkg{pygments}'s |LatexFormatter| options.
% They are made available at the end user level,
% but may not be relevant when \pkg{pygments} is nor used.
%
% \subsubsection{\texorpdfstring{\texttt{__pygments }}{--pygments}
% \pkg{l3keys} module}
%
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { __pygments } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed lang=\meta{language name}]^^A
%where \metatt{language name} is recognized by \pkg{pygments}, including a void string,
%    \begin{MacroCode}[OK]
  lang .code:n = \CDRTag_set:,
  lang .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed pygments{[=true$\vert$false]}]^^A
% whether \pkg{pygments} should be used for syntax coloring.
% Initially |true| if \pkg{pygments} is available,
% |false| otherwise.
%    \begin{MacroCode}[OK]
  pygments .code:n = \CDRTag_boolean_set:x { #1 },
  pygments .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed style=\meta{style name}]^^A
%where \metatt{style name} is recognized by \pkg{pygments}, including a void string,
%    \begin{MacroCode}[OK]
  style .code:n = \CDRTag_set:,
  style .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed commandprefix=\meta{text}]^^A
% The \LaTeX{} commands used to produce colored output are constructed
%        using this prefix and some letters.
% Initially |Py|.
%    \begin{MacroCode}[OK]
  commandprefix .code:n = \CDRTag_set:,
  commandprefix .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed mathescape{[=true$\vert$false]}]^^A
% If set to |true|, enables \LaTeX{} math mode escape in comments. That
%        is, |$...$| inside a comment will trigger math mode.
% Initially |false|.
%    \begin{MacroCode}[OK]
  mathescape .code:n = \CDRTag_boolean_set:x { #1 },
  mathescape .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% Initializer.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    lang = tex,
    pygments = \CDR_has_pygments:TF { true } { false },
    style = default,
    commandprefix = PY,
    mathescape = false,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDRTag_keys_set:nn { __pygments } { __initialize }
}
%    \end{MacroCode}
%
% \subsection{Specifc to \pkg{coder}}
%
% \subsubsection{\texttt{default} \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { default } {
%    \end{MacroCode}
% Keys are:
% \begin{description}
% \itemtt[\CDRCheckRed font family=\meta{family name}]^^A
% font family to use. |tt|, |courier| and |helvetica| are pre-defined.
% Initially \texttt{tt}.
%    \begin{MacroCode}[OK]
  font~family .code:n = \CDRTag_set:,
  font~family .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed font size=\meta{font size}]^^A
% size of the font to use. If you use the \pkg{relsize} package as well,
% you can require a change of the size proportional to the current one
% (for instance: |font size=\relsize{-2}|).
% Initially \texttt{auto}: the same as the current font.
%    \begin{MacroCode}[OK]
  font~size .code:n = \CDRTag_set:,
  font~size .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed font shape=\meta{font shape}]^^A
% font shape to use. Initially \texttt{auto}: the same as the current font.
%    \begin{MacroCode}[OK]
  font~shape .code:n = \CDRTag_set:,
  font~shape .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed font series=\meta{series name}]^^A
% \LaTeX{} font ‘series’ to use.
% Initially \texttt{auto}: the same as the current font.
%    \begin{MacroCode}[OK]
  font~series .code:n = \CDRTag_set:,
  font~series .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed format=\meta{format commands}]^^A
% the format used to display the code (mainly font, size and color),
% after the font has been selected.
% Overrides the default behavior.
% Initially |\ttfamily|.
%    \begin{MacroCode}[OK]
  format .code:n = \CDRTag_set:,
  format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed format*=\meta{format commands}]^^A
% the format used to display the code (mainly font, size and color) after, added to the default behavior, after the normal format applies.
% Initially empty.
%    \begin{MacroCode}[OK]
  format* .code:n = \CDRTag_set:,
  format* .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed hook before=\meta{commands}]^^A
% These commands are executed just before the code is displayed.
% Initially empty.
%    \begin{MacroCode}[OK]
  hook~before .code:n = \CDRTag_set:,
  hook~before .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed hook before*=\meta{commands}]^^A
% These commands are executed just before the code is displayed, after the |hook before|.
% Initially empty.
%    \begin{MacroCode}[OK]
  hook~before* .code:n = \CDRTag_set:,
  hook~before* .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed hook after=\meta{commands}]^^A
% These commands are executed just before the code is displayed.
% Initially empty.
%    \begin{MacroCode}[OK]
  hook~after .code:n = \CDRTag_set:,
  hook~after .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed hook after*=\meta{commands}]^^A
% These commands are executed just before the code is displayed, before the |hook after|.
% Initially empty.
%    \begin{MacroCode}[OK]
  hook~after* .code:n = \CDRTag_set:,
  hook~after* .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed cache]^^A
% Set to |true| if \CDRPy{} should use already existing files
% instead of creating new ones.
% Initially true.
%    \begin{MacroCode}[OK]
  cache .code:n = \CDRTag_boolean_set:x { #1 },
  cache .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed debug]^^A
% Set to |true| if various debugging messages should be printed to the console .
% Initially false.
%    \begin{MacroCode}[OK]
  debug .code:n = \CDRTag_boolean_set:x { #1 },
  debug .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed post processor=\meta{command}]^^A
% the command for \pkg{pygments} post processor.
% This is a string where every occurrence of ``|%%file%%|'' is replaced by
% the full path of the |*.pyg.tex| file to be post processed
% and then executed as terminal instruction.
% Initially empty.
%    \begin{MacroCode}[OK]
  post~processor .code:n = \CDRTag_set:,
  post~processor .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen ref label=\meta{label}]^^A
% define a label to be used with |\pageref|.
% Initially empty.
%    \begin{MacroCode}[OK]
  ref~label .code:n = \CDRTag_set:, 
  ref~label .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed show spaces{[=true$\vert$false]}]^^A
% print a special character representing each space.
% Initially |false|: spaces not shown.
%    \begin{MacroCode}[OK]
  show~spaces .code:n = \CDRTag_boolean_set:x { #1 },
  show~spaces .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed obey tabs=true$\vert$false]^^A
% position characters according to the tabs.
% Initially false: tab characters are added to the current position.
%    \begin{MacroCode}[OK]
  obey~tabs .code:n = \CDRTag_boolean_set:x { #1 },
  obey~tabs .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed escape inside=\meta{before}\meta{after}]^^A
% If set to a string of length 2, enables escaping to \LaTeX{}. Text
%        delimited by these 2 characters is read as \LaTeX{} code and
%        typeset accordingly. It has no effect in string literals. It has
%        no effect in comments if |texcomments| or |mathescape| is
%        set.
% Initially empty.
%    \begin{MacroCode}[OK]
  escape~inside .code:n = \CDRTag_set:,
  escape~inside .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% to initialize storage properly. We cannot use |.initial:n| actions
% because the |\l_keys_path_str| is not set up properly.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    font~family = auto,
    font~size = auto,
    font~series = auto,
    font~shape = auto,
    format  = \ttfamily,
    format* = ,
    hook~before  = ,
    hook~before* = ,
    hook~after  = ,
    hook~after* = ,
    cache = true,
    debug = false,
    post~processor = ,
    show~spaces = false,
    obey~tabs = false,
    ref~label = ,
    escape~inside = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
%
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDRTag_keys_set:nn { default } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{default.code} \pkg{l3keys} module}
% Void for the moment.
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { default.code } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed mbox{[=true$\vert$false]}]^^A
% When set to |true|, put the argument inside a \LaTeX{} |mbox| to prevent the code chunk to spread over different lines.
% Initially |true|.
%    \begin{MacroCode}[OK]
  mbox .code:n = \CDRTag_boolean_set:x { #1 },
  mbox .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% to initialize storage properly. We cannot use |.initial:n| actions
% because the |\l_keys_path_str| is not set up properly.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    mbox = true,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
%
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDRTag_keys_set:nn { default.code } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__tags} \pkg{l3keys} module}
% The only purpose is to catch only the |tags| key very early.
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { __tags } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed tags=\meta{comma list of tag names}]^^A
% to enable/disable the display of the code chunks tags, setup some style, export.
% Initially |empty|.
% to export and display.
%    \begin{MacroCode}
  tags .code:n = {
    \str_set:Nx \l_CDR_str { #1 }
    \str_replace_all:Nnn \l_CDR_str {|} {,}
    \exp_args:NNV
    \clist_set:Nn \l_CDR_clist \l_CDR_str
    \clist_remove_duplicates:N \l_CDR_clist
    \exp_args:NV
    \CDRTag_set:n \l_CDR_clist
  },
  tags .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed default tags=\meta{comma list of tag names}]^^A
% when no tag is provided.
% Initially |empty|.
% When empty, the first tag list provided will override this.
%    \begin{MacroCode}
  default~tags .code:n = {
    \clist_set:Nx \l_CDR_clist { #1 }
    \clist_remove_duplicates:N \l_CDR_clist
    \exp_args:NV
    \CDRTag_set:n \l_CDR_clist
  },
  default~tags .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    tags = ,
    default~tags = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDRTag_keys_set:nn { __tags } { __initialize }
}
%    \end{MacroCode}
% There is a compagnion module to catch unexpected |tags| key.
% Used for \pkg{\jobname} options when defining engines.
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { __no_tags } {
  tags .code:n = {
    \PackageError
      { coder }
      { Key~`tags'~is~forbidden~for~engines }
      { See~the~coder~manual }
  }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__engine} \pkg{l3keys} module}
% The only purpose is to catch only the |engine| key very early,
% just after the |tags| key.
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { __engine } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed engine=\meta{engine name}]^^A
% to specify the engine used to display inline code or blocks.
% Initially |default|.
%    \begin{MacroCode}[OK]
  engine .code:n = \CDRTag_set:,
  engine .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed default engine options=\meta{default engine options}]^^A
% to specify the corresponding options,
%    \begin{MacroCode}[OK]
  default~engine~options .code:n = \CDRTag_set:,
  default~engine~options .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed engine options=\meta{engine options}]^^A
% options forwarded to the engine. They are appended to the options
% given with key \metatt{engine name}| engine options|.
% Mainly a convenient user interface shortcut.
%    \begin{MacroCode}[OK]
  engine~options .code:n = \CDRTag_set:,
  engine~options .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed \meta{engine name} engine options=\meta{engine options}]^^A
% to specify the options
% for the named engine,
% \itemtt[\CDRCheckRed \meta{engine name} options=\meta{\pkg{\jobname} options}]^^A
% to specify the \pkg{\jobname} options that should apply
% when the named engine is selected.
% \itemtt[\CDRCheckRed __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    engine = default,
    default~engine~options = ,
    engine~options = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDRTag_keys_set:nn { __engine } { __initialize }
}
%    \end{MacroCode}
%
% There is a compagnion module to catch unexpected |tags| key.
% Used for \pkg{\jobname} options when defining engines.
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { __no_engine } {
  engine .code:n = {
    \PackageError
      { coder }
      { Key~`engine'~is~forbidden~for~engines }
      { See~the~coder~manual }
  }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{default.block} \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { default.block } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed tab size=\meta{integer}]^^A
% number of spaces given by a tab character,
% Initially 2.
%    \begin{MacroCode}[OK]
  tab~size .code:n = \CDRTag_set:,
  tab~size .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed obey tabs=true$\vert$false]^^A
% position characters according to the tabs.
% Initially false: tab characters are added to the current position as spaces.
%    \begin{MacroCode}[OK]
  obey~tabs .code:n = \CDRTag_boolean_set:x { #1 },
  obey~tabs .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed show tabs=true$\vert$false]^^A
% explicitly show tab characters.
% Initially |false|: tab characters not shown.
%    \begin{MacroCode}[OK]
  show~tabs .code:n = \CDRTag_boolean_set:x { #1 },
  show~tabs .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed list indent=true$\vert$false]^^A
% When set to |true|, follow list indentation.
%    \begin{MacroCode}[OK]
  list~indent .code:n = \CDRTag_boolean_set:x { #1 }, 
  list~indent .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed left margin*=\meta{dimension}]^^A
% indentation to add at the start of each line.
% Initially |0pt|: no left margin.
%    \begin{MacroCode}[OK]
  left~margin* .code:n = \CDRTag_set:, 
  left~margin* .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed right margin*=\meta{dimension}]^^A
% right margin to add after each line.
% Initially |0pt|: no right margin.
%    \begin{MacroCode}[OK]
  right~margin* .code:n = \CDRTag_set:, 
  right~margin* .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed hfuzz=\meta{dimension}]^^A
% value to give to the \TeX{} |\hfuzz| dimension for text to format.
% This can be used to avoid seeing some unimportant overfull box messages.
% Initially 2pt.
%    \begin{MacroCode}[OK]
  hfuzz .code:n = \CDRTag_set:, 
  hfuzz .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed vspace=\metatt{dimension}]^^A
% the amount of vertical space added to |\parskip| before and after blocks.
% Initially |\topsep|.
%    \begin{MacroCode}[OK]
  vspace .code:n = \CDRTag_set:,
  vspace .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed same~page{[=true$\vert$false]}]^^A
% To avoid a page break inside a block of code, set the |same page| option to |true|.
% Initially |false|: allow page break.
%    \begin{MacroCode}[OK]
  same~page .code:n = \CDRTag_boolean_set:x { #1 },
  same~page .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed tags format=\meta{format commands}]^^A
%, where \meta{format} is used
% the format used to display the tag names (mainly font, size and color),
% after it is appended to the |numbers format|.
% Initially empty.
%    \begin{MacroCode}[OK]
  tags~format .code:n = \CDRTag_set:,
  tags~format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed numbers format=\meta{format commands}]^^A
% the format used to display line numbers (mainly font, size and color).
%    \begin{MacroCode}[OK]
  numbers~format .code:n = \CDRTag_set:,
  numbers~format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed show tags={[=true$\vert$false]}]^^A
% whether tags should be displayed.
%    \begin{MacroCode}[OK]
  show~tags .choices:nn =
    { none, left, right, same, mirror, dry }
    { \CDRTag_choices_set: },
  show~tags .default:n = same,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed only top{[=true$\vert$false]}]^^A
% to avoid chunk tags repetitions, if on the same page,
% two consecutive code chunks have the same tag names, the second names are not displayed.
%    \begin{MacroCode}[OK]
  only~top .code:n = \CDRTag_boolean_set:x { #1 },
  only~top .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed line color=\meta{color}]^^A
% when non empty, the background color of each line.
% They will receive 
% the physical line number as first argument
% and the logical one as second.
% Initially empty.
%    \begin{MacroCode}[OK]
  line~color .code:n = \CDRTag_set_nn:,
  line~color .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed text color=\meta{color}]^^A
% when non empty, the text color of each line.
% \pkg{pygments} coloring takes precedence.
% They will receive 
% the physical line number as first argument
% and the logical one as second.
% Initially empty.
%    \begin{MacroCode}[OK]
  text~color .code:n = \CDRTag_set_nn:,
  text~color .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed line prefix=\meta{instructions}]^^A
% the given \meta{instructions} are executed
% before the content. They will receive 
% the physical line number as first argument
% and the logical one as second.
% Initially empty.
%    \begin{MacroCode}[OK]
  line~prefix .code:n = \CDRTag_set_nn:,
  line~prefix .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed line postfix=\meta{instructions}]^^A
% the given \meta{instructions} are executed
% after the content. They will receive 
% the physical line number as first argument
% and the logical one as second.
% Initially empty.
%    \begin{MacroCode}[OK]
  line~postfix .code:n = \CDRTag_set_nn:,
  line~postfix .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed line suffix=\meta{instructions}]^^A
% the given \meta{instructions} are executed
% after the line. They will receive 
% the physical line number as first argument
% and the logical one as second.
% Initially empty.
%    \begin{MacroCode}[OK]
  line~suffix .code:n = \CDRTag_set_nn:,
  line~suffix .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed line content=\meta{instructions}]^^A
% the given \meta{instructions} are executed
% to typeset the line content. They will receive 
% the physical line number as first argument,
% the logical one as second and the content as third.
% Initially returns the third argument as is.
%    \begin{MacroCode}[OK]
  line~content .code:n = \CDRTag_set_nnn:,
  line~content .value_required:n = true,
%    \end{MacroCode}
%
% \itemtt[\CDRCheckRed line depth=\meta{ratio}$\vert$auto]^^A
% set the vertical space below the base line,
% relative to |\baselineskip|.
% The default is set to |auto| which means that this ratio is
% automatically computed from the current font.
% The \meta{ratio} is a floating point number,
% something between |0.25| and |0.3| seems reasonable.
% Initially |auto|.
%    \begin{MacroCode}[OK]
  line~depth .code:n = \CDRTag_set:,
  line~depth .value_required:n = true,
%    \end{MacroCode}
%
% \itemtt[\CDRCheckRed number main=\meta{instructions}]^^A
% the given \meta{instructions} are executed
% to typeset the main line numbers.
% They will receive 
% the logical line number as unique argument.
% Initially returns its argument as is.
%    \begin{MacroCode}[OK]
  number~main .code:n = \CDRTag_set_n:,
  number~main .value_required:n = true,
%    \end{MacroCode}
%
% \itemtt[\CDRCheckRed number other=\meta{instructions}]^^A
% the given \meta{instructions} are executed
% to typeset the line numbers which are not main.
% They will receive 
% the logical line number as unique argument.
% Initially gobbles its argument.
%    \begin{MacroCode}[OK]
  number~other .code:n = \CDRTag_set_n:,
  number~other .value_required:n = true,
%    \end{MacroCode}
%
%\itemtt[\CDRCheckRed use margin{[=true$\vert$false]}]^^A
% to use the margin to display line numbers
% and tag names, or not, UNUSED
%    \begin{MacroCode}[OK]
  use~margin .code:n = \CDRTag_boolean_set:x { #1 },
  use~margin .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed gobble=\meta{integer}]^^A
% number of characters to suppress
% at the beginning of each line (from 0 to 9),
% mainly useful when environments are indented.
% Only |block| mode.
%    \begin{MacroCode}[OK]
  gobble .choices:nn = {
    0,1,2,3,4,5,6,7,8,9
  } {
    \CDRTag_choices_set:
  },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    list~indent = false,
    left~margin*  = 0pt,
    right~margin* = 0pt,
    hfuzz = 2pt,
    vspace = \topsep,
    same~page = false,
    show~tabs = false,
    obey~tabs = false,
    tab~size = 2,
    show~tags = same,
    only~top = true,
    use~margin = true,
    numbers~format = {
      \sffamily
      \scriptsize
      \color{gray}
    },
    tags~format = {
      \bfseries
    },
    line~color =,
    text~color =,
    line~prefix = ,
    line~postfix = ,
    line~suffix  = ,
    line~content = ##3,
    line~depth = auto,
    number~main = ##1,
    number~other = ,    
    gobble = 0,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDRTag_keys_set:nn { default.block } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{default.block} \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { default.block.vrb } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed comment~format=\meta{integer}]^^A
% Commands for font and color.
%    \begin{MacroCode}[OK]
  comment~format .code:n = \CDRTag_set:,
  comment~format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed comment~command=\metatt{instructions}]^^A
% The result of the \metatt{instructions} applied
% to the comment .
%    \begin{MacroCode}[OK]
  comment~command .code:n = \CDRTag_set_n:,
  comment~command .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    comment~format =,
    comment~command = ##1,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDRTag_keys_set:nn { default.block.vrb } { __initialize }
}
%    \end{MacroCode}
%
% \subsection{\pkg{fancyvrb}}
% These are \pkg{fancyvrb} options verbatim.
% The \pkg{fancyvrb} manual has more details, only some parts are reproduced hereafter.
% All of these options may not be relevant for all situations.
% Some of them make no sense in |code| mode, whereas others may not be
% compatible with the display engine.
%
% \subsubsection{\texttt{__fancyvrb.block} \pkg{l3keys} module}
%
% Block specific options, except numbering.
%    \begin{MacroCode}[OK]
\regex_const:Nn \c_CDR_alg_regex { ^\s*[^[:alpha:]^] }
\CDRTag_keys_define:nn { __fancyvrb.block } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed commentchar=\meta{character}]^^A
% lines starting with this character are ignored.
% Initially empty.
%    \begin{MacroCode}[OK]
  commentchar .code:n = \CDRTag_set:,
  commentchar .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed baselinestretch=auto$\vert$\meta{dimension}]^^A
% value to give to the usual \cs{baselinestretch} \LaTeX{} parameter.
% Initially \texttt{auto}: its current value just before the verbatim command.
%    \begin{MacroCode}[OK]
  baselinestretch .code:n = \CDRTag_set:, 
  baselinestretch .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckProhibited commandchars=\meta{three characters}]^^A
% characters which define the character which starts a macro and marks the
% beginning and end of a group; thus lets us introduce escape sequences in
% verbatim code. Of course, it is better to choose special characters which
% are not used in the verbatim text.
% Private to \pkg{coder}, unavailable to users.
% \itemtt[\CDRCheckRed label={\{[\meta{top string}]^^A
%\meta{string}\}}]
% label(s) to print on top, bottom or both, frame lines.
% If the label(s) contains special characters, comma or equal sign,
% it must be placed inside a group.
% If an optional \metatt{top string} is given between square brackets,
% it will be used for the top line and \metatt{string} for the bottom line.
% Otherwise, \metatt{string} is used for both the top or bottom lines.
% Label(s) are printed only if the \texttt{frame} parameter is one of
% \texttt{topline}, \texttt{bottomline}, \texttt{lines} or \texttt{single}.
% Initially empty: no label.
%    \begin{MacroCode}[OK]
  label .code:n = \CDRTag_set:,
  label .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    commentchar = ,
    baselinestretch = auto,
    label = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDRTag_keys_set:nn { __fancyvrb.block } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__numbering} \pkg{l3keys} module}
% Block line numbering.
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { __numbering } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed numbers=none$\vert$left$\vert$right]^^A
% numbering of the verbatim lines.
% If requested, this numbering is done outside the verbatim environment.
% Initially none: no numbering.
% 
%    \begin{MacroCode}[OK]
  numbers .choices:nn =
    { none, left, right }
    { \CDRTag_choices_set: },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed number sep=\meta{dimension}]^^A
% gap between numbers and verbatim lines.
% Initially 12pt.
%    \begin{MacroCode}[OK]
  number~sep .code:n = \CDRTag_set:,
  number~sep .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed first number=auto$\vert$last$\vert$\meta{integer}]^^A
% number of the first line.
% |last| means that the numbering is continued from the previous verbatim environment.
% If an integer is given, its value will be used to start the numbering.
% Initially \texttt{auto}: numbering starts from 1.
%    \begin{MacroCode}[OK]
  first~number .code:n = \CDRTag_set:n { \unexpanded { #1 } },
  first~number .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed step number=\meta{integer}]^^A
% interval at which line numbers are printed.
% Initially 1: all lines are numbered.
%    \begin{MacroCode}[OK]
  step~number .code:n = \CDRTag_set:n { \unexpanded { #1 } },
  step~number .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed numberblanklines{[=true$\vert$false]}]^^A
% to number or not the white lines (really empty or containing blank characters only).
% Initially |true|: all lines are numbered.
%    \begin{MacroCode}[OK]
  numberblanklines .code:n = \CDRTag_boolean_set:x { #1 },
  numberblanklines .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed firstline=\meta{integer expression}$\vert$\meta{regex}]^^A
% first line to print.
% Initially empty: all lines from the first are printed.
% When not void, it is considered as a regular expression when
% starting with a letter or the |^| character. Otherwise,
% it should expand to an integer.
%    \begin{MacroCode}[OK]
  firstline .code:n = \CDRTag_set:n { \unexpanded { #1 } },
  firstline .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed lastline=\meta{integer}$\vert$\meta{regex}]^^A
% last line to print.
% Initially empty: all lines until the last one are printed.
%    \begin{MacroCode}[OK]
  lastline .code:n = \CDRTag_set:n { \unexpanded { #1 } },
  lastline .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    numbers = left,
    number~sep = 1ex,
    first~number = auto,
    step~number = 1,
    numberblanklines = true,
    firstline = ,
    lastline = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDRTag_keys_set:nn { __numbering } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__fancyvrb.all }
% \pkg{l3keys} module}
% Options available when \pkg{pygments} is not used.
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { __fancyvrb.all } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed commandchars=\meta{three characters}]^^A
% characters that define the character that starts a macro and marks the beginning
% and end of a group; allows to introduce escape sequences in the verbatim code.
% Of course, it is better to choose special characters that are not used in
% the verbatim text!
% Initially |none|.
% Ignored in \pkg{pygments} mode.
%    \begin{MacroCode}[OK]
  commandchars .code:n = \CDRTag_set:, 
  commandchars .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed codes=\meta{macro}]^^A
% to specify catcode changes.
% For instance, this allows us to include formatted mathematics in verbatim text.
% Initially empty.
% Ignored in \pkg{pygments} mode.
%    \begin{MacroCode}[OK]
  codes .code:n = \CDRTag_set:, 
  codes .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    commandchars = ,
    codes = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDRTag_keys_set:nn { __fancyvrb.all } { __initialize }
}
%    \end{MacroCode}
%
% \section{\cs{CDRSet}}
% \begin{function}{\CDRSet}
% \begin{syntax}
% \cs{CDRSet} \Arg{key[=value] list}
% \cs{CDRSet} \{only description=true, font family=tt\}
% \cs{CDRSet} \{tag/default.code/font family=sf\}
% \end{syntax}
% To set up the package. This is executed at least once at the end of the preamble.
% The unique mandatory argument of \cs{CDRSet} is a
% list of \texttt{\meta{key}[=\meta{value}]} items defined by
% the \texttt{CDR@Set} \pkg{l3keys} module.
% \end{function}
%
% \subsection{\texttt{CDR@Set} \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\keys_define:nn { CDR@Set } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed only description]^^A
% to typeset only the description
% section and ignore the implementation section.
%    \begin{MacroCode}[OK]
  only~description .choices:nn = { false, true, {} } {
    \int_compare:nNnTF \l_keys_choice_int = 1 {
      \prg_set_conditional:Nnn \CDR_if_only_description: { p, T, F, TF } { \prg_return_true: }
    } {
      \prg_set_conditional:Nnn \CDR_if_only_description: { p, T, F, TF } { \prg_return_false: }
    }
  },
  only~description .initial:n = false,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed python path]^^A
% if automatic processing is not available, manually setting the path
% to the |python| utility is required. Giving a void path forces an automatic
% guess using |which|.
%    \begin{MacroCode}[OK]
  python~path .code:n = {
    \str_set:Nn \l_CDR_str { #1 }
    \exp_args:Nx \CDR_pygments_setup:n {
      \directlua { CDR:set_python_path('l_CDR_str') }
    }
  },
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%
% \subsection{Branching}
% \begin{function}[pTF]{\CDR_if_only_description:}
% \begin{syntax}
% \cs{CDR_if_only_description:TF} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when only the description is expected,
% \metatt{false code} otherwise.
% \emph{Implementation detail}: the functions are defined as part
% of the \texttt{CDR@Set} \pkg{l3keys} module.
% \end{function}
%
% \subsection{Implementation}
%
% \begin{function}{\CDRBlock_preflight:n}
% \begin{syntax}
% \cs{CDR_set_preflight:n} \Arg{CDR@Set kv list}
% \end{syntax}
% This is a prefligh hook intended for testing.
% The default implementation does nothing.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_set_preflight:n #1 { }
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRSet { m } {
\CDR@Debug{\string\CDRSet}
  \CDR_set_preflight:n { #1 }
  \keys_set_known:nnnN { CDR@Set } { #1 } { CDR@Set } \l_CDR_kv_clist
  \CDRTag_expand_kv:N \l_CDR_kv_clist
  \clist_map_inline:nn {
    __pygments,
    __tags, __engine, default.block, default.block.vrb, default.code, default,
    __fancyvrb.block, __numbering, __fancyvrb.all
  } {
    \CDRTag_keys_set_known:nN { ##1 } \l_CDR_kv_clist
\CDR@Debug{\string\CDRSet.1:##1/\l_CDR_kv_clist/ }
  }
  \CDRTag_keys_set_known:nN { .. } \l_CDR_kv_clist
\CDR@Debug{\string\CDRSet.2:\CDRTag_module:n { .. }+\l_CDR_kv_clist/ }
  \CDRTag_provide_from_kv:V \l_CDR_kv_clist
\CDR@Debug{\string\CDRSet.2a:\CDRTag_module:n { .. }+\l_CDR_kv_clist/ }  
  \CDRTag_keys_set_known:nN { .. } \l_CDR_kv_clist
\CDR@Debug{\string\CDRSet.3:\CDRTag_module:n { .. }+\l_CDR_kv_clist/ }
  \CDRTag_keys_set:nV { default } \l_CDR_kv_clist
\CDR@Debug{\string\CDRSet.4:\CDRTag_module:n { default } /\l_CDR_kv_clist/ }
  \keys_define:nn { CDR@Set@tags } {
    tags .code:n = {
      \clist_set:Nx \g_CDR_tags_clist { ##1 }
      \clist_remove_duplicates:N \g_CDR_tags_clist
    },
  }
  \keys_set_known:nn { CDR@Set@tags } { #1 }
  \ignorespaces
}
%    \end{MacroCode}
%
%
% \section{\cs{CDRBlockExport}}
% \begin{function}{\CDRBlockExport}
% \begin{syntax}
% \cs{CDRBlockExport} \Arg{key[=value] controls}
% \end{syntax}
% The \texttt{\meta{key}[=\meta{value}]} controls are defined by
% \texttt{CDR@Export} \pkg{l3keys} module.
% \end{function}
%
% \subsection{Storage}
%
% \begin{function}[EXP]{\CDR_export_get_path:cc}
% \begin{syntax}
% \cs{CDRTag_export_path:cc} \Arg{file name} \Arg{relative key path}
% \end{syntax}
% Internal: return a unique key based on the arguments.
% Used to store and retrieve values.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_export_get_path:cc #1 #2 {
  CDR @ export @ get @ #1 / #2
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_export_set:ccn, \CDR_export_set:Vcn, \CDR_export_set:VcV}
% \begin{syntax}
% \cs{CDR_export_set:ccn} \Arg{file name} \Arg{relative key path} \Arg{value}
% \end{syntax}
% Store \metatt{value}, which is further retrieved with the instruction
% |\CDR_get_get:cc {|\metatt{file name}|}| \linebreak[3]|{|\metatt{relative key path}|}|.
% All the affectations are made at the global \TeX{} group level.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_export_gset:ccn #1 #2 #3 {
  \cs_gset:cpn { \CDR_export_get_path:cc { #1 } { #2 } } { \exp_stop_f: #3 }
}
\cs_new_protected:Npn \CDR_export_gset:Vcn #1 {
  \exp_args:NV
  \CDR_export_gset:ccn { #1 }
}
\cs_new_protected:Npn \CDR_export_gset:VcV #1 #2 #3 {
  \exp_args:NnV
  \use:n {
    \exp_args:NV \CDR_export_gset:ccn #1 { #2 }
  } #3
}
%    \end{MacroCode}
%
% \begin{function}[TF,EXP]{\CDR_export_if_exist:cc}
% \begin{syntax}
% \cs{CDR_export_if_exist:ccTF} \Arg{file name} \meta{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% If the \metatt{relative key path} is known within \metatt{file name},
% the \metatt{true code} is executed,
% otherwise, the \metatt{false code} is executed.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_export_if_exist:cc { p, T, F, TF } {
  \cs_if_exist:cTF { \CDR_export_get_path:cc { #1 } { #2 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP]{\CDR_export_get:cc}
% \begin{syntax}
% \cs{CDR_export_get:cc} \Arg{file name} \Arg{relative key path}
% \end{syntax}
% The property value stored for \metatt{file name}
% and \metatt{relative key path}.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_export_get:cc #1 #2 {
  \CDR_export_if_exist:ccT { #1 } { #2 } {
    \use:c { \CDR_export_get_path:cc { #1 } { #2 } }
  }
}
%    \end{MacroCode}
%
% \begin{function}[TF]{\CDR_export_get:ccN}
% \begin{syntax}
% \cs{CDR_export_get:ccNTF} \Arg{file name} \Arg{relative key path}
% \meta{tl var} \Arg{true code} \Arg{false code}
% \end{syntax}
% Get the property value stored for \metatt{file name}
% and \metatt{relative key path}, copy it to \metatt{tl var}.
% Execute \metatt{true code} on success, \metatt{false code} otherwise.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_protected_conditional:Nnn \CDR_export_get:ccN { T, F, TF } {
  \CDR_export_if_exist:ccTF { #1 } { #2 } {
    \tl_set:Nf #3 { \CDR_export_get:cc { #1 } { #2 } }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \subsection{Storage}
%
% \begin{variable}{\g_CDR_export_seq}
% Global list of all the files to be exported.
%    \begin{MacroCode}[OK]
\seq_new:N \g_CDR_export_seq
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_file_tl}
% Store the file name used for exportation, used as key in the above property list.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_file_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\l_CDR_export_prop}
% Used by \texttt{CDR@Export} \pkg{l3keys} module to temporarily store properties.
%    \begin{MacroCode}[OK]
\prop_new:N \l_CDR_export_prop
%    \end{MacroCode}
% \end{variable}
%
% \subsection{\texttt{CDR@Export} \pkg{l3keys} module}
% No initial value is given for every key.
% An |__initialize| action will set the storage with proper initial values.
%    \begin{MacroCode}[OK]
\keys_define:nn { CDR@Export } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed file=\meta{name}]^^A
% the output file name, must be provided otherwise an error is raised.
%    \begin{MacroCode}[OK]
  file .tl_set:N = \l_CDR_file_tl,
  file .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed tags=\meta{tags comma list}]^^A
% the list of tags. No exportation when this list is void.
% Initially empty.
%    \begin{MacroCode}[OK]
  tags .code:n = {
    \clist_set:Nx \l_CDR_clist { #1 }
    \clist_remove_duplicates:N \l_CDR_clist
    \prop_put:NVV \l_CDR_export_prop \l_keys_key_str \l_CDR_clist
  },
  tags .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed lang]^^A
% one of the languages \pkg{pygments} is aware of.
% Initially |tex|.
%    \begin{MacroCode}[OK]
  lang .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  lang .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed preamble=\meta{preamble content}]^^A
% the added preamble.
% Initially empty.
%    \begin{MacroCode}[OK]
  preamble .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  preamble .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed preamble file=\meta{preamble file path}]^^A
% when provided, the preamble is the content of the file at the given path,
% overriding the |preamble| option. |escape~inside| applies.
% Initially empty.
%    \begin{MacroCode}[OK]
  preamble~file .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  preamble~file .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed postamble=\meta{postamble content}]^^A
% the added postamble.
% Initially empty.
%    \begin{MacroCode}[OK]
  postamble .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  postamble .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed postamble file=\meta{postamble file path}]^^A
% when provided, the postamble is the content of the file at the given path,
% overriding the |postamble| option. |escape~inside| applies.
% Initially empty.
%    \begin{MacroCode}[OK]
  postamble~file .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  postamble~file .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed escape~inside=\meta{2 delimiters}]^^A
% When provided, the text of the preamble or the postamble enclosed
% between the delimiters is interpreted as \LaTeX{} instructions.
% Quite any unicode character is permitted, except the caret |^|.
% Useful to insert the current date.
% Initially empty.
%    \begin{MacroCode}[OK]
  escape~inside .code:n = {
    \prop_put:NVn \l_CDR_export_prop \l_keys_key_str { #1 }
  },
  escape~inside .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed raw{[=true$\vert$false]}]^^A
% true to remove any additional material, false otherwise.
% Initially |false|.
%    \begin{MacroCode}[OK]
  raw .choices:nn = { false, true, {} } {
    \prop_put:NVx \l_CDR_export_prop \l_keys_key_str {
      \int_compare:nNnTF
        \l_keys_choice_int = 1 { false } { true }
    }
  },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed once{[=true$\vert$false]}]^^A
% true to remove any additional material, false otherwise.
% Initially |true|.
%    \begin{MacroCode}[OK]
  once .choices:nn = { false, true, {} } {
    \prop_put:NVx \l_CDR_export_prop \l_keys_key_str {
      \int_compare:nNnTF
        \l_keys_choice_int = 1 { false } { true }
    }
  },
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Properly initialize the local property storage.
%    \begin{MacroCode}[OK]
  __initialize .code:n = \prop_clear:N #1,
  __initialize .default:n = \l_CDR_export_prop,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
% 
% \subsection{Implementation}
% \begin{variable}{\CDRPercent, \CDRHash}
% To include a |%| or a |#| character in the preamble or the postamble below.
% Must be escaped.
% \end{variable}
%    \begin{MacroCode}[OK]
\str_set_eq:NN \CDRPercent \c_percent_str
\str_set_eq:NN \CDRHash \c_hash_str
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\str_set_eq:NN \CDRPercent \c_percent_str
\str_set_eq:NN \CDRHash \c_hash_str
\NewDocumentCommand \CDRBlockExport { m } {
  \keys_set:nn { CDR@Export } { __initialize }
  \keys_set:nn { CDR@Export } { #1 }
  \tl_if_empty:NTF \l_CDR_file_tl {
    \PackageWarning
      { coder }
      { Missing~export~key~`file' }
  } {
    \CDR_export_gset:VcV \l_CDR_file_tl { file } \l_CDR_file_tl
    \prop_map_inline:Nn \l_CDR_export_prop {
      \CDR_export_gset:Vcn \l_CDR_file_tl { ##1 } { ##2 }
    }
%    \end{MacroCode}
% The list of tags must not be empty, raise an error otherwise.
% Records the list in |\g_CDR_tags_clist|, it will be the default list
% of forthcoming code blocks if the |default tags| is not set.
%    \begin{MacroCode}[OK]
    \prop_get:NnNTF \l_CDR_export_prop { tags } \l_CDR_clist {
      \clist_set_eq:NN \g_CDR_tags_clist \l_CDR_clist
      \clist_if_empty:NF \l_CDR_clist {
        \clist_remove_duplicates:N \g_CDR_tags_clist
        \clist_put_left:NV \g_CDR_all_tags_clist \l_CDR_clist
        \clist_remove_duplicates:N \g_CDR_all_tags_clist
%    \end{MacroCode}
% If a |lang| is given, forwards the declaration
% to all the code chunks tagged within |\g_CDR_tags_clist|.
%    \begin{MacroCode}[OK]
        \CDR_export_get:ccNT { \l_CDR_file_tl } { lang } \l_CDR_a_tl {
          \clist_map_inline:Nn \g_CDR_tags_clist {
            \CDRTag_set:ccV { ##1 } { lang } \l_CDR_a_tl
          }
        }
      }
      \seq_put_left:NV \g_CDR_export_seq \l_CDR_file_tl
      \seq_remove_duplicates:N \g_CDR_export_seq
    } {
      \CDR_export_if_exist:ccF { \l_CDR_file_tl } { tags }  {
        \PackageWarning
          { coder }
          { Missing~export~key~`tags' }
      }
    }
  }
  \ignorespaces
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_rescan_regex_split:NNn}
% \begin{syntax}
% \cs{CDR_escapeinside:Nn} \meta{regex variable} \meta{tl variable} \Arg{argument}
% \end{syntax}
% Escape the content of \metatt{argumen} with
% respect to \metatt{regex variable} and put the result in \meta{tl variable}.
% Implementation detail: uses |\l_CDR_a_tl| and |\l_CDR_seq|.
% \end{function}
%    \begin{MacroCode}
\cs_new_protected:Npn \CDR_rescan_regex_split:NNn #1 #2 #3 {
  \regex_split:NnN #1 { #3 } \l_CDR_seq
  \seq_pop_left:NN \l_CDR_seq #2
  \bool_until_do:nn { \seq_if_empty_p:N \l_CDR_seq } {
    \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl
    \exp_args:NNnV
    \tl_set_rescan:Nnn \l_CDR_a_tl {} \l_CDR_a_tl
    \tl_put_right:NV #2 \l_CDR_a_tl
    \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl
    \tl_put_right:NV #2 \l_CDR_a_tl
  }
}
%    \end{MacroCode}
%
% Files are created at the end of the typesetting process.
% We define a separate macro to be used for testing purposes.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_export_complete: {
\CDR@Debug{\string\CDR_export_complete:}
  \prg_set_conditional:Nnn \CDR_if_amblefile:nNn { T, F, TF } {
    \CDR_export_get:ccNTF { ##1 } { ##3~file } ##2 {
      \tl_if_empty:NTF ##2 {
\CDR@Debug{\string\CDR_export_complete:~empty~file~option}
        \prg_return_false:
      } {
        \exp_args:NV
        \file_if_exist:nTF ##2 {
          \prg_return_true:      
        } {
\CDR@Debug{\string\CDR_export_complete:~no~file~at~##2}
          \prg_return_false:
        }
      }
    } {
\CDR@Debug{\string\CDR_export_complete:~no~option~'##1->##3~file' }
      \prg_return_false:
    }
  }
  \prg_set_conditional:Nnn \CDR_export_if_tags:nN { T, F, TF } {
    \CDR_export_get:ccNTF { ##1 } { tags } ##2 {
      \tl_if_empty:NTF ##2 {
        \prg_return_false:
      } {
        \prg_return_true:
      }
    } {
      \prg_return_false:
    }
  }
  \seq_map_inline:Nn \g_CDR_export_seq {
\CDR@Debug{\string\CDR_export_complete:~FILE~##1}
    \CDR_export_if_tags:nNTF { ##1 } \l_CDR_clist {
      \str_set:Nx \l_CDR_str { ##1 }
      \directlua {
        CDR:export_file('l_CDR_str');
        CDR:export_file_info('tags','l_CDR_clist');
      }
\CDR@Debug{\string\CDR_export_complete:~TAGS~\l_CDR_clist}
      \clist_map_inline:nn { raw, once, } {
        \CDR_export_get:ccNTF { ##1 } { ####1 } \l_CDR_b_tl {
          \directlua {
            CDR:export_file_info('####1','l_CDR_b_tl')
          }
        } {
          \CDR@Debug{\string\CDR_export_complete:~no~####1}
        }
      }
      \tl_clear:N \l_CDR_regex
      \CDR_export_get:ccNT { ##1 } { escape~inside } \l_CDR_a_tl {
        \int_compare:nNnTF { \tl_count:N \l_CDR_a_tl } = 1 {
          \regex_set:Nx \l_CDR_regex {
            [ \tl_item:Nn \l_CDR_a_tl 1 ]
            ( .*? )
            [ \tl_item:Nn \l_CDR_a_tl 1 ]
          }
        } {
          \int_compare:nNnT { \tl_count:N \l_CDR_a_tl } > 1 {
            \regex_set:Nx \l_CDR_regex {
              [ \tl_item:Nn \l_CDR_a_tl 1 ]
              ( .*? )
              [ \tl_item:Nn \l_CDR_a_tl 2 ]
            }
          }
        }
      }
%    \end{MacroCode}
% Read preamble and postamble from file if any.
%    \begin{MacroCode}[OK]
      \clist_map_inline:nn { preamble, postamble, } {
\CDR@Debug{\string\CDR_export_complete:~####1}
        \CDR_if_amblefile:nNnTF { ##1 } \l_CDR_a_tl { ####1 } {
\CDR@Debug{\string\CDR_export_complete:~file: \l_CDR_a_tl}
          \exp_args:NNV
          \ior_open:Nn \l_CDR_ior \l_CDR_a_tl
          \tl_if_empty:NTF \l_CDR_regex {
            \ior_str_map_inline:Nn \l_CDR_ior {
              \l_set:Nn \l_CDR_b_tl { ########1 }
              \directlua {
                CDR:append_file_info('####1','l_CDR_b_tl')
              }
            }
          } {
            \ior_str_map_inline:Nn \l_CDR_ior {
              \CDR_rescan_regex_split:NNn
                \l_CDR_regex
                \l_CDR_b_tl
                { ########1 }
              \tl_set:Nx \l_CDR_b_tl { \l_CDR_b_tl }
              \directlua {
                CDR:append_file_info('####1','l_CDR_b_tl')
              }
            }
          }
          \ior_close:N \l_CDR_ior
        } {
\CDR@Debug{\string\CDR_export_complete:~no~file}
          \tl_if_empty:NTF \l_CDR_regex {
            \CDR_export_get:ccNTF { ##1 } { ####1 } \l_CDR_b_tl {
              \directlua {
                CDR:append_file_info('####1','l_CDR_b_tl')
              }
            } {
\CDR@Debug{\string\CDR_export_complete:~no~'##1'->'####1' }
            }
          } {
            \CDR_export_get:ccNTF { ##1 } { ####1 } \l_CDR_a_tl {
              \exp_args:NNV
              \regex_split:NnN \l_CDR_regex \l_CDR_a_tl \l_CDR_seq
              \seq_pop_left:NN \l_CDR_seq \l_CDR_b_tl
              \bool_until_do:nn { \seq_if_empty_p:N \l_CDR_seq } {
                \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl
                \tl_put_right:Nx \l_CDR_b_tl { \l_CDR_a_tl }
                \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl
                \tl_put_right:NV \l_CDR_b_tl \l_CDR_a_tl
              }
              \directlua {
                CDR:append_file_info('####1','l_CDR_b_tl')
              }
            } {
\CDR@Debug{\string\CDR_export_complete:~no~'##1'->'####1' }
            }
          }
        }
      }
      \directlua { CDR:export_complete() }
    } {
      \typeout {\string\CDR_export_complete:~##1:~nothing~to~export}
    }
  }
  \cs_set_eq:NN \CDR_export_complete: \prg_do_nothing:
}

\AddToHook { enddocument / end } {
  \CDR_export_complete:
}
%    \end{MacroCode}
%
% \section{Style}
% \pkg{pygments}, through \CDRPy{}, creates style commands,
% but the storage is managed on the \LaTeX{} side by \CDRSty{}.
% This is a \LaTeX{} style API.
%
% \begin{function}{\CDR_style:c}
% \begin{syntax}
% \cs{CDR_style:c} \Arg{pygments style name}
% \end{syntax}
% Turn the \metatt{pygments style name} into a unique macro name.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_set:Npn \CDR_style:c #1 {
  g_CDR@Style/#1:
}
%    \end{MacroCode}
%
% \begin{function}{\CDR@StyleDefine}
% \begin{syntax}
% \cs{CDR@StyleDefine} \Arg{pygments style name} \Arg{definitions}
% \end{syntax}
% Define the definitions for the given \metatt{pygments style name}.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDR@StyleDefine #1 {
\CDR@Debug { \string\CDR@StyleDefine/#1 }
  \tl_gset:cn { \CDR_style:c { #1 } }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR@StyleUse, CDR@StyleUseTag}
% \begin{syntax}
% \cs{CDR@StyleUse} \Arg{pygments style name}
% \cs{CDR@StyleUseTag}
% \end{syntax}
% Use the definitions for the given \metatt{pygments style name}.
% No safe check is made.
% The |\CDR@StyleUseTag| version finds the \metatt{pygments style name}
% from the context.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDR@StyleUse #1 {
\CDR@Debug{\string\CDR@StyleUse/#1}
  \tl_use:c { \CDR_style:c { #1 } }
}
\cs_set:Npn \CDR@StyleUseTag {
\CDR@Debug{\string\CDR@StyleUseTag}
  \CDR@StyleUse { \CDRTag_get:c { style } }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR@StyleExist}
% \begin{syntax}
% \cs{CDR@StyleExist} \Arg{pygments style name} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} if a style exists with that given name,
% \metatt{false code} otherwise.
% \end{function}
%    \begin{MacroCode}
\prg_new_conditional:Nnn \CDR@StyleIfExist:c { TF } {
  \tl_if_exist:cTF { \CDR_style:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\cs_set_eq:NN \CDR@StyleIfExist \CDR@StyleIfExist:cTF
%    \end{MacroCode}
%
% \section{Creating display engines}
% \subsection{Utilities}
%
% \begin{function}[EXP]{\CDRCode_engine:c, \CDRCode_engine:V, \CDRBlock_engine:c, \CDRBlock_engine:V}
% \begin{syntax}
% \cs{CDRCode_engine:c} \Arg{engine name}
% \cs{CDRBlock_engine:c} \Arg{engine name}
% \end{syntax}
% |\CDRCode_engine:c| builds a command sequence name
% based on \metatt{engine name}.
% |\CDRBlock_engine:c| builds an environment name
% based on \metatt{engine name}.
%\end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRCode_engine:c #1 {
  CDR@colored/code/#1:nn
}
\cs_new:Npn \CDRBlock_engine:c #1 {
  CDR@colored/block/#1
}
\cs_new:Npn \CDRCode_engine:V {
  \exp_args:NV \CDRCode_engine:c
}
\cs_new:Npn \CDRBlock_engine:V {
  \exp_args:NV \CDRBlock_engine:c
}
%    \end{MacroCode}
%
% \begin{function}[EXP]{\CDRCode_options:c, \CDRCode_options:V, \CDRBlock_options:c, \CDRBlock_options:V}
% \begin{syntax}
% \cs{CDRCode_options:c} \Arg{engine name}
% \cs{CDRBlock_options:c} \Arg{engine name}
% \end{syntax}
% |\CDRCode_options:c| builds a command sequence name
% based on \metatt{engine name} used to store the comma list of key value options.
% |\CDRBlock_options:c| builds a command sequence name
% based on \metatt{engine name} used to store the comma list of key value options.
%\end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRCode_options:c #1 {
  CDR@colored/code~options/#1:nn
}
\cs_new:Npn \CDRBlock_options:c #1 {
  CDR@colored/block~options/#1
}
\cs_new:Npn \CDRCode_options:V {
  \exp_args:NV \CDRCode_options:c
}
\cs_new:Npn \CDRBlock_options:V {
  \exp_args:NV \CDRBlock_options:c
}
%    \end{MacroCode}
%
% \begin{function}[EXP]{\CDRCode_options_use:c, \CDRCode_options_use:V, \CDRBlock_options_use:c, \CDRBlock_options_use:V}
% \begin{syntax}
% \cs{CDRCode_options_use:c} \Arg{engine name}
% \cs{CDRBlock_options_use:c} \Arg{engine name}
% \end{syntax}
% |\CDRCode_options_use:c| builds a command sequence name
% based on \metatt{engine name} and use it.
% |\CDRBlock_options:c| builds a command sequence name
% based on \metatt{engine name} and use it.
%\end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDRCode_options_use:c #1 {
  \CDRCode_if_options:cT { #1 } {
    \use:c { \CDRCode_options:c { #1 } }
  }
}
\cs_new:Npn \CDRBlock_options_use:c #1 {
  \CDRBlock_if_options:cT { #1 } {
    \use:c { \CDRBlock_options:c { #1 } }
  }
}
\cs_new:Npn \CDRCode_options_use:V {
  \exp_args:NV \CDRCode_options_use:c
}
\cs_new:Npn \CDRBlock_options_use:V {
  \exp_args:NV \CDRBlock_options_use:c
}
%    \end{MacroCode}
%
% \begin{variable}{\l_CDR_engine_tl}
% Storage for an engine name.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_engine_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDRGetOption}
% \begin{syntax}
% \cs{CDRGetOption} \Arg{relative key path}
% \end{syntax}
% Returns the value given to |\CDRCode| command or |CDRBlock| environment
% for the \metatt{relative key path}.
% This function is only available during |\CDRCode| execution
% and inside |CDRBlock| environment.
% \end{function}
%
% \subsection{Implementation}
%
% \begin{function}{\CDRCodeEngineNew, \CDRCodeEngineRenew}
% \begin{syntax}
% \cs{CDRCodeEngineNew}  \Arg{engine name}\Arg{engine body}
% \cs{CDRCodeEngineRenew}\Arg{engine name}\Arg{engine body}
% \end{syntax}
% \metatt{engine name} is a non void string, once expanded.
% The \metatt{engine body} is a list of instructions which may refer to
% the first argument as |#1|,
% which is the value given for key \metatt{engine name}| engine options|,
% and the second argument as |#2|, which is the colored code.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_forbidden:n #1 {
  \group_begin:
  \CDR_local_inherit:n { __no_tag, __no_engine }
  \CDR_local_set_known:nN { #1 } \l_CDR_kv_clist
  \group_end:
}
\NewDocumentCommand \CDRCodeEngineNew { mO{}m } {
  \exp_args:Nx
  \tl_if_empty:nTF { #1 } {
    \PackageWarning
      { coder }
      { The~engine~cannot~be~void. }
  } {
    \CDR_forbidden:n { #2 }
    \cs_set:cpn { \CDRCode_options:c { #1 } } { \exp_not:n { #2 } }
    \cs_new:cpn { \CDRCode_engine:c {#1} } ##1 ##2 {
      \cs_set_eq:NN \CDRGetOption \CDRTag_get:c
      #3
    }
    \ignorespaces
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR_forbidden_keys:n}
% \begin{syntax}
% \cs{CDR_forbidden_keys:n} \Arg{key[=value] items}
% \end{syntax}
% Raise an error if one of |tags| and |engine| keys is provided in
% \metatt{key[=value] items}.
% These keys are forbidden for the \pkg{\jobname} options associate to
% an engine.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_forbidden_keys:n #1 {
  \group_begin:
  \CDR_local_inherit:n { __no_tags, __no_engine }
  \CDR_local_set_known:nN { #1 } \l_CDR_kv_clist
  \group_end:
}
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRCodeEngineRenew { mO{}m } {
  \exp_args:Nx
  \tl_if_empty:nTF { #1 } {
    \PackageWarning
      { coder }
      { The~engine~cannot~be~void. }
      \use_none:n
  } {
    \cs_if_exist:cTF { \CDRCode_engine:c { #1 } } {
      \CDR_forbidden:n { #2 }
      \cs_set:cpn { \CDRCode_options:c { #1 } } { \exp_not:n { #2 } }
      \cs_set:cpn { \CDRCode_engine:c { #1 } } ##1 ##2 {
        \cs_set_eq:NN \CDRGetOption \CDRTag_get:c
        #3
      }
    } {
      \PackageWarning
        { coder }
        { No~code~engine~#1.}
    }
    \ignorespaces
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR@CodeEngineApply}
% \begin{syntax}
% \cs{CDR@CodeEngineApply} \Arg{source}
% \end{syntax}
% Get the code engine and apply it to the given \metatt{source}.
% When the code engine is not recognized, an error is raised.
% \emph{Implementation detail}: the argument is parsed by the last macro.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR@CodeEngineApply {
  \CDRCode_if_engine:cF { \CDRTag_get:c { engine } } {
    \PackageError
      { coder }
      { \CDRTag_get:c { engine }~code~engine~unknown,~replaced~by~`default' }
      { See~\CDRCodeEngineNew~in~the~coder~manual }
    \CDRTag_set:cn { engine } { default }
  }
  \CDRTag_get:c { format }  
  \exp_args:Nnx
  \use:c { \CDRCode_engine:c { \CDRTag_get:c { engine } } } {
    \CDRTag_get:c { \CDRTag_get:c { engine }~engine~options },
    \CDRTag_get:c { engine~options }
  }
}
%    \end{MacroCode}
% \begin{function}{\CDRBlockEngineNew, \CDRBlockEngineRenew}
% \begin{syntax}
% \cs{CDRBlockEngineNew}   \Arg{engine name} \oarg{options} \Arg{begin instructions} \Arg{end instructions}
% \cs{CDRBlockEngineRenew} \Arg{engine name} \oarg{options} \Arg{begin instructions} \Arg{end instructions}
% \end{syntax}
% Create a \LaTeX{} environment uniquely named after \metatt{engine name},
% which must be a non void string once expanded.
% The \metatt{begin instructions} and \metatt{end instructions}
% are lists of instructions which may refer to the name as |#1|,
% which is the value given to |CDRBlock| environment
% for key \metatt{engine name}| engine options|.
% Various options are available with the |\CDRGetOption| function.
% \emph{Implementation detail}: the fourth argument is parsed by
% |\NewDocumentEnvironment|.
% \end{function}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRBlockEngineNew { mO{}m } {
  \CDR_forbidden:n { #2 }
  \cs_set:cpn { \CDRBlock_options:c { #1 } } { \exp_not:n { #2 } }
  \NewDocumentEnvironment { \CDRBlock_engine:c { #1 } } { m } {
    \cs_set_eq:NN \CDRGetOption \CDRTag_get:c
    #3
  }
}
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRBlockEngineRenew { mO{}m } {
  \tl_if_empty:nTF { #1 } {
    \PackageError
      { coder }
      { The~engine~cannot~be~void. }
      { See~\string\CDRBlockEngineNew~in~the~coder~manual }
      \use_none:n
  } {
    \cs_if_exist:cTF { \CDRBlock_engine:c { #1 } } {
      \CDR_forbidden:n { #2 }
      \cs_set:cpn { \CDRBlock_options:c { #1 } } { \exp_not:n { #2 } }
      \RenewDocumentEnvironment { \CDRBlock_engine:c { #1 } } { m } {
        \cs_set_eq:NN \CDRGetOption \CDRTag_get:c
        #3
      }
    } {
      \PackageError
        { coder }
        { No~block~engine~#1.}
        { See~\string\CDRBlockEngineNew~in~the~coder~manual }
    }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_engine_begin:, \CDR@Block_engine_end:}
% \begin{syntax}
% \cs{CDRBlock_engine_begin:}
% \cs{CDRBlock_engine_end:}
% \end{syntax}
% After some checking, begin the engine display environment with the proper options.
% The second command closes the environment.
% This does not start a new group.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_engine_begin: {
\CDR@Debug{\string\CDRBlock_engine_begin:}
  \CDRBlock_if_engine:cF { \CDRTag_get:c { engine } } {
    \PackageError
      { coder }
      { \CDRTag_get:c { engine }~block~engine~unknown,~replaced~by~`default' }
      {See~\CDRBlockEngineNew~in~the~coder~manual}
    \CDRTag_set:cn { engine } { default }
  }
  \exp_args:Nnx
  \use:c { \CDRBlock_engine:c \CDRTag_get:c { engine } } {
    \CDRTag_get:c { \CDRTag_get:c { engine }~engine~options },
    \CDRTag_get:c { engine~options },
  }
}
\cs_new:Npn \CDRBlock_engine_end: {
\CDR@Debug{\string\CDRBlock_engine_end:}
  \use:c { end \CDRBlock_engine:c \CDRTag_get:c { engine } }
}
%    \begin{MacroCode}
%
% \subsection{Conditionals}
%
% \begin{function}[EXP,TF]{\CDRCode_if_engine:c}
% \begin{syntax}
% \cs{CDRCode_if_engine:cTF} \Arg{engine name} \Arg{true code} \Arg{false code}
% \end{syntax}
% If there exists a code engine with the given \metatt{engine name},
% execute \metatt{true code}.
% Otherwise, execute \metatt{false code}.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRCode_if_engine:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRCode_engine:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDRCode_if_engine:V { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRCode_engine:V #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \begin{function}[EXP,TF]{\CDRBlock_if_engine:c}
% \begin{syntax}
% \cs{CDRBlock_if_engine:c} \Arg{engine name} \Arg{true code} \Arg{false code}
% \end{syntax}
% If there exists a block engine with the given \metatt{engine name},
% execute \metatt{true code}, otherwise, execute \metatt{false code}.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRBlock_if_engine:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRBlock_engine:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDRBlock_if_engine:V { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRBlock_engine:V #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP,TF]{\CDRCode_if_options:c}
% \begin{syntax}
% \cs{CDRCode_if_options:cTF} \Arg{engine name} \Arg{true code} \Arg{false code}
% \end{syntax}
% If there exists a code options with the given \metatt{engine name},
% execute \metatt{true code}.
% Otherwise, execute \metatt{false code}.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRCode_if_options:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRCode_options:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDRCode_if_options:V { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRCode_options:V #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \begin{function}[EXP,TF]{\CDRBlock_if_options:c}
% \begin{syntax}
% \cs{CDRBlock_if_options:c} \Arg{engine name} \Arg{true code} \Arg{false code}
% \end{syntax}
% If there exists a block options with the given \metatt{engine name},
% execute \metatt{true code}, otherwise, execute \metatt{false code}.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDRBlock_if_options:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRBlock_options:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDRBlock_if_options:V { p, T, F, TF } {
  \cs_if_exist:cTF { \CDRBlock_options:V #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \subsection{Default code engine}
% The default code engine does nothing special and forwards its argument as is.
%    \begin{MacroCode}[OK]
\CDRCodeEngineNew { default } { #2 }
%    \end{MacroCode}
% 
% \subsection{\pkg{efbox} code engine}
%    \begin{MacroCode}
\AtBeginDocument {
  \@ifpackageloaded{efbox} {
    \CDRCodeEngineNew {efbox} {
      \efbox[#1]{#2}
    }
  } {}
}
%    \end{MacroCode}
% \subsection{Block mode default engine}
%    \begin{MacroCode}
\CDRBlockEngineNew { default } {
  \@bsphack
} {
  \@esphack
}
%    \end{MacroCode}
%
% \subsection{\pkg{tcolorbox} related engine}
% If the \pkg{tcolorbox} is loaded, related code and block engines are available.
%    \begin{MacroCode}
\AtBeginDocument {
  \@ifpackageloaded{tcolorbox} {
    \CDRBlockEngineNew {tcbox} {
      \begin{tcolorbox}[#1]
    } {
      \end{tcolorbox}
    }
  } {}
}
%    \end{MacroCode}
% 
% \section{\cs{CDRCode} function}
%
% \subsection{API}
%
% \begin{function}{\CDRCode}
% \begin{syntax}
% \cs{CDRCode}\Arg{key[=value]}\meta{delimiter}\meta{code}\meta{same delimiter}
% \end{syntax}
% Public method to declare inline code.
% \end{function}
%
% \subsection{Storage}
%
% \subsection{\texttt{__code} \pkg{l3keys} module}
% This is the module used to parse the user interface of the \cs{CDRCode} command.
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { __code } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed __initialize]^^A
% initialize
%    \begin{MacroCode}[OK]
  __initialize .meta:n = { 
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%
% \subsection{Implementation}
%
% \begin{variable}{\l_CDR_id_tl,\l_CDR_id_short_tl,\l_CDR_delimiters_tl,\l_CDR_gobble_tl}
% Storage on the \LaTeX\ side.
% \end{variable}
%    \begin{MacroCode}
\tl_new:N \l_CDR_id_tl
\tl_new:N \l_CDR_id_short_tl
\tl_new:N \l_CDR_delimiters_tl
\tl_new:N \l_CDR_gobble_tl
\tl_new:N \l_CDR_status_tl
%    \end{MacroCode}
%
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_to_str:c #1 {
  \exp_last_unbraced:Nx \string { \use:c{#1} }
}
\cs_new:Npn \CDRCode_id:c #1 {
  CDRCode / #1 :
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_new:c,\CDRCode_free:}
% \begin{syntax}
% \cs{CDRCode_new:c} \Arg{identifier}
% \cs{CDRCode_free:}
% \end{syntax}
% Prepare the current id, and feed |\l_CDR_id_tl|.
% Prepare a dedicated storage with attributes and methods
% as |CDR.Code| with the help of |Code_new| of \CDRLua.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRCode_new:c #1 {
  \tl_set:Nx \l_CDR_id_short_tl { #1 }
  \tl_set:Nx \l_CDR_id_tl { \CDRCode_id:c { #1 } }
  \directlua{
    CDR:Code_new()
  }
\CDR@Debug{\string\l_CDR_id_short_tl=\l_CDR_id_short_tl}
\CDR@Debug{\string\l_CDR_id_tl=\l_CDR_id_tl}
}
\cs_new:Npn \CDRCode_free: {
  \directlua{
    CDR:Code_free()
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP,pTF]{\CDRCode_if_unknown:}
% \begin{syntax}
% \cs{CDRCode_if_unknown:TF} \Arg{true code} \Arg{false code}
% \end{syntax}
% Assuming |\l_CDR_id_tl| has been properly set up,
% execute \metatt{true code} when a code or block
% is available, \metatt{false code} otherwise.
% \end{function}
%    \begin{MacroCode}
\CDR_set_conditional_alt:Nn \CDRCode_if_unknown: {
  \exp_args:Nf \tl_if_empty_p:n { \directlua {
    CDR.Code:sprint_known()
  } }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCodeSave}
% \begin{syntax}
% \cs{CDRCodeSave} \Arg{unique id} \metatt{delimiter}
% \end{syntax}
% \metatt{unique id} will be the argument of \cs{CDRCodeUse}.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRCodeSave #1 {
  \CDR@Debug{\string\CDRCodeSave/\tl_to_str:n{#1}}
  \group_begin:
  \CDRCode_new:c { #1 }
  \directlua {
    CDR.Code:synctex_store()
  }
  \cs_set:Npn \CDR: {
    \CDRCode_free:
    \group_end:
  }
  \CDRCode_peek:NN \CDR:
}
\cs_new:Npn \CDR@Source {}
\cs_new:Npn \CDRCode_setup:n #1 {
  \prg_set_conditional:Nnn \CDR_if_block: { p, T, F, TF } {
    \prg_return_false:
  }
  \clist_set:Nn \l_CDR_kv_clist { #1 }
  \CDRCode_tags_setup:N \l_CDR_kv_clist
  \CDRCode_engine_setup:N \l_CDR_kv_clist
  \CDR_local_inherit:n {
    __code, default.code, __pygments, default,
  }
  \CDR_local_set_known:N \l_CDR_kv_clist
  \CDRTag_provide_from_kv:V \l_CDR_kv_clist
  \CDR_local_set_known:N \l_CDR_kv_clist
  \CDR_local_set:V \l_CDR_kv_clist  
  \CDR_set_conditional:Nn \CDR_if_pygments: {
    \CDR_has_pygments_p: && \CDRTag_if_truthy_p:c {pygments}
  } 
  \CDRTag_if_eq:cnF { ref~label } { } {
    \exp_args:Nx \label {
      \CDRTag_get:c { ref~label }
    }
  }
  \CDRTag_get:cN { escape~inside  } \l_CDR_delimiters_tl
  \CDRTag_get:cN { gobble  } \l_CDR_gobble_tl
}
\NewDocumentCommand \CDRCodeUse { O{} m } {
\CDR@Debug{\string\CDRCodeUse=#2}
  \CDRCode_new:c { #2 }
  \CDRCode_if_unknown:TF {
\CDR@Debug{ \directlua { CDR:Code_list_all() } }
    \PackageError
      { coder }
      { Unknown~identifier:\space#2 }
      { See\space\string\CDRCodeSave }
    \CDRCode_free:
  } {
    \group_begin:
    \directlua {
      CDR.Code:synctex_save();
    }        
    \CDRCode_setup:n { #1 }
    \CDR_if_pygments:TF {
      \CDRCode_pyg_use:
    } {
      \CDRCode_vrb_use:
    }
    \directlua {
      CDR.Code:synctex_restore()
    }
    \group_end:
    \CDRCode_free:
  }
}
\NewDocumentCommand \CDRCodeExe { m } {
\CDR@Debug{\string\CDRCodeExe=#1}
  \CDRCode_new:c { #1 }
  \CDRCode_if_unknown:TF {
\CDR@Debug{ \directlua { CDR:Code_list_all() } }
    \PackageError
      { coder }
      { Unknown~identifier:\space#1 }
      { See\space\string\CDRCodeSave }
    \CDRCode_free:
  } {
    \directlua {
      CDR.Code:synctex_save();
      CDR.Code:sprint_inline();
      CDR.code:synctex_restore();
    }        
    \CDRCode_free:
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_escape_inside:n}
% \begin{syntax}
% \cs{CDRCode_escape_inside:n} \Arg{text}
% \end{syntax}
% When \pkg{pygments} does not manage what is escaped,
% it must be done by hand.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDRCode_escape_inside:n #1 {
\CDR@Debug{\string\CDRCode_escape_inside:nn}
  \CDRTag_get:cN { escape~inside } \l_CDR_delimiters_tl
  \int_compare:nNnTF { \tl_count:N \l_CDR_delimiters_tl } = 2 {
    \regex_set:Nx \l_CDR_regex {
      [ \tl_item:Nn \l_CDR_delimiters_tl { 1 } ]
      (.*?) [ \tl_item:Nn \l_CDR_delimiters_tl { 2 } ]
    }
    \regex_split:NnN \l_CDR_regex { #1 } \l_CDR_seq
  } {
    \int_compare:nNnTF { \tl_count:N \l_CDR_delimiters_tl } = 3 {
      \regex_set:Nx \l_CDR_regex {
        [ \tl_item:Nn \l_CDR_delimiters_tl { 1 } ]
        (.*?) [ \tl_item:Nn \l_CDR_delimiters_tl { 2 } ]
        .*? [ \tl_item:Nn \l_CDR_delimiters_tl { 3 } ]
      }
      \regex_split:NnN \l_CDR_regex { #1 } \l_CDR_seq
    } {
      \seq_clear:N \l_CDR_seq
    }
  }
  \seq_if_empty:NTF \l_CDR_seq {
    #1
  } {
    \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl \tl_use:N \l_CDR_a_tl
    \bool_while_do:nn { ! \seq_if_empty_p:N \l_CDR_seq } {
      \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl
      \exp_args:NnV
      \tl_rescan:nn { } \l_CDR_a_tl
      \seq_pop_left:NN \l_CDR_seq \l_CDR_a_tl \tl_use:N \l_CDR_a_tl  
    }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_peek:NN}
% \begin{syntax}
% \cs{CDRCode_peek:NN} \metatt{function} \metatt{delimiter}
% \end{syntax}
% Implementation detail: change the category code regime inside a group.
% \end{function}
%    \begin{MacroCode}
\tl_new:N \l_CDR_peek_tl
\cs_set:Npn \CDRCode_peek:NN #1 {
  \group_begin:
  \tl_clear:N \l_CDR_peek_tl
  \cs_set:Npn \CDRCode_peek_active_continue:n ##1 {
    \tl_put_right:Nn \l_CDR_peek_tl { ##1 }
    \CDRCode_peek_active:
  }
  \cs_set:Npn \CDRCode_peek_active_end:n ##1 {
    \directlua {
      CDR.Code:inline_save();
    }
    \exp_args:NNNV
    \group_end:
    \tl_set:Nn \l_CDR_peek_tl \l_CDR_peek_tl
    #1
  }
  \cctab_select:N \c_CDR_active_cctab
  \CDRCode_peek_active_begin:N
}
\cs_set:Npn \CDRCode_peek_active_begin:N #1 {
  \directlua{
    CDR.Code:peek_active_begin('\luaescapestring{ #1 }')
  }
  \char_set_active_eq:nN { `\    } \ %
  \char_set_active_eq:nN { `\^^I } \^^I %
  \char_set_active_eq:nN { `\^^M } \ %
  \char_set_catcode_active:n { `\^^M } %
\CDR@Debug{\string\CDRCode_peek_active_begin:N/#1/}
  \cs_set:Npn \CDRCode_peek_active: {
    \peek_meaning:NTF #1 {
      \exp_args:Nx \tl_if_empty:nF {
        \directlua{ CDR.Code:status() }
      } {
        \PackageError
          {coder}
          {Missing\space#1\space before\space next\space line}
          {Unterminated\space short\space verbatim\space input}
      }
      \directlua{ CDR.Code:peek_active_end() }
\typeout{\string\CDRCode_peek_active_end:n/#1/}
	      \CDRCode_peek_active_end:n
    } {
      \CDRCode_peek_active_continue:n
    }
  }
  \CDRCode_peek_active:
}

\NewDocumentCommand \CDRCode { O{} } {
  \group_begin:
  \CDRCode_new:c {}
  \directlua { CDR.Code:synctex_store() }
  \CDRCode_setup:n { #1 }
  \CDR_if_pygments:TF {
    \cs_set:Npn \CDR: {
      \CDRCode_pyg_use:
      \CDRCode_free:
      \group_end:
    }
  } {
    \cs_set:Npn \CDR: {
      \CDRCode_vrb_use:
      \CDRCode_free:
      \group_end:
    }
  }
  \CDRCode_peek:NN \CDR:
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_tags_setup:N, \CDRCode_engine_setup:N}
% \begin{syntax}
% \cs{CDRCode_tags_setup:N} \Arg{clist var}
% \cs{CDRCode_engine_setup:N} \Arg{clist var}
% \end{syntax}
% Utility to setup the tags, the tag inheritance tree and the engine.
% When not provided explicitly with the |tags=...| user interface,
% a code chunk will have the list of tags stored in |\g_CDR_tags_clist|
% by last |\CDRBlockExport|, |\CDRSet| or |\CDRBlock| environment.
% At least one tag must be provided, either implicitly or explicitly.
% \end{function}
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRCode_tags_setup:N #1 {
\CDR@Debug{\string \CDRCode_tags_setup:N, \string #1 }
  \CDR_local_inherit:n { __tags }
  \CDR_local_set_known:N #1
  \CDRTag_if_exist_here:ccT { __local } { tags } {
    \CDRTag_get:cN { tags } \l_CDR_clist
    \clist_if_empty:NF \l_CDR_clist {
      \clist_gset_eq:NN \g_CDR_tags_clist \l_CDR_clist
    }
  }
  \clist_if_empty:NT \g_CDR_tags_clist {
    \CDRTag_get:cN { default~tags } \g_CDR_tags_clist
    \clist_if_empty:NT \g_CDR_tags_clist {
      \PackageWarning
        { coder }
        { No~default~tags~provided. }
    }
  }
\CDR@Debug {\string \CDRCode_tags_setup:N\space\g_CDR_tags_clist}
%    \end{MacroCode}
% Setup the inheritance tree for the |\CDRTag_get:...| related functions.
%    \begin{MacroCode}
  \CDRTag_get_inherit:f {
    \g_CDR_tags_clist,
    __tags, __engine,
    __code, default.code, __pygments, default,
  }
}
%    \end{MacroCode}
% Now setup the engine options if any.
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRCode_engine_setup:N #1 {
\CDR@Debug{\string \CDRCode_engine_setup:N, \string #1}
  \CDR_local_inherit:n { __engine }
  \CDR_local_set_known:N #1
  \CDRTag_get:cNT { engine } \l_CDR_a_tl {
    \clist_put_left:Nx #1 { \CDRCode_options_use:V \l_CDR_a_tl }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_pyg_use:}
% \begin{syntax}
% \cs{CDRCode_pyg_use:}
% \end{syntax}
% Utility used by |\CDRCode|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDRCode_pyg_use: {
\CDR@Debug{\string\CDRCode_pyg_use:}
  \cs_set:Npn \CDR@StyleUseTag {
    \CDR@StyleUse { \CDRTag_get:c { style } }
    \cs_set_eq:NN \CDR@StyleUseTag \prg_do_nothing:
  }
  \directlua { CDR.Code:pyg_setup() }
  \CDRTag_get:cN {lang} \l_CDR_a_tl
  \directlua { CDR.Code:pyg_set_var('lang') }
  \CDRTag_get:cN {cache} \l_CDR_a_tl
  \directlua { CDR.Code:pyg_set_var('cache') }
  \CDRTag_get:cN {debug} \l_CDR_a_tl
  \directlua { CDR.Code:pyg_set_var('debug') }
  \CDRTag_get:cN {mathescape} \l_CDR_a_tl
  \directlua { CDR.Code:pyg_set_var('mathescape') }
  \CDRTag_get:cN {style} \l_CDR_a_tl
  \directlua { CDR.Code:pyg_set_var('style') }
  \tl_set:Nx \l_CDR_a_tl { \directlua {
    CDR.Code:synctex_sprint_tag()
  } }
  \directlua { CDR.Code:pyg_set_var('synctex_tag') }
  \tl_set:Nx \l_CDR_a_tl { \directlua {
    CDR.Code:synctex_sprint_line()
  } }
  \directlua { CDR.Code:pyg_set_var('synctex_line') }
  \CDR@StyleIfExist {
    \CDRTag_get:c { style }
  } { } {
    \directlua { CDR.Code:pyg_source(true) }
    \input { \l_CDR_pyg_sty_tl }
  }
  \CDR@StyleUseTag
  \directlua { CDR.Code:pyg_source(false, true) }        
  \CDR@CodeEngineApply {
    \CDRTag_if_truthy:cT { mbox } { \mbox } {
      \makeatletter
      \CDRCode_format:
      \CDRCode_hook_before:
      \CDR_whitespace_setup:
      \CDR_whitespace_define:
      \char_set_catcode_active:n { `\^^I }
      \char_set_catcode_active:n { `\    }
      \input { \l_CDR_pyg_tex_tl }\ignorespaces
      \CDRCode_hook_after:
      \makeatother
    }  
    \directlua { CDR.Code:pyg_teardown() }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_format:}
% \begin{syntax}
% \cs{CDRCode_format:}
% \end{syntax}
% Execute the format instructions before
% code is displayed.
% Syntax coloring with \pkg{pygments} takes precedence.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_format: {
  \frenchspacing
  \CDRTag_if_eq:cnF { font~size } { auto } {
    \CDRTag_get:c { font~size }
  }
  \CDRTag_if_eq:cnF { font~series } { auto } {
    \exp_args:Nx \fontseries {
      \CDRTag_get:c { font~series }
    }
  }
  \CDRTag_if_eq:cnF { font~family } { auto } {
    \exp_args:Nx \fontfamily {
      \CDRTag_get:c { font~family }
    }
  }
  \CDRTag_if_eq:cnF { font~shape } { auto } {
    \exp_args:Nx \fontshape {
      \CDRTag_get:c { font~shame }
    }
  }
  \selectfont
  \CDRTag_if_eq:cnF { format } { auto } {
    \CDRTag_get:c { format }
  }
  \CDRTag_if_eq:cnF { format* } { auto } {
    \CDRTag_get:c { format* }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_format:}
% \begin{syntax}
% \cs{CDRCode_format:}
% \end{syntax}
% Execute the format instructions before
% code is displayed.
% Syntax coloring with \pkg{pygments} takes precedence.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRCode_format: {
  \CDR_format:
  \CDRTag_get:cc { default.code } { format* }
  \CDR_if_pygments:F {
    \CDRTag_get:cc { __verbatim.code } { format* }
  }
  \CDRTag_get:c  { format* }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_hook_before:}
% \begin{syntax}
% \cs{CDRCode_hook_before:}
% \end{syntax}
% Execute the hook instructions just before didplay.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDRCode_hook_before: {
  \CDRTag_get:c  { hook~before }
  \CDRTag_get:cc { default } { hook~before* }
  \CDRTag_get:cc { default.code } { hook~before* }
  \CDR_if_pygments:F {
    \CDRTag_get:cc { __verbatim.code } { hook~before* }
  }
  \CDRTag_get:c  { hook~before* }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_hook_after:}
% \begin{syntax}
% \cs{CDRCode_hook_after:}
% \end{syntax}
% Execute the hook instructions just after display.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDRCode_hook_after: {
  \CDRTag_get:cc { default } { hook~after* }
  \CDRTag_get:cc { default.code } { hook~after* }
  \CDR_if_pygments:TF {
    \CDRTag_get:cc { pygments.code } { hook~after* }
  } {
    \CDRTag_get:cc { verbatim.code } { hook~after* }
  }
  \CDRTag_get:c  { hook~after* }
  \CDRTag_get:c  { hook~after }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRCode_vrb_use:}
% \begin{syntax}
% \cs{CDRCode_vrb_use:}
% \end{syntax}
% Utility used by |\CDRCode|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected_nopar:Npn \CDRCode_vrb_use: {
\CDR@Debug{\string\CDRCode_vrb_use:}
  \CDR@CodeEngineApply { \CDRTag_if_truthy:cT { mbox } { \mbox } {
    \exp_args:Nx
    \CDR@Setup {
      synctex_tag  = \directlua {
        CDR.Code:synctex_sprint_tag()
      },
      synctex_line = \directlua {
        CDR.Code:synctex_sprint_line()
      },
    }
    \CDRCode_format:
    \CDRCode_hook_before:
    \CDR_whitespace_setup:
    \CDR_whitespace_define:
    \directlua { CDR.Code:sprint_inline() }
    \CDRCode_hook_after:
  } }
}

%    \end{MacroCode}
%
% \section{\texttt{CDRBlock} environment}
%
% \begin{environment}{CDRBlock}
% \begin{syntax}
% \cs{begin}\{CDRBlock\}\Arg{key[=value] list} ... \cs{end}\{CDRBlock\}
% \end{syntax}
% \end{environment}
%
% \subsection{\texttt{__block} \pkg{l3keys} module}
% This module is used to parse the user interface of the |CDRBlock| environment.
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { __block } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed no~export{[=true$\vert$false]}]^^A
% to ignore this code chunk at export time.
%    \begin{MacroCode}[OK]
  no~export .code:n = \CDRTag_boolean_set:x { #1 },
  no~export .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed no export format=\metatt{format commands}]^^A
% a format appended to |format|, |tags format| and |numbers format|
% when |no export| is |true|..
% Initially empty.
%    \begin{MacroCode}[OK]
  no~export~format .code:n = \CDRTag_set:,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed dry numbers{[=true$\vert$false]}]^^A
% Initially |false|.
%    \begin{MacroCode}[OK]
  dry~numbers .code:n = \CDRTag_boolean_set:x { #1 },
  dry~numbers .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed test{[=true$\vert$false]}]^^A
% whether the chunk is a test,
%    \begin{MacroCode}[OK]
  test .code:n = \CDRTag_boolean_set:x { #1 },
  test .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed obey lines{[=true$\vert$false]}]^^A
% The displayed line numbers are exactly the physical ones.
%    \begin{MacroCode}[OK]
  obey~lines .code:n = \CDRTag_set:,
  obey~lines .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% initialize
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    no~export = false,
    no~export~format = ,
    dry~numbers  = false,
    test   = false,
    obey~lines = false,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%
% \subsection{Implementation}
%
% \subsubsection{Storage}
%
% \begin{variable}{__start, __step, __last, __mini, __maxi }
% For the line numbering, these are loop integer controls.
% The lines displayed are in the range $⟦$|__mini|;|__maxi|$⟧$\CDRCheckRed,
% relative to the \LaTeX\ source block where they are defined.
% \begin{description}
% \itemtt[__start] for the first index
% \itemtt[__step] for the step, defaults to 1
% \itemtt[__last] for the last index, included
% \end{description}
%    \begin{MacroCode}[OK]
\CDR_int_new:cn { __start } { 0 }
\CDR_int_new:cn { __step  } { 0 }
\CDR_int_new:cn { __last  } { 0 }
\CDR_int_new:cn { __mini  } { 0 }
\CDR_int_new:cn { __maxi  } { 0 }
%    \end{MacroCode}
% \end{variable}
%
% \subsubsection{Preparation}
%
% \begin{function}{\CDRBlock_preflight:n}
% \begin{syntax}
% \cs{CDRBlock_preflight:n} \Arg{CDR@Block kv list}
% \end{syntax}
% This is a prefligh hook intended for testing.
% The default implementation does nothing.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_preflight:n #1 { }
%    \end{MacroCode}
%
% \subsubsection{Main environment}
%
% \begin{function}{\CDR_whitespace_setup:}
% \begin{syntax}
% \cs{CDR_vrb_whitespace:}
% \end{syntax}
% Set the |\CDR@Space| and |\CDR@Tab| functions.
% These are the behavior of white space characters
% when they are active.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_whitespace_setup: {
\CDR@Debug{\string\CDR_whitespace_setup:}
  \CDRTag_if_truthy:cTF { show~spaces } {
    \cs_set:Npn \CDR@Space { { \textvisiblespace } }
  } {
    \cs_set:Npn \CDR@Space { \  }    
  }
  \tl_set:No \CDR@Tab {
    \prg_replicate:nn
      { \CDRTag_get:c { tab~size } }
      { \CDR@Space }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock@Read@Options}
% \begin{syntax}
% \cs{CDRBlock@Read@Options} \oarg{key[=value] options}
% \end{syntax}
% This is just an options catcher.
% It happens to allways be called with optional arguments.
% \end{function}
%    \begin{MacroCode}
\bool_new:N \l_CDR_before_eol_bool
\NewDocumentCommand \CDRBlock@Read@Options { O{} } {
\CDR@Debug{\string\CDRBlock@Read@Options}
  \clist_set:Nn \l_CDR_kv_clist { #1 }
  \directlua { CDR.Block:exit_options() }
  \bool_set_true:N \l_CDR_before_eol_bool
\CDR@Debug{\string\CDRBlock@Read@Options/SKIP}
  \cs_set:Npn \CDR: {
    \bool_if:NTF \l_CDR_before_eol_bool {
\CDR@Debug{After.%[
].BEFORE_EOL}
      \token_if_space:NTF \l_peek_token {
        \CDR@doafterspace {
          \peek_after:Nw \CDR:
        }
      } {
%    \end{MacroCode}
% This is a forbidden black character.
%    \begin{MacroCode}
        \PackageError
          { coder }
          { Only\space`\c_percent_str'\space
            after\space\string\begin{\@currenvir} [...]}
          { See\space\@currenvir\space documentation }
        \CDR_skip_and_enter_body:
      }
    } {
\CDR@Debug{AFTER_EOL/ENTER_BODY}
      \CDR_gobble_and_enter_body:n
    }
  }
  \peek_after:Nw \CDR:
}
\cs_set:Npn \CDR_enter_body: {
\CDR@Debug{WILL_ENTER_BODY}
  \directlua { CDR.Block:enter_body() }
  \ignorespaces
}
\cs_set:Npn \CDR_gobble_and_enter_body:n #1 {
  \CDR_enter_body:
}
\cs_set:Npn \CDR_skip_and_enter_body: {
\CDR@Debug{SKIP_LINE_TAIL}
  \bool_set_true:N \l_CDR_before_eol_bool
  \cs_set:Npn \CDR: {
    \bool_if:NTF \l_CDR_before_eol_bool {
\CDR@Debug{BEFORE_EOL}
      \token_if_space:NTF \l_peek_token {
        \CDR@doafterspace {
          \peek_after:Nw \CDR:
        }
      } {
%    \end{MacroCode}
% This is a forbidden black character.
%    \begin{MacroCode}
        \PackageError
          { coder }
          { Only\space`['\space or\space`\c_percent_str'\space%]
            after\space\string\begin{\@currenvir} }
          { See\space\@currenvir\space documentation }
      } {
\CDR@Debug{ENTER_BODY_AFTER_EOL}
      }
      \CDR_gobble_and_enter_body:n
    } {
      \CDR_enter_body:
    }
  }
  \peek_after:Nw \CDR:
}
%    \end{MacroCode}
%
% \subsubsection{Utilities}
%
% \begin{function}{\CDRBlock_count:}
% \begin{syntax}
% \cs{CDRBlock_count:}
% \end{syntax}
% Total number of lines of the current block environment.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_count: {
  \directlua { 
    CDR.Block:sprint_count();
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_line_raw:n, \CDRBlock_line_active:n, \CDRBlock_line_escape:n}
% \begin{syntax}
% \cs{CDRBlock_line_}\metatt{variant}:n \Arg{integer index}
% \end{syntax}
% Bridge to \CDRLua{} functions |Block.print_line_|\metatt{variant}.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_line_raw:n #1 {
  \directlua { 
    CDR.Block:print_line_raw(#1)
  }
}
\cs_new:Npn \CDRBlock_line_active:n #1 {
  \directlua { 
    CDR.Block:print_line_active(#1)
  }
}
\cs_new:Npn \CDRBlock_line_escape:n #1 {
  \directlua { 
    CDR.Block:print_line_escape(#1)
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP,pTF]{\CDRBlock_if_unknown:}
% \begin{syntax}
% \cs{CDRBlock_if_unknown:TF} \Arg{true code} \Arg{false code}
% \end{syntax}
% Assuming |\l_CDR_id_tl| has been properly set up,
% execute \metatt{true code} when a code or block
% is available, \metatt{false code} otherwise.
% \end{function}
%    \begin{MacroCode}
\CDR_set_conditional_alt:Nn \CDRBlock_if_unknown: {
  \exp_args:Nf \tl_if_empty_p:n { \directlua {
    CDR.Block:sprint_known()
  } }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_map_indexed_inline:nn}
% \begin{syntax}
% \cs{CDRBlock_map_indexed_inline:nn} \Arg{mode} \Arg{instructions}
% \end{syntax}
% Standard iterator over the lines.
% \metatt{mode} is one of |raw|, |active| and |escape|.
% The corresponding |\CDRBlock_line_|\metatt{mode}|:n|
% will be called.
% NB: you do not use 
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_map_indexed_inline:nn #1 #2 {
  \cs_set:Npn \@CDRBlock_map_indexed_inline:nn ##1 ##2 { #2 }
  \int_step_inline:nn { \CDRBlock_count: } {
    \exp_args:Nnx
    \@CDRBlock_map_indexed_inline:nn { ##1 } {
      \use:c{CDRBlock_line_#1:n} { ##1 }
    }
  }
}
%    \end{MacroCode}
%
% \begin{variable}{\l_CDR_vrb_tl}
% Storage for the mandatory argument of the |CDRBlockSave| environment.
% This data must be shared with the command that closes the environment.
% \end{variable}
%    \begin{MacroCode}
\tl_new:N \l_CDR_vrb_tl
%    \end{MacroCode}
%
% \begin{variable}{\l_CDR_vrb_seq}
% All the lines are scanned and recorded before they are processed.
% \end{variable}
%    \begin{MacroCode}
\seq_new:N \l_CDR_vrb_seq
%    \end{MacroCode}
% \begin{variable}{\l_CDR_vrb_prop}
% Extra fields.
% \end{variable}
%    \begin{MacroCode}
\prop_new:N \l_CDR_vrb_prop
%    \end{MacroCode}
%
%    \begin{MacroCode}
\NewDocumentEnvironment { CDRBlock } { } {
\CDR@Debug{\string\begin{CDRBlock}...\the\inputlineno }
  \CDRBlock_new:c { }
  \CDRBlock_save_begin:
} {
\CDR@Debug{\string\end{CDRBlock}...\the\inputlineno }
  \CDRBlock_save_end:
\CDR@Debug{CDRBlock...SETUP}
  \CDRBlock_setup:n { }
  \CDR_if_pygments:TF {
    \CDR@Debug{THIS\space IS\space PYGMENTS}
  } {
    \CDR@Debug{THIS\space IS\space NOT\space PYGMENTS}
  }
\CDR@Debug{CDRBlock...USE}
  \CDRBlock_use:
\CDR@Debug{CDRBlock...FREE}
  \CDRBlock_free:
\CDR@Debug{\string\end{CDRBlock}...DONE}
}
%    \end{MacroCode}
%%
% \begin{function}{\CDRBlock_save_begin:, \CDRBlock_save_end:}
% \begin{syntax}
% \cs{CDRBlock_save_begin:}
% \cs{CDRBlock_save_end:}
% \end{syntax}
% Helper to begin/end the |CDRBlock| and |CDRBlockSave| environments.
% These functions must be balanced.
% The purpose is to record the verbatim text in a sequence of lines,
% from the \pkg{lua} side.
% \end{function}
%    \begin{MacroCode}
\ExplSyntaxOff
\def\CDR@doafterspace#1 {#1}%
\ExplSyntaxOn
\cs_new:Npn \CDRBlock_save_begin: {
\CDR@Debug{ \string\CDRBlock_save_begin: }
  \directlua{ CDR.Block:save_begin() }
%    \end{MacroCode}
% Function to break the analysis, skip the end of the line,
% and execute |\CDR_read_options:n { }| on new line:
%    \begin{MacroCode}
  \bool_set_true:N \l_CDR_before_eol_bool
  \cs_set:Npn \CDR: {
    \bool_if:NTF \l_CDR_before_eol_bool {
\CDR@Debug{BEFORE_EOL}
      \token_if_space:NTF \l_peek_token {
        \CDR@doafterspace {
          \peek_after:Nw \CDR:
        }
      } {
        \token_if_eq_charcode:NNTF \l_peek_token [%]
        {
          \directlua { CDR.Block:enter_options() }
          \CDRBlock@Read@Options
        } {
%    \end{MacroCode}
% This is a forbidden black character.
%    \begin{MacroCode}
          \PackageError
            { coder }
            { Only\space`['\space or\space`\c_percent_str'\space%]
              after\space\string\begin{\@currenvir} }
            { See\space\@currenvir\space documentation }
          \CDR_skip_and_enter_body:
        }
      }
    } {
\CDR@Debug{AFTER_EOL}
\CDR@Debug{ENTER_BODY}
      \CDR_enter_body:
    }
  }
  \peek_after:Nw \CDR:
}
\cs_new:Npn \CDRBlock_id:c #1 {
  CDRBlock / #1 :
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_new:c,\CDRBlock_free:}
% \begin{syntax}
% \cs{CDRBlock_new:c} \Arg{identifier}
% \cs{CDRBlock_free:}
% \end{syntax}
% Prepare the current id, and feed |\l_CDR_id_tl|.
% Prepare a dedicated storage with attributes and methods
% as |CDR.Block| with the help of |Block_new| of \CDRLua.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_new:c #1 {
  \tl_set:Nx \l_CDR_id_short_tl { #1 }
  \tl_set:Nx \l_CDR_id_tl { \CDRBlock_id:c { #1 } }
  \directlua{ CDR:Block_new() }
\CDR@Debug{\string\l_CDR_id_short_tl=\l_CDR_id_short_tl}
\CDR@Debug{\string\l_CDR_id_tl=\l_CDR_id_tl}
}
\cs_new:Npn \CDRBlock_free: {
  \directlua{ CDR:Block_free() }
}
\cs_new:Npn \CDRBlock_save_end: {
\CDR@Debug{ \string\CDRBlock_save_end: }
  \directlua {
    CDR.Block:synctex_store( -1 - \CDRBlock_count: );
    CDR.Block:save_end();
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_interlinepenalty:}
% \begin{syntax}
% \cs{CDRBlock_interlinepenalty:}
% \end{syntax}
% When |same page| was chosen, appropriate penalty is used.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_interlinepenalty: {
  \CDRTag_if_truthy:cT { same~page } {
    \interlinepenalty\@M
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_format:}
% \begin{syntax}
% \cs{CDRBlock_format:}
% \end{syntax}
% Execute the format instructions before
% code is displayed.
% Syntax coloring with \pkg{pygments} takes precedence.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_format: {
  \CDRTag_get:c  { format }
  \CDRTag_get:cc { default } { format* }
  \CDRTag_get:cc { default.block } { format* }
  \CDR_if_pygments:F {
    \CDRTag_get:cc { __verbatim.block } { format* }
  }
  \CDRTag_get:c  { format* }
  \CDR_if_no_export:T {
    \CDRTag_get:c { no~export~format }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_hook_before:}
% \begin{syntax}
% \cs{CDRBlock_hook_before:}
% \end{syntax}
% Execute the hook instructions just before display.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDRBlock_hook_before: {
  \CDRTag_get:c  { hook~before }
  \CDRTag_get:cc { default } { hook~before* }
  \CDRTag_get:cc { default.block } { hook~before* }
  \CDR_if_pygments:F {
    \CDRTag_get:cc { __verbatim.block } { hook~before* }
  }
  \CDRTag_get:c  { hook~before* }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_hook_after:}
% \begin{syntax}
% \cs{CDRBlock_hook_after:}
% \end{syntax}
% Execute the hook instructions just after display.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDRBlock_hook_after: {
  \CDRTag_get:cc { default } { hook~after* }
  \CDRTag_get:cc { default.block } { hook~after* }
  \CDR_if_pygments:TF {
    \CDRTag_get:cc { pygments.block } { hook~after* }
  } {
    \CDRTag_get:cc { verbatim.block } { hook~after* }
  }
  \CDRTag_get:c  { hook~after* }
  \CDRTag_get:c  { hook~after }
}

\cs_new:Npn \CDRBlock_v_space: {
  \exp_last_unbraced:Nx
  \@topsepadd {
    \CDRTag_get:c { vspace }
  } \relax
}

\cs_new:Npn \CDRBlock_linewidth: {%
  \CDRTag_if_truthy:cT { list~indent } {
    \advance\leftmargin\@totalleftmargin
  }
  \exp_last_unbraced:NNf
  \advance\leftmargin {
    \CDRTag_get:c { left~margin* }
  } \relax
  \exp_last_unbraced:NNf
  \advance\leftmargin {
    \CDRTag_get:c { right~margin* }
  } \relax
  \linewidth\hsize
  \advance\linewidth-\leftmargin
  \advance\linewidth-\rightmargin
  \exp_last_unbraced:Nx
  \hfuzz {
    \CDRTag_get:c { hfuzz }
  } \relax
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_use:}
% \begin{syntax}
% \cs{CDRBlock_use:}
% \end{syntax}
% Once the code has been parsed and stored, it
% can be used.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlock_use: {
\CDR@Debug{\string\CDRBlock_use:, COUNT: \CDRBlock_count:}
%    \group_align_safe_begin:
    \CDRBlock_engine_begin:
\CDR@Debug{\string\CDRBlock_use:, STEP: 1}
%    \end{MacroCode}
% We export all the lines if requested except what was escaped to \LaTeX.
% As we use regular expressions, we must take care of characters with a special
% meaning. For that purpose we enclose between square brackets, this is why
% the carret |^| is not allowed, as it would negate the class.
%
% If |texcomment| has been set and the language is not |tex|,
% for each line, only the part before the first |%| will be exported.
%
% If |texcomment| has not been set, and |escape inside| has been provided with
% two characters, then what is inside the delimiter and the delimiters is not exported.
%
% Actually, no alternate possibility is offered.
% Line numbering is not delegated to \pkg{fancyvrb}, the main difficulty
% is to manage the |__mini| and |__maxi| values because they can be defined either
% explicitly by a number or implicitly by a regular expression.
% Let us start by the minimum index.
%    \begin{MacroCode}  
\CDR@Debug{\string\CDRBlock_use:, STEP: 2}
    \CDR_int_set:cn { __mini } { 1 }
\CDR@Debug{\string\CDRBlock_use:, STEP: 2a}
    \CDRTag_get:cNT { firstline } \l_CDR_a_tl {
\CDR@Debug{\string\CDRBlock_use:, STEP: 2b, \l_CDR_a_tl}
      \tl_if_empty:NF \l_CDR_a_tl {
\CDR@Debug{\string\CDRBlock_use:, STEP: 2c}
        \exp_args:NNV
        \regex_match:NnTF \c_CDR_alg_regex \l_CDR_a_tl {
\CDR@Debug{\string\CDRBlock_use:, STEP: 2d}
          \int_compare:nNnTF { \l_CDR_a_tl } > 0 {
\CDR@Debug{\string\CDRBlock_use:, STEP: 2e, \int_eval:n {\l_CDR_a_tl} }
            \CDR_int_set:cn { __mini } { \l_CDR_a_tl }
          } {
\CDR@Debug{\string\CDRBlock_use:, STEP: 2f}
            \CDR_int_set:cn { __mini } { \CDRBlock_count: + \l_CDR_a_tl }
          }
        } {
\CDR@Debug{\string\CDRBlock_use:, STEP: 2g}
          \regex_set:NV \l_CDR_regex \l_CDR_a_tl
\CDR@Debug{\string\CDRBlock_use:, STEP: 2h}
          \cs_set:Npn \CDR:nn ##1 ##2 {
            \regex_match:NnT \l_CDR_regex { ##2 } {
              \CDR_int_set:cn { __mini } { ##1 }
\CDR@Debug{\string\CDRBlock_use:, __mini: ##1}
              \cs_set:Npn \CDR:nn { \use_none:nn }
            }
          }
          \CDRBlock_map_indexed_inline:nn { raw } {
            \CDR:nn { ##1 } { ##2 }
          }
        }
      }
    }
%    \end{MacroCode}
% Let us go now for the maximum index.
%    \begin{MacroCode}
\CDR@Debug{\string\CDRBlock_use:, STEP: 3}
    \CDR_int_set:cn { __maxi } { \CDRBlock_count: }
\CDR@Debug{\string\CDRBlock_use:, STEP: 3a}
    \CDRTag_get:cNT { lastline } \l_CDR_a_tl {
\CDR@Debug{\string\CDRBlock_use:, STEP: 3b}
      \tl_if_empty:NF \l_CDR_a_tl {
\CDR@Debug{\string\CDRBlock_use:, STEP: 3c}
        \exp_args:NNV
        \regex_match:NnTF \c_CDR_alg_regex \l_CDR_a_tl {
\CDR@Debug{\string\CDRBlock_use:, STEP: 3d}
          \int_compare:nNnTF { \l_CDR_a_tl } > 0 {
            \CDR_int_set:cn { __maxi } { \l_CDR_a_tl }
\CDR@Debug{\string\CDRBlock_use:, STEP: 3d1,  \CDR_int_use:c {__maxi} }
          } {
            \CDR_int_set:cn { __maxi } { \CDRBlock_count: + \l_CDR_a_tl }
\CDR@Debug{\string\CDRBlock_use:, STEP: 3d2,  \CDR_int_use:c {__maxi} }
          }
        } {
\CDR@Debug{\string\CDRBlock_use:, STEP: 3e}
          \regex_set:NV \l_CDR_regex \l_CDR_a_tl
          \cs_set:Npn \CDR:nn ##1 ##2 {
            \regex_match:NnT \l_CDR_regex { ##2 } {
\CDR@Debug{\string\CDRBlock_use:, __maxi: ##1}
              \CDR_int_set:cn { __maxi } { ##1 }
              \cs_set:Npn \CDR:nn { \use_none:nn }
            }
          }
          \CDRBlock_map_indexed_inline:nn { raw } {
            \CDR:nn { ##1 } { ##2 }
          }
        }
      }
    }
%    \end{MacroCode}
% This is a patch to remove an extra space at the top.
%    \begin{MacroCode}
\CDR@Debug{\string\CDRBlock_use:\space 2}
    \CDRTag_if_truthy:cT { obey~lines } {
      \tl_set:Nn \l_CDR_obey_tl { __l }
    }
    \trivlist\item
    \group_begin:
    \CDRBlock_v_space:
    \CDRBlock_linewidth:
    \CDRBlock_interlinepenalty:
    \frenchspacing
    \CDRBlock_format:
    \CDRBlock_strut:
    \CDR_if_pygments:TF {
      \CDRBlock_pyg_use:
    } {
      \CDRBlock_vrb_use:
    }
    \vskip-\baselineskip
    \group_end:
    \endtrivlist
    \CDRBlock_teardown:
    \CDRBlock_engine_end:
%    \group_align_safe_end:
}
%    \end{MacroCode}
%
% \begin{variable}{\l_CDR_regex}
% Scratch variable to hold a regular expression.
% \end{variable}
%    \begin{MacroCode}
\regex_new:N \l_CDR_regex
%    \end{MacroCode}
%
%    \begin{MacroCode}
\cs_generate_variant:Nn \regex_set:Nn { Nx, NV }
%    \end{MacroCode}
% Read and catch the key value arguments,
% except the ones related to \pkg{fancyvrb}.
% Then build the dynamic keys matching
% \metatt{engine name}| engine options| for appropriate
% engine names.
%    \begin{MacroCode}
\cs_generate_variant:Nn \tl_to_str:n { V }
\cs_new_protected_nopar:Npn \CDRBlock_setup:n #1 {
\CDR@Debug { \string \CDRBlock_setup:n ,\tl_to_str:V \l_CDR_kv_clist }
  \prg_set_conditional:Nnn \CDR_if_block: { p, T, F, TF } {
    \prg_return_true:
  }
  \CDRTag_keys_set:nn { __block } { __initialize }
%    \end{MacroCode}
% Read and catch the key value arguments.
% Then build the dynamic keys matching
% \metatt{engine name}| engine options| for appropriate
% engine names.
%    \begin{MacroCode}
  \CDRBlockTags_setup:N \l_CDR_kv_clist
  \CDRBlock_engine_setup:N \l_CDR_kv_clist
  \CDR_local_inherit:n {
    __block, __pygments.block, default.block, default.block.vrb, __numbering,
    __fancyvrb.block,
    __pygments, default
  }
  \CDR_local_set_known:N \l_CDR_kv_clist
  \CDRTag_provide_from_kv:V \l_CDR_kv_clist
  \CDR_local_set_known:N \l_CDR_kv_clist
\CDR@Debug{\string \CDRBlock_setup:n.KV1:}
%    \end{MacroCode}
%    \begin{MacroCode}  
  \CDR_local_set_known:N \l_CDR_kv_clist
  \directlua {
    CDR.Block:pyg_setup('g_CDR_tags_clist')
  }
  \CDR_set_conditional:Nn \CDR_if_pygments:
    { \CDR_has_pygments_p: && \CDRTag_if_truthy_p:c { pygments } }
  \CDR_set_conditional:Nn \CDR_if_no_export:
    { \CDRTag_if_truthy_p:c { no~export } }
  \CDR_set_conditional:Nn \CDR_if_numbers_dry:
    { \CDRTag_if_truthy_p:c { dry~numbers } }
  \CDR_set_conditional:Nn \CDR_if_dry_tags:
    { \CDRTag_if_eq_p:cn { show~tags } { dry } }
  \CDR_set_conditional:Nn \CDR_if_number_on:
    { ! \CDRTag_if_eq_p:cn { numbers } { none } }
  \CDR_set_conditional:Nn \CDRBlockTags_if_already: {
    \CDRTag_if_truthy_p:c { only~top } &&
    \CDR_clist_if_eq_p:NN \g_CDR_tags_clist \g_CDR_last_tags_clist
  }
  \CDR_if_number_on:T {
    \clist_map_inline:Nn \g_CDR_tags_clist {
      \CDR_int_if_exist:cF { ##1 } {
        \CDR_int_new:cn { ##1 } { 1 }
      }
    }
  }
  \CDRTag_if_eq:cnF { ref~label } { } {
    \exp_args:Nx \label {
      \CDRTag_get:c { ref~label }
    }
  }
  \CDRTag_get:cN { escape~inside } \l_CDR_delimiters_tl
  \CDRTag_get:cN { gobble } \l_CDR_gobble_tl
  #1
}
%    \end{MacroCode}
% \begin{function}{\CDRBlock_teardown:}
% \begin{syntax}
% \cs{CDRBlock_teardown:}
% \end{syntax}
% Update the stored line numbers and send the |pyg_teardown| message to |CDR.Block|.
% In general, line numbers are updated such that people reading the whole document
% can have the impression that the numbering flow is continuous.
% If numbering was off or |dry|, no number update is performed.
% \end{function}
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRBlock_teardown: {
\CDR@Debug{ \string \CDRBlock_teardown:c }
  \bool_if:nT { \CDR_if_number_on_p: && !\CDR_if_numbers_dry_p: } {
\CDR@Debug{ \string \CDRBlock_teardown:c ~UPDATE}
    \CDRTag_if_eq:cnTF { first~number } { last } {
\CDR@Debug{ \string \CDRBlock_teardown:c~CONTINUOUS }
      \CDRLine_logical_set:n {
        \CDRBlock_count:
      }
      \clist_map_inline:Nn \g_CDR_tags_clist {
        \CDR_int_gadd:cc { ##1 } { __l }
        \CDR@Debug{NEXT~LINE~##1:~\CDR_int_use:c { ##1 } }
      }
    } {
\CDR@Debug{ \string \CDRBlock_teardown:c~NORMAL }
      \CDRTag_if_eq:cnTF { first~number } { auto } {
        \CDRLine_logical_set:n {
          1 + \CDRBlock_count:
        }
      } {
        \CDRLine_logical_set:n {
          \CDRTag_get:c { first~number } + \CDRBlock_count:
        }
      }
      \clist_map_inline:Nn \g_CDR_tags_clist {
        \CDR_int_gset:cc { ##1 } { __l }
        \CDR@Debug{NEXT~LINE~##1:~\CDR_int_use:c { ##1 } }
      }
    }
  }
  \directlua {
    CDR.Block:pyg_teardown()
  }
  \CDR_if_dry_tags:F {
    \clist_gset_eq:NN \g_CDR_last_tags_clist \g_CDR_tags_clist
  }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{CDRBlockSave} environment}
% This is used to save code for a later use by |\CDRBlockUse|.
%
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { CDRBlockSave } {
  gobble .choices:nn = {
    0,1,2,3,4,5,6,7,8,9
  } {
    \CDRTag_choices_set:
  },
}
%    \end{MacroCode}
%
% Now the |CDRBlockSave| environment.
%    \begin{MacroCode}
\NewDocumentEnvironment { CDRBlockSave } { m } {
\CDR@Debug{\@currenvir...\the\inputlineno }
  \CDRBlock_new:c { #1 }
  \CDRBlock_save_begin:
}{
  \CDRBlock_save_end:
\CDR@Debug{\the\inputlineno...\@currenvir}
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlockUse}
% \begin{syntax}
% \cs{CDRBlockUse} \oarg{key[=value] list} \marg{unique identifier}
% \end{syntax}
% \end{function}
%    \begin{MacroCode}
\NewDocumentCommand\CDRBlockUse{ O{} m } {
\CDR@Debug{\string\CDRBlockUse/#2}
  \CDRBlock_new:c { #2 }
  \CDRBlock_if_unknown:TF {
\CDR@Debug{ \directlua { CDR:Block_list_all() } }
    \PackageError
      { coder }
      { Unknown~block~identifier:~#2 }
      { See~CDRBlockUse~documentation. }
    \CDRBlock_free:
  } {
    \clist_set:Nn \l_CDR_kv_clist { #1 }
    \CDRBlock_setup:n {}
    \CDRBlock_use:
    \CDRBlock_free:
  }
}
%    \end{MacroCode}
%
%    \begin{MacroCode}[OK]
\keys_define:nn { CDRBlockExe } {
  makeatletter .choices:nn =
    { {}, true, false }
    { \directlua{
      CDR.Block:exe_makeatletter(\l_keys_choice_tl)
    } },
  makeatletter .default:n = true,
  ExplSyntaxOn .choices:nn =
    { {}, true, false }
    { \directlua{
      CDR.Block:exe_ExplSyntaxOn(\l_keys_choice_tl)
    } },
  ExplSyntaxOn .default:n = true,
}
%    \end{MacroCode}
% \begin{function}{\CDRBlockExe}
% \begin{syntax}
% \cs{CDRBlockExe} \oarg{makeatletter[=true$\vert$false]} \marg{block identifier}
% \end{syntax}
% \end{function}
%    \begin{MacroCode}
\NewDocumentCommand\CDRBlockExe{ O{} m } {
\CDR@Debug{\string\CDRBlockExe/#2}
  \CDRBlock_new:c { #2 }
  \CDRBlock_if_unknown:TF {
\CDR@Debug{ \directlua { CDR:Block_list_all() } }
    \PackageError
      { coder }
      { Unknown~block~identifier:~#2 }
      { See~\string\CDRBlockSave~documentation. }
  } {
    \directlua {
      CDR.Block:synctex_save();
      CDR.Block:exe_begin();
    }
    \exp_args:Nnx
    \keys_set:nn { CDRBlockExe } {
      \tl_if_empty:nTF { #1 }
        { makeatletter=false }
        { #1 }
    }
    \CDR@Setup {
      synctex_tag  = \directlua {
        CDR.Block:synctex_sprint_tag()
      },
      synctex_line = \directlua {
        CDR.Block:synctex_sprint_line()
      },
    }
\CDR@Debug{\string\l_CDR_id_short_tl=\l_CDR_id_short_tl}
\CDR@Debug{\string\l_CDR_id_tl=\l_CDR_id_tl}
    \directlua {
      CDR.Block:exe_end();
      CDR.Block:exeExplSyntaxOff()
      CDR.Block:exe_makeatother()
    }
%    \end{MacroCode}
% In a separate |\directlua| call for synchronization.
%    \begin{MacroCode}
    \directlua {
      CDR.Block:synctex_restore();
    }    
  }
  \CDRBlock_free:
\CDR@Debug{\string\CDRBlockExe/#2/DONE}
  \ignorespaces
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlockFree}
% \begin{syntax}
% \cs{CDRBlockFree} \marg{unique identifier}
% \end{syntax}
% Free the memory for this identifier. After that instruction,
% |\CDRBlockUse{|\marg{unique identifier}|}| is no longer available.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDRBlockFree #1 {
\CDR@Debug{\string\CDRBlockFree/#1}
  \cs_undefine:c { CDRBlockUse / #1 }
}
%    \end{MacroCode}
%
% \subsubsection{\pkg{pygments} only}
%
% Parts of |CDRBlock| environment specific to \pkg{pygments}.
%
% \begin{function}{\CDRBlock_pyg_use:}
% \begin{syntax}
% \cs{CDRBlock_pyg_use:}
% \end{syntax}
% The code chunk is stored line by line in |#1_seq|.
% Other field are in |#1_prop|.
% Use \pkg{pygments} to colorize the code,
% and use \pkg{fancyvrb} once more to display the colored code.
% \end{function}
%    \begin{MacroCode}
\cs_new_protected:Npn \CDRBlock_pyg_use: {
\CDR@Debug { \string\CDRBlock_pyg_use: }
  \directlua{
    CDR.Block:pyg_set {
      synctex_tag  = \directlua {
        CDR.Block:synctex_sprint_tag()
      },
      synctex_line = \directlua {
        CDR.Block:synctex_sprint_line()
      },
    }
  }
  \CDRTag_get:cN {lang} \l_CDR_a_tl
  \directlua { CDR.Block:pyg_set_var('lang') }
  \CDRTag_get:cN {cache} \l_CDR_a_tl
  \directlua { CDR.Block:pyg_set_var('cache') }
  \CDRTag_get:cN {debug} \l_CDR_a_tl
  \directlua { CDR.Block:pyg_set_var('debug') }
  \CDRTag_get:cN {mathescape} \l_CDR_a_tl
  \directlua { CDR.Block:pyg_set_var('mathescape') }
  \CDRTag_get:cN {style} \l_CDR_a_tl
  \directlua { CDR.Block:pyg_set_var('style') }
  \CDR@StyleIfExist { \l_CDR_a_tl } { 
\CDR@Debug { \string\CDRBlock_pyg_use: / Style:\l_CDR_a_tl=OK }  
  } {
    \directlua { CDR.Block:pyg_source(true) }
\CDR@Debug { \string\CDRBlock_pyg_use:\string\input{\l_CDR_pyg_sty_tl} }
    \input { \l_CDR_pyg_sty_tl }
  }
  \CDR@StyleUseTag
  \directlua { CDR.Block:pyg_source(false, 'l_CDR_id_tl') }
  \CDRBlock_pyg_whitespace:
  \CDRBlock_hook_before:
  \makeatletter
  \directlua { CDR.Block:synctex_save() }
  \input { \l_CDR_pyg_tex_tl }
  \directlua { CDR.Block:synctex_restore() }
  \makeatother
  \CDRBlock_hook_after:
\CDR@Debug{...~DONE}
}
\cs_new:Npn \CDRBlock_pyg_whitespace: {
\CDR@Debug{\string\CDRBlock_pyg_whitespace:}
  \CDRTag_if_truthy:cTF { show~spaces } {
    \cs_set:Npn \CDR@Space { { \textvisiblespace } }
  } {
    \cs_set:Npn \CDR@Space { \  }
  }
  \CDR_whitespace_define:
  \char_set_catcode_active:n { `\^^I }
  \char_set_catcode_active:n { `\    }
}

%    \end{MacroCode}
%
% \paragraph{Info}
%
%    \begin{MacroCode}
\cs_new:Npn \CDR@NumberFormat {
  \CDRTag_get:c { numbers~format }
}
\cs_new:Npn \CDR@NumberSep {
  \hspace{ \CDRTag_get:c { number~sep } }
}
\cs_new:Npn \CDR@TagsFormat {
  \CDRTag_get:c { tags~format }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_info_N_L:n, \CDR_info_N_R:n,\CDR_info_T_L:n, \CDR_info_T_R:n}
% \begin{syntax}
% \cs{CDR_info_N_L:n} \Arg{line number}
% \cs{CDR_info_T_L:n} \Arg{line number}
% \end{syntax}
% Core methods to display the left and right information. The |T| variants contain
% tags informations, they are only used on the first line eventually.
% The |N| variants are for line numbers only.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_info_N_L:n #1 {
  \hbox_overlap_left:n {
    \cs_set:Npn \baselinestretch { 1 }
    { \CDR@NumberFormat
      #1
    }
    \CDR@NumberSep
  }
}
\cs_new:Npn \CDR_info_T_L:n #1 {
  \hbox_overlap_left:n {
    \cs_set:Npn \baselinestretch { 1 }
    \CDR@NumberFormat
    \smash{
    \parbox[b]{\marginparwidth}{
      \raggedleft
        { \CDR@TagsFormat \g_CDR_tags_clist :} 
      }
      #1
    }
    \CDR@NumberSep
  }
}
\cs_new:Npn \CDR_info_N_R:n #1 {
  \hbox_overlap_right:n {
    \CDR@NumberSep
    \cs_set:Npn \baselinestretch { 1 }
    \CDR@NumberFormat
    #1
  }
}
\cs_new:Npn \CDR_info_T_R:n #1 {
  \hbox_overlap_right:n {
    \cs_set:Npn \baselinestretch { 1 }
    \CDR@NumberSep
    \CDR@NumberFormat
    \smash {
      \parbox[b]{\marginparwidth}{
        \raggedright
        #1:
        {\CDR@TagsFormat \space \g_CDR_tags_clist} 
      }
    }
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR_logical_alt:n}
% First line.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDR_logical_alt:n #1 {
  \CDRTag_get:c { number~
    \CDRLine_if_logical_main:nTF { #1 } { main } { other }
  } { #1 }
}
\cs_set:Npn \CDR_logical_alt: {
\CDR@Debug{\string\CDR_logical_alt:/\CDR_int_use:c { __l } }
  \CDR_logical_alt:n { \CDR_int_use:c { __l } }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRIfLR}
% \begin{syntax}
% \cs{CDRIfLR} \Arg{left commands} \Arg{right commands}
% \end{syntax}
% The |\cs{CDRIfLR}| allows to format the numbers differently on the left and on the right.
% \end{function}
%
% \begin{function}{\CDR_logical_main:, \CDR_logical_other:}
% \begin{syntax}
% \cs{CDR_logical_main:}
% \cs{CDR_logical_other:}
% \end{syntax}
% Respectively apply |\CDR_logical_main:| or |\CDR_logical_other:|
% on |\CDR_int_use:c { __l }|
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_logical_main: {
  \exp_args:Nnx
  \CDRTag_get:c {number~main} { \CDR_int_use:c { __l } }
}
\cs_new:Npn \CDR_logical_other: {
  \exp_args:Nnx
  \CDRTag_get:c {number~other} { \CDR_int_use:c { __l } }
}
%    \end{MacroCode}
%
% \paragraph{Boxes for lines}
% The first index is for the tags (|L|, |R|, |N|, |S|, |M|),
% the second for the numbers (|L|, |R|, |N|).
% |L| stands for left, |R| stands for right, |N| stands for nothing,
% |S| stands for same side as numbers, |M| stands for mirror side of numbers.
% 
% \begin{function}{\CDR_line_[LRNSM]_[LRN]:nn}
% \begin{syntax}
% \cs{CDR_line_[LRNSM]_[LRN]:nn} \Arg{line number} \Arg{line content}
% \end{syntax}
% These functions may be called by |\CDR@Line| on each block.
% |LRNSO| corresponds to the |show tags| options
% whereas |LRN| corresponds to the |numbers| options.
% These functions display the first line and setup the next one.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_line_N_N:n {
\CDR@Debug {\string\CDR_line_N_N:n}
  \CDR_line_box_N:n
}

\cs_new:Npn \CDR_line_L_N:n #1 {
\CDR@Debug {\string\CDR_line_L_N:n}
  \CDR_line_box:nnn { \CDR_info_T_L:n { } } { #1 } { }
}

\cs_new:Npn \CDR_line_R_N:n #1 {
\CDR@Debug {\string\CDR_line_R_N:n}
  \CDR_line_box:nnn { } { #1 } { \CDR_info_T_R:n { } }
}

\cs_new:Npn \CDR_line_S_N:n {
\CDR@Debug {\string\CDR_line_S_N:n}
  \CDR_line_box_N:n
}

\cs_new:Npn \CDR_line_M_N:n {
\CDR@Debug {\string\CDR_line_M_N:n}
  \CDR_line_box_N:n
}

\cs_new:Npn \CDR_line_N_L:n #1 {
\CDR@Debug {\string\CDR_line_N_L:n}
  \CDRLine_if_no_number:TF {
    \CDR_line_box:nnn {
      \CDR_info_N_L:n { \CDR_logical_main: }
    } { #1 } {}
  } {
    \CDRLine_if_logical_main:nTF { \CDR_int:c { __l } + 1 } {
      \CDR_line_box_L:n { #1 }
    } {
      \CDR_line_box:nnn {
        \CDR_info_N_L:n { \CDR_logical_main: }
      } { #1 } {}
    }
  }
}

\cs_new:Npn \CDR_line_L_L:n #1 {
\CDR@Debug {\string\CDR_line_L_L:n}
  \CDR_if_number_single:TF {
    \CDR_line_box:nnn {
      \CDR_info_T_L:n { \space \CDR_logical_main: }
    } { #1 } {}
  } {
    \CDRLine_if_no_number:TF {
      \cs_set:Npn \CDR@@Line {
        \cs_set:Npn \CDR@@Line {
          \CDR_line_box_L:nn { \CDR_info_N_L:n { \CDR_logical_other: } }
        }
        \CDR_line_box_L:nn { \CDR_info_N_L:n { \CDR_logical_main: } }
      }
    } {
      \cs_set:Npn \CDR@@Line {
        \CDR_line_box_L:nn { \CDR_info_N_L:n { \CDR_logical_alt: } }
      }
    }
    \CDR_line_box:nnn { \CDR_info_T_L:n { } } { #1 } { }
  }
}

\cs_new:Npn \CDR_line_R_R:n #1 {
\CDR@Debug {\string\CDR_line_R_R:n}
  \CDR_if_number_single:TF {
    \CDR_line_box:nnn { } { #1 } {
      \CDR_info_T_R:n { \CDR_logical_main: }
    }
  } {
    \CDRLine_if_no_number:TF {
      \cs_set:Npn \CDR@@Line {
        \cs_set:Npn \CDR@@Line {
          \CDR_line_box_R:nn { \CDR_info_N_R:n { \CDR_logical_other: } }
        }
        \CDR_line_box_R:nn { \CDR_info_N_R:n { \CDR_logical_main: } }
      }
    } {
      \cs_set:Npn \CDR@@Line {
        \CDR_line_box_R:nn { \CDR_info_N_R:n { \CDR_logical_alt: } }
      }
    }
    \CDR_line_box:nnn { } { #1 } { \CDR_info_T_R:n { } }
  }
}

\cs_new:Npn \CDR_line_R_L:n #1 {
\CDR@Debug {\string\CDR_line_R_L:n}
  \CDR_line_box:nnn {
    \CDRLine_if_no_number:TF {
      \CDR_info_N_L:n { \CDR_logical_main: }
    } {
      \CDRLine_if_logical_main:nTF { \CDR_int:c { __l } + 1 } {
        \CDR_info_N_L:n { \CDR_logical_alt: }
      } {
        \CDR_info_N_L:n { \CDR_logical_main: }
      }
    }
  } { #1 } {
    \CDR_info_T_R:n { }
  }
}

\cs_set_eq:NN \CDR_line_S_L:n \CDR_line_L_L:n
\cs_set_eq:NN \CDR_line_M_L:n \CDR_line_R_L:n

\cs_new:Npn \CDR_line_N_R:n #1 {
\CDR@Debug {\string\CDR_line_N_R:n}
  \CDRLine_if_no_number:TF {
    \CDR_line_box:nnn {} { #1 } {
      \CDR_info_N_R:n { \CDR_logical_main: }
    }
  } {
    \CDRLine_if_logical_main:nTF { \CDR_int:c { __l } + 1 } {
      \CDR_line_box_R:n { #1 }
    } {
      \CDR_line_box:nnn {} { #1 } {
        \CDR_info_N_R:n { \CDR_logical_main: }
      }
    }
  }
}

\cs_new:Npn \CDR_line_L_R:n #1 {
\CDR@Debug {\string\CDR_line_L_R:n}
  \CDR_line_box:nnn {
    \CDR_info_T_L:n { }
  } { #1 } {
    \CDRLine_if_no_number:TF {
      \CDR_info_N_R:n { \CDR_logical_main: }
    } {
      \CDRLine_if_logical_main:nTF { \CDR_int:c { __l } + 1 } {
        \CDR_info_N_R:n { \CDR_logical_alt: }
      } {
        \CDR_info_N_R:n { \CDR_logical_main: }
      }
    }
  }
}

\cs_set_eq:NN \CDR_line_S_R:n \CDR_line_R_R:n
\cs_set_eq:NN \CDR_line_M_R:n \CDR_line_L_R:n


\cs_new:Npn \CDR_line_box_N:n #1 {
\CDR@Debug {\string\CDR_line_box_N:n}
  \CDR_line_box:nnn { } { #1 } {}
}

\cs_new:Npn \CDR_line_box_L:n #1 {
\CDR@Debug {\string\CDR_line_box_L:n}
  \CDR_line_box:nnn {
    \CDR_info_N_L:n { \CDR_logical_alt: }
  } { #1 } {}
}

\cs_new:Npn \CDR_line_box_R:n #1 {
\CDR@Debug {\string\CDR_line_box_R:n}
  \CDR_line_box:nnn { } { #1 } { 
    \CDR_info_N_R:n { \CDR_logical_alt: }
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlock_strut:}
% The |\l_CDR_strut_tl| is used calibrate lines.
% \end{function}
%    \begin{MacroCode}
\tl_new:N \l_CDR_strut_tl
\cs_new:Npn \CDRBlock_strut: {
  \tl_set:Nn \l_CDR_strut_tl {%[
    \baselineskip]{0pt}{\baselineskip}
  }
  \CDRTag_if_eq:cnTF { line~depth } { auto } {
    \hbox_set:Nn \l_CDR_a_box { lp }
    \tl_put_left:Nx \l_CDR_strut_tl {
      -\fp_eval:n {
        \dim_ratio:nn
          { \box_dp:N \l_CDR_a_box }
          {\box_ht_plus_dp:N \l_CDR_a_box}
      }
    }
  } {
    \tl_put_left:Nx \l_CDR_strut_tl {
      -\CDRTag_get:c { line~depth }
    }
  }
  \tl_put_left:Nn \l_CDR_strut_tl {
    \rule[%]
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_line_box:nnn, \CDR_line_box_L:nn, \CDR_line_box_R:nn, \CDR_line_box:nn}
% \begin{syntax}
% \cs{CDR_line_box:nnn} \Arg{left info} \Arg{line content} \Arg{right info}
% \cs{CDR_line_box_L:nn} \Arg{left info} \Arg{line content}
% \cs{CDR_line_box_R:nn} \Arg{right info} \Arg{line content}
% \end{syntax}
% Returns an hbox with the given material.
% The first |LR| command is the reference, from which are derived the |L|, |R| and |N| commands.
% At run time the |\CDR_line_box:nn| is defined to call one of the above commands
% (with the same signature).
% \end{function}
%    \begin{MacroCode}
\tl_new:N \l_CDR_obey_tl
\tl_set:Nn \l_CDR_obey_tl { __p }
\box_new:N \l_CDR_a_box
\box_new:N \l_CDR_b_box
\exp_args_generate:n { nVV }
\cs_new:Npn \CDR_line_box:nnn #1 #2 #3 {
\CDR@Debug {\string\CDR_line_box:nnn/\tl_to_str:n{#1}/.../\tl_to_str:n{#3}/}
  \lua_now:e {
    CDR.Block:synctex_target_set( \CDR_int_use:c { \l_CDR_obey_tl } )
  }
\CDR@Debug {\string\CDR_line_box:nnn/ \tl_to_str:V \l_CDR_p_tl, \tl_to_str:V \l_CDR_l_tl/\tl_to_str:V\hsize }
  \hbox to \hsize {
    \tl_set:Nx \l_CDR_tl {
      \exp_args:NnVV
      \CDRTag_get:c
        { text~color } \l_CDR_p_tl \l_CDR_l_tl
    }
    \tl_if_empty:NF \l_CDR_tl {
      \color { \l_CDR_tl }
    }
    \kern \leftmargin
    {
      \let\CDRIfLR\use_i:nn
      #1
    }
    \hbox_set_to_wd:Nnn \l_CDR_a_box { \linewidth } {
      \exp_args:NnVV
      \CDRTag_get:c
        { line~prefix } \l_CDR_p_tl \l_CDR_l_tl
      \exp_args:NnVV
      \CDRTag_get:c
        { line~content } \l_CDR_p_tl \l_CDR_l_tl {
        \l_CDR_strut_tl
        #2
      }
      \exp_args:NnVV
      \CDRTag_get:c
        { line~postfix } \l_CDR_p_tl \l_CDR_l_tl
      \hss
      \exp_args:NnVV
      \CDRTag_get:c
        { line~suffix } \l_CDR_p_tl \l_CDR_l_tl
    }
    \tl_set:Nx \l_CDR_tl {
      \exp_args:NnVV
      \CDRTag_get:c { line~color } \l_CDR_p_tl \l_CDR_l_tl
    }
    \tl_if_empty:NTF \l_CDR_tl {
      \box_use_drop:N \l_CDR_a_box
    } {
      \hbox_set_to_wd:Nnn \l_CDR_b_box { \fboxsep } {
        \l_CDR_strut_tl
      }
      \fboxsep0pt
      \hbox_overlap_left:n {
        \colorbox {\l_CDR_tl} { \box_use:N \l_CDR_b_box }
      }
      {    
        \colorbox { \l_CDR_tl } { \box_use_drop:N \l_CDR_a_box }
      }
      \hbox_overlap_right:n {
        \colorbox {\l_CDR_tl} { \box_use_drop:N \l_CDR_b_box }
      }
    }
    {
\CDR@Debug{BEFORE\space\string\use_ii:nn\space\tl_to_str:n{#3}}
      \let\CDRIfLR\use_ii:nn
      #3
    }
  }
\CDR@Debug {\string\CDR_line_box:nnn...DONE }
  \ignorespaces
}
\cs_new:Npn \CDR_line_box_L:nn #1 #2 {
  \CDR_line_box:nnn { #1 } { #2 } {}
}
\cs_new:Npn \CDR_line_box_R:nn #1 #2 {
\CDR@Debug {\string\CDR_line_box_R:nn}
  \CDR_line_box:nnn { } {#2} { #1 }
}
\cs_new:Npn \CDR_line_box_N:nn #1 #2 {
\CDR@Debug {\string\CDR_line_box_N:nn}
  \CDR_line_box:nnn { } { #2 } {}
}
%    \end{MacroCode}
%
% \paragraph{Lines}
% The code is typeset one line after the other.
%
% \begin{function}{\CDR@Setup}
% \begin{syntax}
% \cs{CDR@Setup} \Arg{kv list}
% \end{syntax}
% This is the very first command called when typesetting.
% The purpose is to announce in advance the number of lines,
% and Sync\TeX\ related data as well.
% \end{function}
%    \begin{MacroCode}
\keys_define:nn { CDR@Setup } {
  last         .code:n = {
\CDR@Debug {\string\CDR@Setup/last=#1}
    \CDR_int_set:cn { __last } { #1 }
  },
  synctex_tag  .code:n = {
\CDR@Debug {\string\CDR@Setup/synctex_tag=#1}
    \directlua { CDR:synctex_tag_set( #1 ) }
  },
  synctex_line .code:n = {
\CDR@Debug {\string\CDR@Setup/synctex_line=#1}
    \directlua { CDR:synctex_line_set( #1 ) }
  },
}
\cs_new:Npn \CDR@Setup #1 {
\CDR@Debug {\string\CDR@Setup}
  \keys_set:nn { CDR@Setup } { #1 }
}
%    \end{MacroCode}
% \begin{function}{\CDR@Line}
% \begin{syntax}
% \cs{CDR@Line} \Arg{physical line index} \Arg{line content}
% \end{syntax}
% This is the very first command called when typesetting.
% Some setup are made for line numbering, in particular the |\CDRLine_if_visible_at_index:n...|
% family is set here.
% The line index refers to the lines in the source, what is displayed is a physical line number.
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR@Line #1 {
\CDR@Debug {\string\CDR@Line}
  \CDRLine_logical_set:n  { 1 }
  \CDRLine_physical_set:n { 1 }
  \CDR_if_number_on:TF {
%    \end{MacroCode}
% Set the first line number.
%    \begin{MacroCode}
    \CDR_int_set:cn { __start } { 1 }
    \CDRTag_if_eq:cnTF { first~number } { last } {
      \clist_map_inline:Nn \g_CDR_tags_clist {
        \clist_map_break:n {
          \CDR_int_set:cc { __start } { ##1 }
\CDR@Debug {START: ##1=\CDR_int_use:c { ##1 } }
        }
      }
    } {
      \CDRTag_if_eq:cnF { first~number } { auto } {
        \CDR_int_set:cn { __start } { \CDRTag_get:c { first~number } }
      }
    }
%    \end{MacroCode}
% Make |__last| absolute only after defining the |\CDR_if_number_single...| conditionals.
%    \begin{MacroCode}
    \CDR_set_conditional:Nn \CDR_if_number_single: {
      \CDR_int_compare_p:cNn { __mini } = { \CDR_int:c { __maxi } }
    }
\CDR@Debug{****** TEST: \CDR_if_number_single:TF { SINGLE } { MULTI } }
    \CDR_int_add:cn { __last } { \CDR_int:c { __start } - 1 }
    \CDR_int_set:cn { __step } { \CDRTag_get:c { step~number } }
\CDR@Debug {\string\CDR@Line/START/STEP/LAST=\CDR_int_use:c { __start }/\CDR_int_use:c { __step } /\CDR_int_use:c { __last }, #1}
%    \end{MacroCode}
% \begin{function}[EXP,pTF]{\CDRLine_if_visible_at_index:n}
% \begin{syntax}
% \cs{CDRLine_if_visible_at_index:nTF} \Arg{physical line number} \Arg{true code} \Arg{false code}
% \end{syntax}
% The \metatt{physical line number} is the first braced token after |\CDR@Line| in the
% various colored |...pyg.tex| files.
% Execute \metatt{true code} if the \metatt{physical line number} is visible, \metatt{false code} otherwise.
% The \metatt{physical line number} visibility depends on the value relative to first number and the step.
% This is relavant only when line numbering is enabled.
% Some setup are made for line numbering, in particular the |\CDRLine_if_visible_at_index:n...|.
% family is set here.
% \end{function}
%    \begin{MacroCode}
    \CDR_set_conditional_alt:Nn \CDRLine_if_visible_at_index:n {
      \CDRLine_if_number_visible_p:n { ##1 + \CDR_int:c { __start } - (#1) } 
    }
    \CDR_set_conditional_alt:Nn \CDRLine_if_number_visible:n {
      ! \CDR_int_compare_p:cNn { __last } < { ##1 } 
    }
    \CDR_int_compare:cNnTF { __step } < 2 {
      \CDR_int_set:cn { __step } { 1 }
      \CDR_set_conditional_alt:Nn \CDRLine_if_logical_main:n {
        \CDRLine_if_number_visible_p:n { ##1 }
      }
    } {
      \CDR_set_conditional_alt:Nn \CDRLine_if_logical_main:n {
        \int_compare_p:nNn {
          ( ##1 ) / \CDR_int:c { __step }  * \CDR_int:c { __step }
        } = { ##1 }
        && \CDRLine_if_number_visible_p:n { ##1 }
      }
    }
\CDR@Debug {\string\CDR@Line:STEP_1}
%    \end{MacroCode}
%    \begin{MacroCode}
    \CDR_set_conditional:Nn \CDRLine_if_no_number: {
      \CDR_int_compare_p:cNn { __start } > {
        \CDR_int:c { __last } / \CDR_int:c { __step } * \CDR_int:c { __step }
      }
    }
\CDR@Debug {\string\CDR@Line:STEP_2}
    \cs_set:Npn \CDR@Line ##1 {
\CDR@Debug {\string\CDR@Line(A), ##1, \CDR_int_use:c{__mini}, \CDR_int_use:c{__maxi}}
      \CDR_int_compare:cNnTF { __mini } > { ##1 } {
        \use_none:n
      } {
        \CDR_int_compare:cNnTF { __maxi } < { ##1 } {
          \use_none:n
        } {
          \CDRLine_physical_set:n { ##1 }
          \CDRLine_logical_set:n { ##1 + \CDR_int:c { __start } - (#1) }
          \tl_set:Nx \@currentlabel { \CDR_int_use:c { __l } }
          {
            \advance\interlinepenalty\widowpenalty
            \bool_if:nT {
              \CDR_int_compare_p:cNn { __l } = { \CDR_int:c { __mini } + 1 } ||
              \CDR_int_compare_p:cNn { __l } = { \CDR_int:c { __maxi } }
            } {
              \advance\interlinepenalty\clubpenalty
            }
            \penalty\interlinepenalty
          }
          \CDR@@Line
        }
      }
    }
 \CDR@Debug {\string\CDR@Line:STEP_3=(#1)}
   \CDRLine_logical_set:n { 1 + \CDR_int:c { __start } - (#1) }
 \CDR@Debug {\string\CDR@Line:STEP_4}
   \tl_set:Nx \@currentlabel { \CDR_int_use:c { __l } }
 \CDR@Debug {\string\CDR@Line:STEP_5}
  } {
\CDR@Debug {NUMBER~OFF}
    \cs_set:Npn \CDR@Line ##1 {
      \CDRLine_physical_set:n { ##1 }
      \CDRLine_logical_set:n { ##1 }
\CDR@Debug {\string\CDR@Line(B), ##1, \CDR_int_use:c{__mini}, \CDR_int_use:c{__maxi}}
      \CDR_int_compare:cNnTF { __mini } > { ##1 } {
\CDR@Debug{<MINI}
        \use_none:n
      } {
        \CDR_int_compare:cNnTF { __maxi } < { ##1 } {
\CDR@Debug{>MAXI}
          \use_none:n
        } {
\CDR@Debug{MINI<=...<=MAXI}
          \CDR@@Line
        }
      }
    }
  }
\CDR@Debug {\string\CDR@Line == STEP_S, \CDR_int_use:c {__step}, \CDR_int_use:c {__last} }
%    \end{MacroCode}
% Convenient method to branch whether one line number will be displayed or not,
% considering the stepping.
% When numbering is on, each code chunk must have at least one number.
% One solution is to allways display the first one but it is not satisfying
% when lines are numbered stepwise, moreover when the tags should be displayed.
%    \begin{MacroCode}
  \tl_clear:N \l_CDR_a_tl
  \CDRBlockTags_if_already:TF {
    \tl_put_right:Nn \l_CDR_a_tl { _N }
  } {
    \exp_args:Nx
    \str_case:nnF { \CDRTag_get:c { show~tags } } {
      { left  } { \tl_put_right:Nn \l_CDR_a_tl { _L } }
      { right } { \tl_put_right:Nn \l_CDR_a_tl { _R } }
      { none  } { \tl_put_right:Nn \l_CDR_a_tl { _N } }
      { dry   } { \tl_put_right:Nn \l_CDR_a_tl { _N } }
      { same  } { \tl_put_right:Nn \l_CDR_a_tl { _S } }
      { mirror  } { \tl_put_right:Nn \l_CDR_a_tl { _M } }
    } { \PackageError
          { coder }
          { Unknown~show~tags~options~:~ \CDRTag_get:c { show~tags } }
          { See~the~coder~manual }
    }
  }
%    \end{MacroCode}
% By default, the next line is displayed with no tag, but the real content may
% change to save space.
%    \begin{MacroCode}
  \exp_args:Nx
  \str_case:nnF { \CDRTag_get:c { numbers } } {
    { left  } {
      \tl_put_right:Nn \l_CDR_a_tl { _L }
      \cs_set:Npn \CDR@@Line { \CDR_line_box_L:n }
    }
    { right } {
      \tl_put_right:Nn \l_CDR_a_tl { _R }
      \cs_set:Npn \CDR@@Line { \CDR_line_box_R:n }
    }
    { none  } {
      \tl_put_right:Nn \l_CDR_a_tl { _N }
      \cs_set:Npn \CDR@@Line { \CDR_line_box_N:n }    
    }
  } { \PackageError
        { coder }
        { Unknown~numbers~options~:~ \CDRTag_get:c { numbers } }
        { See~the~coder~manual }
  }
\CDR@Debug {\string\CDR@Line == BRANCH:CDR_line \l_CDR_a_tl :n}
  \CDR_int_compare:cNnTF { __mini } > { 1 } {
    \use_none:n
  } {
    \CDR_int_compare:cNnTF { __maxi } < { 1 } {
      \use_none:n
    } {
      \use:c { CDR_line \l_CDR_a_tl :n }
     }
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR@Comment}
% \begin{syntax}
% \cs{CDR@Comment} \Arg{line comment}
% \end{syntax}
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR@Comment #1 {
  {
    \CDRTag_get_all:c { comment~format }
    \CDRTag_get:c { comment~command } { #1 }
  }
}
%    \end{MacroCode}
%
% \subsubsection{\pkg{fancyvrb} only}
%
% \pkg{pygments} is not used, fall back to \pkg{fancyvrb} features.
%
% \begin{function}{\CDRBlock_vrb_use:}
% \begin{syntax}
% \cs{CDRBlock_vrb_use:}
% \end{syntax}
% \end{function}
%    \begin{MacroCode}
\cs_new_protected:Npn \CDRBlock_vrb_use: {
\CDR@Debug {\string\CDRBlock_vrb_use:}
  \makeatletter
  \savecatcodetable \c_CDR_escape_cctab
  \CDR_whitespace_setup:
  \CDR_whitespace_define:
  \CDRBlock_hook_before:
  \cs_set:Npn \CDR:n ##1 {
    \tl_put_right:Nn \l_CDR_vrb_tl { { ##1 } }
  }
  \directlua {
    CDR.Block:synctex_save();
  }
  \tl_set:Nn \l_CDR_vrb_tl \CDR@Setup
  \exp_args:Nx \CDR:n {
    last = \CDRBlock_count:,
    synctex_tag  = \directlua {
      CDR.Block:synctex_sprint_tag()
    },
    synctex_line = \directlua {
      CDR.Block:synctex_sprint_line()
    },
  }
  \l_CDR_vrb_tl
  \directlua { CDR.Block:pre_setup () }
  %\def\CDR@Line##1##2{##1##2}
%      \directlua{
%        CDR.Block:sprint_line_ltx(##1);
%      }
%      \directlua{
%        tex.print([[\string\textbf{FAKE}]])
%      }
%      \directlua{
%        CDR.sprint_escape([[\CDR@Line{1}{]]);
%        CDR.sprint_string([[BEFORE\string\RIEN AFTER]]);
%        CDR.sprint_escape([[}]]);
%      }
  \exp_args:Nx \int_step_inline:nn { \CDRBlock_count: } {
\CDR@Debug {\string\CDRBlock_vrb_use:/line##1}
    \tl_set:Nf \l_CDR_vrb_tl {
      \directlua{
        CDR.Block:sprint_line_ltx(##1);
      }
    }
\CDR@Debug {\string\CDRBlock_vrb_use:/\tl_to_str:V \l_CDR_vrb_tl}
    \exp_args:NnV \CDR@Line { ##1 } \l_CDR_vrb_tl
  }
  \directlua {
    CDR.Block:synctex_restore();
  }
  \CDRBlock_hook_after:
\CDR@Debug {\string\CDRBlock_vrb_use:c...DONE}
}
%    \end{MacroCode}
%
% \subsubsection{Utilities}
%
% This is put aside for better clarity.
%
% \begin{function}{\CDR_if_middle_column:, \CDR_if_right_column:}
% \begin{syntax}
% \cs{CDR_if_middle_column:TF} \Arg{true code} \Arg{false code}
% \cs{CDR_if_right_column:TF} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when in the middle or right column,
% \metatt{false code} otherwise.
% \end{function}
%    \begin{MacroCode}
\prg_set_conditional:Nnn \CDR_if_middle_column: { p, T, F, TF } { \prg_return_false: }
\prg_set_conditional:Nnn \CDR_if_right_column:  { p, T, F, TF } { \prg_return_false: }
%    \end{MacroCode}
%
% Various utility conditionals: their purpose is to clarify the code.
% They are available in the |CDRBlock| environment only.
% \begin{function}[EXP,pTF]{\CDRBlockTags_if_visible:n}
% \begin{syntax}
% \cs{CDRBlockTags_if_visible:nTF} \Arg{left$\vert$right} \Arg{true code} \Arg{false code}
% \end{syntax}
% \end{function}
% Whether the tags should be visible, at the left or at the right.
%    \begin{MacroCode}
\prg_set_conditional:Nnn \CDRBlockTags_if_visible:n { p, T, F, TF } {
  \bool_if:nTF {
    ( \CDRTag_if_eq_p:cn { show~tags } { ##1 } ||
      \CDRTag_if_eq_p:cn { show~tags } { same } &&
      \CDRTag_if_eq_p:cn { numbers } { ##1 }
    ) && ! \CDRBlockTags_if_already_p:
  } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}{\CDRBlockTags_setup:N, \CDRBlock_engine_setup:N}
% Utility to setup the tags, the tag inheritance tree and the engine.
% When not provided explicitly with the |tags=...| user interface,
% a code chunk will have the list of tags stored in |\g_CDR_tags_clist|
% by last |\CDRBlockExport|, |\CDRSet| or |\CDRBlock| environment.
% At least one tag must be provided, either implicitly or explicitly.
% \end{function}
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRBlockTags_setup:N #1 {
\CDR@Debug{ \string \CDRBlockTags_setup:N, \string #1 }
  \CDR_local_inherit:n { __tags }
  \CDR_local_set_known:N #1
  \CDRTag_if_exist_here:ccT { __local } { tags } {
    \CDRTag_get:cN { tags } \l_CDR_clist
    \clist_if_empty:NF \l_CDR_clist {
      \clist_gset_eq:NN \g_CDR_tags_clist \l_CDR_clist
    }
  }
  \clist_if_empty:NT \g_CDR_tags_clist {
    \CDRTag_get:cN { defaulft~tags } \g_CDR_tags_clist {
      \PackageWarning
        { coder }
        { No~default~tags~provided. }
    }
  }
\CDR@Debug {\string \CDRBlockTags_setup:N\space\g_CDR_tags_clist}
%    \end{MacroCode}
% Setup the inheritance tree for the |\CDRTag_get:...| related functions.
%    \begin{MacroCode}
  \CDRTag_get_inherit:f {
    \g_CDR_tags_clist,
    __block, __tags, __engine, default.block,
    __fancyvrb.block, __numbering,
    __pygments, default,
  }
%    \end{MacroCode}
% For each \metatt{tag name}, create an \pkg{l3int} variable and initialize it to 1.
%    \begin{MacroCode}
  \clist_map_inline:Nn \g_CDR_tags_clist {
    \CDR_int_if_exist:cF { ##1 } {
      \CDR_int_new:cn { ##1 } { 1 }
    }
  }
}
%    \end{MacroCode}
% Now setup the engine options if any.
%    \begin{MacroCode}
\cs_new_protected_nopar:Npn \CDRBlock_engine_setup:N #1 {
\CDR@Debug{ \string \CDRBlock_engine_setup:N, \string #1 }
  \CDR_local_inherit:n { __engine }
  \CDR_local_set_known:N #1
  \CDRTag_get:cNT { engine } \l_CDR_a_tl {
    \clist_put_left:Nx #1 { \CDRBlock_options_use:V \l_CDR_a_tl }
  }
}
%    \end{MacroCode}
%
% \section{\string\CDRBlockImport}
% This is certainly the most interesting feature of this package: it allows to input source files and pretty print the comments.
% Quite everything is done on the \pkg{lua} side such that
% a little bit of \pkg{lua} is required but that remains
% extremely simple.
% \begin{function}{\CDRBlockImport}
% \begin{syntax}
% \cs{CDRBlockImport} \oarg{driver=\metatt{driver name}$\vert$\metatt{driver path}, \metatt{key}=\metatt{value}...} \Arg{source path}
% \end{syntax}
% Read and execute the lua driver,
% then typeset the source accordingly.
% Some builtin drivers are provided and used by their name
% which is in general the name of a programming language.
% The default driver is |raw|, which means that the file is input as is.
% The other \metatt{key}|=|\metatt{value} options are used to display the code within |CDRBlock| environment.
% \end{function}
% 
% \subsection{Builtin drivers}
% Here is the |raw| driver.
%    \begin{MacroCode}
%</sty>
%<*driver-raw>
-- This is the raw driver for the coder package
-- Display code as is
-- See \CDRBlockImport
-- put here whatever statement you need
-- return a table
return {}
%</driver-raw>
%<*sty>
%    \end{MacroCode}
% and here is the |lua| driver.
%    \begin{MacroCode}
%</sty>
%<*driver-c>
--[=[!latex:
\begin{coder}{Embedded documentation}
This is the driver for the C programming language
and other languages with the same syntax regarding long comments.
The \pkg{coder} package  will pretty print embedded documentation formatted in \LaTeX\ that is delimited by special
comment markers. The beginning of a documentation block is delimited by a full line starting with
\CDRCode[lang=lua]|^/%*+!latex:|.
The end of a documentation block is delimited by a full line starting with \CDRCode[lang=lua]|^%*+/|.
In both cases there must be at least one star.

The delimiting lines are removed and what is inside is typeset with \LaTeX{}.

See the \CDRCode|\CDRBlockImport| documentation for more information.
\end{coder}
]=]
-- put here whatever statement you need
-- return a table
local ans = {
  open = function (self, line)
    return line:match(
      [[^/%*+!latex:]]
    ) ~= nil
  end,
  close = function (self, line)
    return line:match(
      [[^%*+/]]
    ) ~= nil
  end,
  short = function (self, line)
    return line:match(
      [[^//+!latex:%s*(.*)]]
    )
  end,
}
texio.write_nl('============================ DRIVER_C')
texio.write_nl(tostring(ans.open))
texio.write_nl(tostring(ans.close))
return ans
%</driver-c>
%<*driver-py>
--[=[!latex:
\begin{coder}{Embedded documentation}
This is the driver for the python programming language.
The \pkg{coder} package  will pretty print embedded documentation formatted in \LaTeX\ that is delimited by special
comment markers. The beginning of a documentation block is delimited by a full line starting with
\CDRCode[lang=lua]|^('''|""")!latex:|.
The end of a documentation block is delimited by a full line
starting with the very same combination of quotes and spaces.

The delimiting lines are removed and what is inside is typeset with \LaTeX{}.

See the \CDRCode|\CDRBlockImport| documentation for more information.
\end{coder}
]=]
-- put here whatever statement you need
-- return a table
return {
  open = function (self, line)
    local quotes = line:match(
      [[^(%s*""")!latex:]]
    )
    if quotes then
      local pattern = '^'..quotes
      self.close = function (this, l)
        return l:match(pattern) ~= nil
      end
      return true
    end
    quotes = line:match(
      [[^(%s*''')!latex:]]
    )
    if quotes then
      local pattern = '^'..quotes
      self.close = function (this, l)
        return l:match(pattern) ~= nil
      end
      return true
    end
  end,
}
%</driver-py>
%<*driver-lua>
--[=[!latex:
\begin{coder}{Embedded documentation}
This is the driver for the lua programming language.
The \pkg{coder} package  will pretty print embedded documentation formatted in \LaTeX\ that is delimited by special
comment markers. The beginning of a documentation block is delimited by a full line starting with
\CDRCode[lang=lua]|^--[(=*)[!latex:|.
The end of a documentation block is delimited by the next full line starting with
\CDRCode[lang=lua,escape~inside=<>]|--](<\CDRMeta{equals}>)]|
where \CDRMeta*{equals} represents the previously capture group.

The delimiting lines are removed and what is inside is typeset with \LaTeX{}.

See the \CDRCode|\CDRBlockImport| documentation for more information.
\end{coder}
--]=]
-- put here whatever statement you need
-- return a table
return {
  open = function (self, line)
print('driver-lua open?', line)
    local equals = line:match(
      '^%-%-%[(=*)%[!latex:'--]]
    )
    if equals then--[[
self.debug_msg('driver-lua open!', equals)
      local pattern = '^%-%-%]'..equals..'%]'
      local close = self.close
      self.close = function (this, l)
self.debug_msg('driver-lua close?', l)
        if l:match(pattern) then
self.debug_msg('driver-lua close!')
          self.close = close
          return true
        end
      end
      return true
    end
  end,
  debug_msg = f_noop,
}
%</driver-lua>
%<*sty>
%    \end{MacroCode}
%
% \subsection{Options}
% The options will inherit the |__tags| \pkg{l3keys} module.
%    \begin{MacroCode}[OK]
\CDRTag_keys_define:nn { CDRBlockImport } {
%    \end{MacroCode}
% \begin{description}
%
% \itemtt[\CDRCheckGreen driver=\metatt{driver name}$\vert$\metatt{driver path}]^^A
% When the driver has a path extension, this is the path
% to a driver, otherwise this is a builtin driver name.
% Some builtin drivers are provided
% and generally named after a programming language.
% Initially |raw|, which means that the file is input as one uncommented code snippet.
% Let's hope that no language will ever be named |raw|.
%    \begin{MacroCode}[OK]
  driver .code:n = \CDRTag_set:,
  driver .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen first line=\metatt{integer}]^^A
% The lines up to \metatt{integer}-1 are hidden.
% If the value is not positive, then the total amount
% of lines is added.
% The initial value is 1: no header line is hidden.
%    \begin{MacroCode}[OK]
  first~line .code:n = \CDRTag_set:,
  first~line .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen last line=\metatt{integer}]^^A
% The lines from \metatt{integer}+1 are hidden.
% The initial value is the total amount of lines:
% no trailer line is hidden.
% If the value is not positive, then the total amount
% of lines is added.
% The initial value is 0: no trailer line is hidden.
%    \begin{MacroCode}[OK]
  last~line .code:n = \CDRTag_set:,
  last~line .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed show code{[=true$\vert$false]}]^^A
% whether code should be displayed.
% Initially |true|.
%    \begin{MacroCode}[OK]
  show~code .code:n = \CDRTag_boolean_set:x { #1 },
  show~code .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed show doc{[=true$\vert$false]}]^^A
% whether doc should be displayed.
% Initially |true|.
%    \begin{MacroCode}[OK]
  show~doc .code:n = \CDRTag_boolean_set:x { #1 },
  show~doc .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    first~line = 1,
    last~line  = 0,
    driver     = raw,
    show~code  = true,
    show~doc   = true,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\AtBeginDocument{
  \CDRTag_keys_set:nn { CDRBlockImport } { __initialize }
}
%    \end{MacroCode}
%
% \subsection{Implementation}
%
%    \begin{MacroCode}
\tl_new:N \l_CDR_input_tl
\tl_new:N \l_CDR_driver_tl
\NewDocumentCommand\CDRBlockImport { O{} m } {
\CDR@Debug{\string\CDRBlockImport/#1/#2}
  \group_begin:
  \cs_set:Npn \SyncTeXLC:##1:##2: {
    \directlua{CDR.Block:synctex_target_set(##1, ##2) }
  }
  \CDRBlock_new:c {}
  \tl_set:Nn \l_CDR_input_tl { #2 }
  \CDR_local_inherit:n { CDRBlockImport }
  \CDR_local_set_known:nN { #1 } \l_CDR_kv_clist
\CDR@Debug{\string\CDRBlockImport: STEP1}
  \directlua {
    CDR.Block:synctex_tag_catch('\luaescapestring{#2}')
  }
\CDR@Debug{\string\CDRBlockImport: STEP2}
  \CDRTag_get_inherit:n { CDRBlockImport }
  \CDRTag_get:cN { driver } \l_CDR_driver_tl
\CDR@Debug{\string\CDRBlockImport: STEP3}
  \directlua { CDR.Block:import_begin() }
  \tl_if_empty:NT \l_CDR_status_tl {
    \CDRTag_get:cN { show~code } \l_CDR_a_tl
    \directlua {
      CDR.Block:import_set_boolean('show_code')
    }
    \CDRTag_get:cN { show~doc } \l_CDR_a_tl
    \directlua {
      CDR.Block:import_set_boolean('show_doc')
    }
    \CDRTag_get:cN { first~line } \l_CDR_a_tl
    \directlua {
      CDR.Block:import_set_integer('first_line')
    }
    \CDRTag_get:cN { last~line } \l_CDR_a_tl
    \directlua {
      CDR.Block:import_set_integer('last_line')
    }
\CDR@Debug{\string\CDRBlockImport\string\input{#2}...}
    \input { #2 }
\CDR@Debug{\string\CDRBlockImport\string\input{#2}..........................DONE}
  }
  \CDRBlock_free:
  \group_end:
  %\@doendpe\global\@ignorefalse\ignorespaces
}
%    \end{MacroCode}
%
%    \begin{MacroCode}
\ExplSyntaxOff
%    \end{MacroCode}  
%
% Input a configuration file named \texttt{\jobname.cfg}, if any.
%    \begin{MacroCode}
\AtBeginDocument{
  \InputIfFileExists{coder.cfg}{}{}
}
%</sty>
%    \end{MacroCode}
% \end{implementation}
%\Finale
%
% % ^^A \PrintIndex
