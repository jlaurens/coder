% \iffalse meta-comment
% !TEX program  = lualatex
% !TEX encoding  = utf8
%<*internal>
\iffalse
%</internal>
%<*readme>
----------------------------------------------------------------
coder --- description text
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

Some text about the package: probably the same as the abstract.
%</readme>
%<*internal>
\fi
\def\nameofplainTeX{plain}
\ifx\fmtname\nameofplainTeX\else
  \expandafter\begingroup
\fi
%</internal>
%<*install>
\input docstrip.tex
\keepsilent
\askforoverwritefalse
\def\MetaPrefix{}
\declarepreamble\PreambleRaw
----------------------------------------------------------------
\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/coder
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt
----------------------------------------------------------------

\endpreamble
\def\MetaPrefix{--}
\declarepreamble\PreambleLua

\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/coder
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt

\endpreamble
{
\catcode`\#=11
\global\def\MetaPrefix{#}
}
\declarepreamble\PreamblePy

\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
url: https:github.com/jlaurens/coder
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later
See http://www.latex-project.org/lppl.txt

\endpreamble

\edef\PreamblePy {%
\MetaPrefix!/usr/bin/env python3^^J\MetaPrefix\space -*- coding: utf-8 -*-^^J\PreamblePy
}

\def\MetaPrefix{\DoubleperCent}
\declarepreamble\PreambleSty
\jobname --- code inlined in a LuaLaTeX document.
version: \fileversion
date: \filedate
E-mail: jerome.laurens@u-bourgogne.fr
Released under the LaTeX Project Public License v1.3c or later

Copyright (C) 2022 by Jérôme LAURENS <jerome.laurens@u-bourgogne.fr>

This work may be distributed and/or modified under the
conditions of the LaTeX Project Public License (LPPL), either
version 1.3c of this license or (at your option) any later
version.  The latest version of this license is in the file:

http://www.latex-project.org/lppl.txt

This work is "maintained" (as per LPPL maintenance status) by
Jérôme LAURENS.

This work consists of the file  \jobname.dtx
and the derived files           \jobname.ins,
                                \jobname.pdf,
                                \jobname-util.lua,
                                \jobname-tool.py and
                                \jobname.sty.

\endpreamble
\nopostamble
\usedir{tex/latex/coder}
\usepreamble\PreambleSty
\def\MetaPrefix{\DoubleperCent}
\generate{
  \file{\jobname.sty}{\from{\jobname.dtx}{sty}}
}
\usepreamble\PreambleLua
\def\MetaPrefix{--}
\usedir{scripts/coder}
\generate{
  \file{\jobname-util.x.lua}{\from{\jobname.dtx}{lua}}
}
\generate{
  \file{\jobname-util.lua}{\from{\jobname.dtx}{lua}}
}
\usepreamble\PreamblePy
{
\catcode`\#=11
\global\def\MetaPrefix{#}
}
\usedir{scripts/coder}
\generate{
  \file{\jobname-tool.x.py}{\from{\jobname.dtx}{py}}
}
\generate{
  \file{\jobname-tool.py}{\from{\jobname.dtx}{py}}
}
\nopreamble\nopostamble
\usedir{doc/latex/coder}
\generate{
  \file{README.md}{\from{\jobname.dtx}{readme}}
}
%</install>
%<install>\endbatchfile
%<*internal>
\usedir{source/latex/coder}
\generate{
  \file{\jobname.ins}{\from{\jobname.dtx}{install}}
}
\ifx\fmtname\nameofplainTeX
  \expandafter\endbatchfile
\else
  \expandafter\endgroup
\fi
%</internal>
%<*sty>
\RequirePackage{fancyvrb}
\RequirePackage{color}
\RequirePackage{emoji}
\RequirePackage{ifthen}
%\RequirePackage[font=small,format=plain,labelfont=bf,up,textfont=it,up]{caption}
%\RequirePackage{caption}
\RequirePackage[framemethod=tikz]{mdframed}

%\DeclareCaptionType[within=chapter]{pygcode}[Listagem][Lista de listagens]
%\DeclareCaptionType{pygcode}[Listagem][Lista de listagens]
%\captionsetup[pygcode]{position=top}

\RequirePackage{luacode, needspace, xcolor, verbatim}
\AddToHook { begindocument / before } {
  \RequirePackage{datetime2}
}
%</sty>
%<*driver,sty>
\def\CDRFileDate{2022/02/07}
\def\CDRFileVersion{2022/02/07}
%</driver,sty>
%<*sty>
\ProvidesExplPackage{coder}
  {\CDRFileDate}
  {\CDRFileVersion}
  {code inlined in documents}

\NeedsTeXFormat{LaTeX2e}

\msg_new:nnn { coder } { :n } { #1 }
\cs_if_exist:NTF\IfFormatAtLeastTF {
  \IfFormatAtLeastTF{2021/06/01} {} {
    \msg_fatal:nnn { coder } { :n } { Please~update~LaTeX.~Emergency~stop }
  }
} {
  \msg_fatal:nnn { coder } { :n } { Please~update~LaTeX.~Emergency~stop }
}
\ExplSyntaxOff
\directlua{CDR = require("coder-util")}
\ExplSyntaxOn
%</sty>
%<*driver>
\ExplSyntaxOff
\documentclass{l3doc}
\RequirePackage{fancyvrb}
\RequirePackage{emoji}
\EnableCrossrefs
\CodelineIndex
\RecordChanges
\newcommand{\lua} {\pkg{lua}}
\newcommand{\CDRSty}{\pkg{\jobname.sty}}
\newcommand{\CDRLua}{\pkg{\jobname-util.lua}}
\newcommand{\CDRPy} {\pkg{\jobname-tool.py}}
\newcommand{\metatt} [1] {\texttt{\meta{#1}}}
\ExplSyntaxOn
\NewDocumentCommand\CDRCheckGreen{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{check-mark-button}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckRed{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{stop-sign}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckOrange{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{white-question-mark}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckProhibited{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{prohibited}}
  \ttfamily\hspace{#1}\vphantom{.}
}}
\NewDocumentCommand\CDRCheckInternal{O{2ex}}{\leavevmode\hbox_overlap_left:n{
  \raisebox{-0.1\baselineskip}{\emoji{gear}}
  \ttfamily\hspace{#1}\vphantom{.}
}}

\makeatletter
\@addtoreset{FancyVerbLine}{part}
\ExplSyntaxOn
\define@booleankey{FV}{OK}
  {\def\DCR@possibly@in@progress{\color{gray}}}
  {\def\DCR@possibly@in@progress{\color{red}}}
\define@booleankey{FV}{construction}
  {\def\DCR@possibly@in@progress{\color{red}}}
  {\def\DCR@possibly@in@progress{\color{gray}}}
\fvset{construction}
\def\FVB@MacroCode{
  \@bsphack
  \FV@VerbatimBegin
  \renewcommand{\theFancyVerbLine}{{
    \DCR@possibly@in@progress
    \scriptsize
    \arabic{FancyVerbLine}
  }}
  \FV@Scan
}
\def\FVE@MacroCode{
  \FV@VerbatimEnd
  \@esphack
}
\ExplSyntaxOff
\DefineVerbatimEnvironment{MacroCode}{MacroCode}{
  numbers=left,
  resetmargins=true,
  firstnumber=last,
  gobble=0,
  numbersep=1ex,
  fontsize=\small,
}
\makeatother


\makeatletter
\newcommand{\CDRPygVerbatim} {CDR@Pyg@Verbatim}
\makeatother
\NewDocumentCommand \itemtt { o }{^^A
  \IfNoValueTF { #1 } {
    \item
  } {
    \item[\ttfamily#1]
  }
}
\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
%\title{^^A
%  \textsf{\jobname} --- code inlined in a \LaTeX\ document\thanks{^^A
%    This file describes version \CDRFileVersion, last revised \CDRFileDate.^^A
%  }^^A
%}
%\author{^^A
%  Jérôme LAURENS\thanks{E-mail: jerome.laurens@u-bourgogne.fr}^^A
%}
%\date{Released \CDRFileDate}
%
%\maketitle
%
% \begin{documentation}
%
%\changes{v1.0a}{2022/01/20}{First public release}
%
% \begin{abstract}
% Usually, documentation is put inside the code,
% \pkg{\jobname} allows to work the other way round
% by putting code inside the documentation.
% This is particularly interesting when different code files share some logic
% and should be documented all at once.
%
% The file \url{coder-manual.pdf} gives different examples. Here is the implementation of the package.
%
% This \LaTeX{} package requires \LuaTeX{} and may use syntax coloring based on \pkg{pygments}.
% \end{abstract}
%
% \section{Package dependencies}
% \pkg{luacode}, \pkg{datetime2}, \pkg{xcolor}, \pkg{fancyvrb} and dependencies of these packages.
% \section{Similar technologies}
% \begin{description}
% \item The \pkg{docstrip} utility offers similar features,
% it is somehow more powerful than \pkg{\jobname} at the cost of
% more technicality and less practicality,
% \item The \pkg{ydoc.cls} and \pkg{skdoc.cls} are
% full document classes with similar features but
% many more that are unrelated.
% \pkg{\jobname} focuses on code inlining and interfaces very well with \pkg{pygments}
% for a smart and efficient syntax hilighting.
% \item The \pkg{pygmentex} and \pkg{minted} packages were somehow a source of inspiration.
% \end{description}
%
% \section{Known bugs and limitations}
% \begin{itemize}
% \item
% \pkg{\jobname} does not play well with \pkg{docstrip}.
% \end{itemize}
%
% \end{documentation}
% 
% \begin{implementation}
%
% \section{Namespace and conventions}
% \LaTeX{} identifiers related to \pkg{\jobname} start with |CDR|,
% including both commands and evironments.
% \pkg{expl3} identifiers also start with |CDR|, after and eventual leading |c_|, |l_| or |g_|.
% \pkg{l3keys} module path's first component is either |CDR|
% or starts with |CDR@|.
%
% \lua{} objects (functions and variables) are collected
% in the \texttt{CDR} table automatically created
% while loading \CDRLua{} from \CDRSty{}.
%
% The |c| argument specifier is used here in a more general acception.
% Normaly , it means that the argument is turned to a command sequence name.
% Here, it means that the argument is part of something bigger
% which is turned to a command sequence name.
% As such, there is no need to explictly expand such an argument.
%
% \section{Presentation}
% \pkg{\jobname} is a triptych of three complementary components
% \begin{enumerate}
% \item \CDRSty, on the \LaTeX{} side,
% \item \CDRLua, to store data and call \CDRPy,
% \item \CDRPy, to color code with the help of \pkg{pygments}.
% \end{enumerate}
% \CDRSty{} mainly declares the \cs{CDRCode} command and the |CDRBlock| environment.
% The former allows to insert code chunks as running text whereas the latter allows
% to instert code snippets as blocks.
% Moreover, block code chunks can be exported to files, once declared with \cs{CDRExport} command.
% The \cs{CDRSet} command is used to set various parameters,
% including display engines declared with either \cs{CDRCodeEngineNew} or \cs{CDRBlockEngineNew}.
%
% \subsection{Code flow}
% The normal code flow is
% \begin{enumerate}
% \item from \CDRSty{}, \LaTeX{} parses a code snippet as |\CDRCode| argument
% of |CDRBlock| environment body, somehow stores it,
% and calls either |CDR:hilight_code| or |CDR:hilight_block|,
% \item \CDRLua{} reads the content of some command, and stores it in a |json| file,
% together with informations to process this code snippet properly,
% \item \CDRPy{} is asked by \CDRLua{} to read the |json| file and eventually uses \pkg{pygments} to translate
% the code snippet into dedicated \LaTeX{} coloring commands. These are stored in a |*.pyg.tex| file
% named after the md5 digest of the original code chunck,
% a |*.pyg.sty| \LaTeX{} style file is recorded as well.
% On return, \CDRPy{} gives to \CDRLua{} some \LaTeX{} instructions to both input the |*.pyg.sty| and
% the |*.pyg.tex| file, these are finally executed and the code is displayed with colors.
% \CDRPy{} is also partially responsible of code line numbering.
% \end{enumerate}
%
% The package \CDRSty{} only exchanges with \CDRLua{} using |\directlua| and |tex.print|.
% \CDRPy{} in turn only exchanges with \CDRLua{}:
% we put in \CDRPy{} as few \LaTeX{} logic as possible.
% It receives instructions from \CDRSty{} as command line arguments,
% \LaTeX{} options, \pkg{pygments} options and \pkg{fancyvrb} options.
%
% \subsection{File exports}
% \begin{enumerate}
% \item
% The \cs{CDRExport} command declares a file path, a list of tags and other
% usefull information like a coding language. These data are saved as export records
% by \CDRLua.
% \item
% When some |tags={...}| have been given to the |CDRBlock| environment,
% the \CDRLua{} records the corresponding code chunk and its associate tags for
% later save. 
% \item
% Once the typesetting process is complete, \CDRLua{}'s |CDR_export_...| methods
% are called to save all the files externally. For each export record,
% \CDRLua{} collects all the chunks with the same tag and save them
% at the proper location.
% \end{enumerate}
%
% \subsection{Display engine}
% The display management is partly delegated to other packages.
% \CDRSty{} provides default engines for running code and code blocks,
% and new engines can be declared with \cs{CDRCodeEngineNew}
% and \cs{CDRBlockEngineNew}.
% 
% \subsection{\LaTeX{} user interface}
% The first required argument of both commands and environment
% is a \metatt{key[=value] controls} list managed by \pkg{l3keys}.
% Each command requires its own \pkg{l3keys} module but some
% \metatt{key[=value] controls} are shared between modules.

% \subsection{Properties and inheritance}
% Properties cover various informations, from the language of the code,
% to the color and font. They are uniquely identified by a path component,
% the \emph{tag}, which is used for inheritance. All tags starting with
% two leading underscore characters are reserved by the package.
% Other tags are at the user disposal.
%
% Each processed code chunk has a list of associate tags.
% Most tag inherits from default ones.
%
% \section{Options}
% Key-value options allow the user, \CDRSty{}, \CDRLua{} and CDRPy{} to exchange
% data. What the user is allowed to do is detailed in \url{coder-manual.pdf}.
%
% \subsection{\pkg{fancyvrb}}
% These are \pkg{fancyvrb} options verbatim.
% The \pkg{fancyvrb} manual has more details, only some parts are reproduced hereafter.
% All of these options may not be relevant for all situations.
% Some of them make no sense in |code| mode, whereas others may not be
% compatible with the display engine.
%
% \begin{description}
% \itemtt[\CDRCheckRed formatcom=\meta{command}]^^A
% execute before printing verbatim text.
% Initially empty.
% Ignored in |code| mode.
% \itemtt[\CDRCheckRed fontfamily=\meta{family name}]^^A
% font family to use. |tt|, |courier| and |helvetica| are pre-defined.
% Initially \texttt{tt}.
% \itemtt[\CDRCheckRed fontsize=\meta{font size}]^^A
% size of the font to use. If you use the \pkg{relsize} package as well,
% you can require a change of the size proportional to the current one
% (for instance: |fontsize=\relsize{-2}|).
% Initially \texttt{auto}: the same as the current font.
% \itemtt[\CDRCheckRed fontshape=\meta{font shape}]^^A
% font shape to use. Initially \texttt{auto}: the same as the current font.
% \itemtt[\CDRCheckRed showspaces{[=true$\vert$false]}]^^A
% print a special character representing each space.
% Initially |false|: spaces not shown.
% \itemtt[\CDRCheckRed showtabs=true$\vert$false]^^A
% explicitly show tab characters.
% Initially |false|: tab characters not shown.
% \itemtt[\CDRCheckRed obeytabs=true$\vert$false]^^A
% position characters according to the tabs.
% Initially false: tab characters are added to the current position.
% \itemtt[\CDRCheckRed tabsize=\meta{integer}]^^A
% number of spaces given by a tab character,
% Initially 2 (8 for \pkg{fancyvrb}).
% \itemtt[\CDRCheckRed defineactive=\meta{macro}]^^A
% to define the effect of active characters.
% This allows to do some devious tricks, see the \pkg{fancyvrb} package.
% Initially empty.
% \itemtt[\CDRCheckGreen reflabel=\meta{label}]^^A
% define a label to be used with |\pageref|.
% Initially empty.
% \itemtt[\CDRCheckRed commentchar=\meta{character}]^^A
% lines starting with this character are ignored.
% Initially empty.
% \itemtt[\CDRCheckRed gobble=\meta{integer}]^^A
% number of characters to suppress
% at the beginning of each line (from 0 to 9),
% mainly useful when environments are indented.
% Only |block| mode.
% \itemtt[\CDRCheckRed frame=none$\vert$leftline$\vert$topline$\vert$bottomline$\vert$lines$\vert$single]^^A
% type of frame around the verbatim environment.
% With \texttt{leftline} and \texttt{single} modes, a space of a length given
% by the \LaTeX{} |\fboxsep| macro is added between the left vertical line
% and the text. Initially \texttt{none}: no frame.
% \itemtt[\CDRCheckRed label={\{[\meta{top string}]^^A
%\meta{string}\}}]
% label(s) to print on top, bottom or both, frame lines.
% If the label(s) contains special characters, comma or equal sign,
% it must be placed inside a group.
% If an optional \metatt{top string} is given between square brackets,
% it will be used for the top line and \metatt{string} for the bottom line.
% Otherwise, \metatt{string} is used for both the top or bottom lines.
% Label(s) are printed only if the \texttt{frame} parameter is one of
% \texttt{topline}, \texttt{bottomline}, \texttt{lines} or \texttt{single}.
% Initially empty: no label.
% \itemtt[\CDRCheckRed labelposition=none$\vert$topline$\vert$bottomline$\vert$all]^^A
% position where to print the label(s) when defined.
% When options happen to be contradictory,
% like |frame=topline| and  |labelposition=bottomline|,
% nothing is displayed.
% Initially |none| when no labels are defined,
% |topline| for one label and |all| otherwise.
% \itemtt[\CDRCheckRed numbers=none$\vert$left$\vert$right]^^A
% numbering of the verbatim lines.
% If requested, this numbering is done outside the verbatim environment.
% Initially none: no numbering.
% 
% \itemtt[\CDRCheckRed numbersep=\meta{dimension}]^^A
% gap between numbers and verbatim lines.
% Initially 12pt.
% \itemtt[\CDRCheckRed firstnumber=auto$\vert$last$\vert$\meta{integer}]^^A
% number of the first line.
% |last| means that the numbering is continued from the previous verbatim environment.
% If an integer is given, its value will be used to start the numbering.
% Initially \texttt{auto}: numbering starts from 1.
% \itemtt[\CDRCheckRed stepnumber=\meta{integer}]^^A
% interval at which line numbers are printed.
% Initially 1: all lines are numbered.
% \itemtt[\CDRCheckRed numberblanklines{[=true$\vert$false]}]^^A
% to number or not the white lines (really empty or containing blank characters only).
% Initially |true|: all lines are numbered.
% \itemtt[\CDRCheckRed firstline=\meta{integer}]^^A
% first line to print.
% Initially empty: all lines from the first are printed.
% \itemtt[\CDRCheckRed lastline=\meta{integer}]^^A
% last line to print.
% Initially empty: all lines until the last one are printed.
% \itemtt[\CDRCheckRed baselinestretch=auto$\vert$\meta{dimension}]^^A
% value to give to the usual \cs{baselinestretch} \LaTeX{} parameter.
% Initially \texttt{auto}: its current value just before the verbatim command.
% \itemtt[\CDRCheckProhibited commandchars=\meta{three characters}]^^A
% characters which define the character which starts a macro and marks the
% beginning and end of a group; thus lets us introduce escape sequences in
% verbatim code. Of course, it is better to choose special characters which
% are not used in the verbatim text.
% Private to \pkg{coder}, unavailable to users.
% \itemtt[\CDRCheckRed xleftmargin=\meta{dimension}]^^A
% indentation to add at the start of each line.
% Initially |0pt|: no left margin.
% \itemtt[\CDRCheckRed xrightmargin=\meta{dimension}]^^A
% right margin to add after each line.
% Initially |0pt|: no right margin.
% \itemtt[\CDRCheckRed resetmargins{[=true$\vert$false]}]^^A
% reset the left margin, which is useful if we are inside other indented environments.
% Initially |true|.
% \itemtt[\CDRCheckRed hfuzz=\meta{dimension}]^^A
% value to give to the \TeX{} |\hfuzz| dimension for text to format.
% This can be used to avoid seeing some unimportant overfull box messages.
% Initially 2pt.
% \itemtt[\CDRCheckRed samepage{[=true$\vert$false]}]^^A
% in very special circumstances, we may want to make sure that a verbatim environment
% is not broken, even if it does not fit on the current page.
% To avoid a page break, we can set the samepage parameter to |true|.
% Initially |false|.
% \end{description}
%
% \subsection{\pkg{pygments} options}
% These are \pkg{pygments}'s |LatexFormatter| options,
% used only by \CDRLua{} to communicate with \CDRPy{}.
%
% \begin{description}
% \itemtt[\CDRCheckRed style=\meta{name}]^^A
% the \pkg{pygments} style to use.
% Initially \texttt{default}.
% \itemtt[\CDRCheckProhibited full]^^A
% Tells the formatter to output a "full" document, i.e. a complete
%        self-contained document (default: |false|).
% Forbidden.
% \itemtt[\CDRCheckProhibited title]^^A
% If |full| is true, the title that should be used to caption the
%         document (default empty).
% Forbidden.
% \itemtt[\CDRCheckProhibited encoding]^^A
% If given, must be an encoding name. This will be used to
%        convert the Unicode token strings to byte strings in the
%        output. If it is "" or None, Unicode strings will be written
%        to the output file, which most file-like objects do not
%        support (default: None).
% \itemtt[\CDRCheckProhibited outencoding]^^A
% Overrides |encoding| if given.
% \itemtt[\CDRCheckProhibited docclass]^^A
% If the |full| option is enabled, this is the document class to use
% (default: |article|).
% Forbidden.
% \itemtt[\CDRCheckProhibited preamble]^^A
% If the |full| option is enabled, this can be further preamble commands,
% e.g. ``|\usepackage|`` (default |empty|).
% Forbidden.
% \itemtt[\CDRCheckProhibited  linenos{[=true$\vert$false]}]^^A
% If set to |true|, output line numbers.
% Initially |false|: no numbering.
% Ignored in |code| mode.
% \itemtt[\CDRCheckProhibited  linenostart=\meta{integer}]^^A
% The line number for the first line.
% Initially 1: numbering starts from 1.
% Ignored in |code| mode.
% \itemtt[\CDRCheckProhibited  linenostep=\meta{integer}]^^A
% If set to a number n > 1, only every nth line number is printed.
% Ignored in |code| mode.
% Additional options given to the Verbatim environment (see the \pkg{fancyvrb}
%         docs for possible values).
% Initially empty.
% \itemtt[\CDRCheckProhibited verboptions]^^A
% Forbidden.
% \itemtt[\CDRCheckRed commandprefix=\meta{text}]^^A
% The LaTeX commands used to produce colored output are constructed
%        using this prefix and some letters.
% Initially |PY|.
% \itemtt[\CDRCheckRed texcomments{[=true$\vert$false]}]^^A
% If set to |true|, enables \LaTeX{} comment lines.  That is, \LaTeX{} markup
%        in comment tokens is not escaped so that \LaTeX{} can render it.
% Initially |false|.
% Ignored in code mode.
% \itemtt[\CDRCheckRed mathescape{[=true$\vert$false]}]^^A
% If set to |true|, enables \LaTeX{} math mode escape in comments. That
%        is, |$...$| inside a comment will trigger math mode.
% Initially |false|.
% \itemtt[\CDRCheckRed escapeinside=\meta{before}\meta{after}]^^A
% If set to a string of length 2, enables escaping to \LaTeX{}. Text
%        delimited by these 2 characters is read as LaTeX code and
%        typeset accordingly. It has no effect in string literals. It has
%        no effect in comments if |texcomments| or |mathescape| is
%        set.
% Initially empty.
% \itemtt[\CDRCheckInternal envname=\meta{name}]^^A
% Allows you to pick an alternative environment name replacing |Verbatim|.
%        The alternate environment still has to support |Verbatim|'s option syntax.
% Initially |Verbatim|.
% \end{description}
%
% \subsection{\LaTeX{}}
%
% These are options used by \CDRSty{} to pass data to \CDRPy{}.
% All values are required, possibly empty.
% \begin{description}
% \itemtt[\CDRCheckRed tags] |clist| of tag names, used for line numbering.
% \itemtt[\CDRCheckRed inline] |true| when inline code is concerned, false otherwise.
% \itemtt[\CDRCheckRed ignore_style] |true| when the style has already been defined, false otherwise,
% \itemtt[\CDRCheckRed sty_template] \LaTeX{} source text where |<placeholder:style_defs>| must be replaced by the style definitions provided by \pkg{pygments}.
% It may include the style name.
%
% \itemtt[\CDRCheckRed code_template]%
%   \LaTeX{} source text where |<placeholder:hilighted>| should be replaced
%   by the hilighted code provided by \pkg{pygments}.
% \itemtt[\CDRCheckRed block_template]
%   \LaTeX{} source text where |<placeholder:count>| should be replaced
%   by the count of numbered lines (not all lines may be numbered)
%   and |<placeholder:hilighted>| should be replaced by the hilighted code
%   provided by \pkg{pygments}.
% \end{description}
% All the line templates below are \LaTeX{} source text
%   where |<placeholder:number>| should be replaced by a line number
%   and |<placeholder:line>| should be replaced by the hilighted line code
%   provided by \pkg{pygments}.
%   They should not include a trailing newline char.
% \begin{description}
% \itemtt[\CDRCheckRed single_line_template]   
%   It may contain tag related information and number as well.
%   When the block consists of only one line.
% \itemtt[\CDRCheckRed first_line_template]
%   When the block consists of more than one line.
%   If the tag information is required or new, display only the tag.
%   Display the number if required, otherwise.
% \itemtt[\CDRCheckRed second_line_template]
%   If the first line did not, display the line number, but only when required.
% \itemtt[\CDRCheckRed black_line_template]
%   for numbered lines,
% \itemtt[\CDRCheckRed white_line_template]
%   for unnumbered lines,
% \end{description}
%
% \part{\CDRLua{} implementation}
% \section{Usage}
% This \texttt{lua} library is loaded by \CDRSty{}
% with the instruction \texttt{CDR=require("\jobname-util")}.
% In the sequel, the syntax to call class methods and instance methods are
% presented with either a \texttt{CDR.} or a \texttt{CDR:} prefix.
% This is what is used in the library for convenience.
% Of course either a \texttt{self.} or a \texttt{self:} prefix would be possible.
%
% \section{Declarations}
%    \begin{MacroCode}[OK]
%<*lua>
local lfs   = _ENV.lfs
local tex   = _ENV.tex
local token = _ENV.token
local md5   = _ENV.md5
local kpse  = _ENV.kpse
local rep   = string.rep
local lpeg  = require("lpeg")
local P, Cg, Cp, V = lpeg.P, lpeg.Cg, lpeg.Cp, lpeg.V
local json  = require('lualibs-util-jsn')
%    \end{MacroCode}
% \section{General purpose material}
% \begin{variable}{CDR_PY_PATH}
% Location of the \CDRPy{} utility.
% This will cause an error if |kpsewhich| is not available.
% The |PATH| must be properly set up.
%    \begin{MacroCode}[OK]
local CDR_PY_PATH = kpse.find_file('coder-tool.py')
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{PYTHON_PATH}
% Location of the |python| utility, defaults to 'python'.
%    \begin{MacroCode}[OK]
local PYTHON_PATH = io.popen([[which python]]):read('a'):match("^%s*(.-)%s*$")
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{set_python_path}
% \begin{syntax}
% CDR:set_python_path(\meta{path var})
% \end{syntax}
% \CDRCheckRed Set manually the path of the |python| utility with the contents
% of the \metatt{path var}.
% If the given path does not point to a file or a link then an error is raised.
% \end{function}
%    \begin{MacroCode}[OK]
local function set_python_path(self, path_var)
  local path = assert(token.get_macro(assert(path_var)))
  if #path>0 then
    local mode,_,__ = lfs.attributes(self.PYTHON_PATH,'mode')
    assert(mode == 'file' or mode == 'link')
  else
    path = io.popen([[which python]]):read('a'):match("^%s*(.-)%s*$")
  end
  self.PYTHON_PATH = path  
end
%    \end{MacroCode}
%
% \begin{function}{escape}
% \begin{syntax}
% <variable> = CDR.escape(<string>)
% \end{syntax}
% \CDRCheckRed Escape the given string to be used by the shell.
% \end{function}
%    \begin{MacroCode}[OK]
local function escape(s)
  s = s:gsub(' ','\\ ')
  s = s:gsub('\\','\\\\')
  s = s:gsub('\r','\\r')
  s = s:gsub('\n','\\n')
  s = s:gsub('"','\\"')
  s = s:gsub("'","\\'")
  return s
end
%    \end{MacroCode}
% \begin{function}{make_directory}
% \begin{syntax}
% \meta{variable} = CDR.make_directory(\meta{string path})
% \end{syntax}
% Make a directory at the given path.
% \end{function}
%    \begin{MacroCode}[OK]
local function make_directory(path)
  local mode,_,__ = lfs.attributes(path,"mode")
  if mode == "directory" then
    return true
  elseif mode ~= nil then
    return nil,path.." exist and is not a directory",1
  end
  if os["type"] == "windows" then
    path = path:gsub("/", "\\")
    _,_,__ = os.execute(
      "if not exist "  .. path .. "\\nul " .. "mkdir " .. path
    )
  else
    _,_,__ = os.execute("mkdir -p " .. path)
  end
  mode = lfs.attributes(path,"mode")
  if mode == "directory" then
    return true
  end
  return nil,path.." exist and is not a directory",1
end
%    \end{MacroCode}
% \begin{variable}{dir_p}
% The directory where the auxiliary \pkg{pygments} related files are saved,
% in general \metatt{jobname}|.pygd/|.
% \end{variable}
% \begin{variable}{json_p}
% The path of the JSON file used to communicate with \CDRPy{},
% in general \metatt{jobname}|.pygd/|\metatt{jobname}|.pyg.json|.
% \end{variable}
%    \begin{MacroCode}[OK]
local dir_p, json_p
local jobname = tex.jobname
dir_p = './'..jobname..'.pygd/'
if make_directory(dir_p) == nil then
  dir_p = './'
  json_p = dir_p..jobname..'.pyg.json'
else
  json_p = dir_p..'input.pyg.json'
end
%    \end{MacroCode}
% \begin{function}{print_file_content}
% \begin{syntax}
% CDR.print_file_content(\meta{macro name})
% \end{syntax}
% The command named \metatt{macro name} contains the path to a file.
% Read the content of that file and print the result to the \TeX{} stream.
% \end{function}
%    \begin{MacroCode}[OK]
local function print_file_content(name)
  local p = token.get_macro(name)
  local fh = assert(io.open(p, 'r'))
  local s = fh:read('a')
  fh:close()
  tex.print(s)
end
%    \end{MacroCode}
% \begin{function}{safe_equals}
% \begin{syntax}
% <variable> = safe_equals(<string>)
% \end{syntax}
% Class method.
% Returns an \meta{=...=} string as \metatt{ans} exactly composed of sufficently many \texttt{=} signs
% such that \meta{string} contains neither sequence \texttt{[\meta{ans}[}
% nor \texttt{]\meta{ans}]}.
% \end{function}
%    \begin{MacroCode}[OK]
local eq_pattern = P({ Cp() * P('=')^1 * Cp() + P(1) * V(1) })
local function safe_equals(s)
  local i, j = 0, 0
  local max = 0
  while true do
    i, j = eq_pattern:match(s, j)
    if i == nil then
      return rep('=', max + 1)
    end
    i = j - i
    if i > max then
      max = i
    end
  end
end
%    \end{MacroCode}
%
% \begin{function}{load_exec}
% \begin{syntax}
% CDR:load_exec(\meta{lua code chunk})
% \end{syntax}
% Class method. Loads the given \metatt{lua code chunk} and execute it.
% On error, messages are printed.
% \end{function}
%    \begin{MacroCode}[OK]
local function load_exec(self, chunk)
  local env = setmetatable({ self = self, tex = tex }, _ENV)
  local func, err = load(chunk, 'coder-tool', 't', env)
  if func then
    local ok
    ok, err = pcall(func)
    if not ok then
      print("coder-util.lua Execution error:", err)
      print('chunk:', chunk)
    end
  else
    print("coder-util.lua Compilation error:", err)
    print('chunk:', chunk)
  end
end
%    \end{MacroCode}
%
% \begin{function}{load_exec_output}
% \begin{syntax}
% CDR:load_exec_output(\meta{lua code chunk})
% \end{syntax}
% Instance method to parse the \metatt{lua code chunk} sring for commands and execute them.
% The patterns being searched are enclosed within opening |<<<<<| and closing |>>>>>|,
% each containing 5 characters,
% \begin{description}
% \item[\texttt{?TEX}:\metatt{TeX instructions}] the \metatt{TeX instructions} are executed
% asynchronously once the control comes back to \TeX{}.
% \item[\texttt{!LUA}:\metatt{!Lua instructions}] the \metatt{!Lua instructions} are executed
% synchronously. When not properly designed, these instruction may cause a
% forever loop on execution, for example, they must not use \texttt{CDR:if_code_engine}.
% \item[\texttt{?LUA}:\metatt{?Lua instructions}] these \metatt{?Lua instructions} are executed
% asynchronously once the control comes back to \TeX{} through a call to \cs{directlua},
% which means that they will wait until any previous asynchronous \metatt{?TeX instructions}
% or \metatt{?Lua instructions} completes.
% \end{description}
% \end{function}
%    \begin{MacroCode}[OK]
local parse_pattern
do
  local tag = P('!') + '*' + '?'
  local stp = '>>>>>'
  local cmd = (P(1) - stp)^0
  parse_pattern = P({
    P('<<<<<') * Cg(tag) * 'LUA:' * Cg(cmd) * stp * Cp() + 1 * V(1)
  })
end
local function load_exec_output(self, s)
  local i, tag, cmd
  i = 1
  while true do
    tag, cmd, i = parse_pattern:match(s, i)
    if tag == '!' then
      self:load_exec(cmd)
    elseif tag == '*' then
      local eqs = safe_equals(cmd)
      cmd = '['..eqs..'['..cmd..']'..eqs..']'
      tex.print([[%
\directlua{CDR:load_exec(]]..cmd..[[)}%
]])
    elseif tag == '?' then
      print('\nDEBUG/coder: '..cmd)
    else
      return
    end
  end
end
%    \end{MacroCode}
%
% \section{Properties}
% This is one of the channels from \CDRSty{} to \CDRLua{}.
%
% \section{Hiligting}
% \subsection{Code}
% \begin{function}{hilight_code}
% \begin{syntax}
% CDR:hilight_code(\meta{code var})
% \end{syntax}
% Hilight the code in \pkg{str} variable named \metatt{code var name}.
% Build a configuration table with all data necessary for the processing,
% save it as a |JSON| file and launch \CDRPy{} with the proper arguments.
% \end{function}
%    \begin{MacroCode}
local function hilight_code_prepare(self)
  self['.arguments'] = {
    __cls__ = 'Arguments',
    source  = '',
    md5     = '',
    cache   = true,
    debug   = false,
    pygopts = {
      __cls__ = 'PygOpts',
      lang    = 'tex',
      style   = 'default',
    },
    texopts = {
      __cls__ = 'TeXOpts',
      tags    = '',
      inline  = true,
      ignore_style  = false,
      ignore_source = false,
      pyg_sty_p     = '',
      pyg_tex_p     = ''
    }
  }
end

local function hilight_set(self, key, value)
  local args = self['.arguments']
  local t = args
  if t[key] == nil then
    t = args.pygopts
    if t[key] == nil then
      t = args.texopts
      assert(t[key] ~= nil)
    end
  end
  t[key] = value
end

local function hilight_set_var(self, key, var)
  self:hilight_set(key, assert(token.get_macro(var or 'l_CDR_tl')))
end

local function hilight_code(self)
  local args = self['.arguments']
  local texopts = args.texopts
  local pygopts = args.pygopts
  args.md5 = md5.sumhexa( ('%s:%s:%s'
    ):format(
      args.source,
      texopts.inline and 'code' or 'block',
      pygopts.style
    )
  )
  local pyg_sty_p = dir_p..pygopts.style..'.pyg.sty'
  texopts.pyg_sty_p = pyg_sty_p
  local pyg_tex_p = dir_p..args.md5..'.pyg.tex'
  texopts.pyg_tex_p = pyg_tex_p
  local last = ''
  local use_tool = args.cache == 'false'
  if not use_tool then
    local mode,_,__ = lfs.attributes(pyg_tex_p,'mode')
    if mode == 'file' or mode == 'link' then
      last = [[\CDR@StyleUseTag\input{]]..pyg_tex_p..'}%'
      texopts.ignore_source = true
    else
      use_tool = true
    end  
    if not texopts.ignore_style then
      mode,_,__ = lfs.attributes(pyg_sty_p,'mode')
      if mode == 'file' or mode == 'link' then
        tex.print([[\input{]]..pyg_sty_p..[[}\CDR@StyleUseTag]])
        texopts.ignore_style = true
      else
        use_tool = true
      end  
    end
  end
  if use_tool then
    local json_p = self.json_p
    local f = assert(io.open(json_p, 'w'))
    local s = json.tostring(args, true)
    local ok, err = f:write(s)
    f:close()
    if ok == nil then
      print('File error('..json_p..'): '..err)
    end
    local cmd = ('%s %s %q'):format(
      self.PYTHON_PATH,
      self.CDR_PY_PATH,
      json_p
    )
    local o = io.popen(cmd):read('a')
    self:load_exec_output(o)
  else
    print('NO PYTHON')
  end
  if #last > 0 then
    tex.print(last)
  end
  self:cache_record(pyg_sty_p, pyg_tex_p)
end
%    \end{MacroCode}
%
% \subsection{Block}
%
% \begin{function}{hilight_block_prepare}
% \begin{syntax}
% CDR:hilight_block_prepare(\meta{tags clist var})
% \end{syntax}
% Records the contents of the \metatt{tags clist var} \LaTeX{} variable
% to prepare block hilighting.
% \end{function}
%    \begin{MacroCode}
local function hilight_block_prepare(self, tags_clist_var)
  local tags_clist = assert(token.get_macro(assert(tags_clist_var)))
  local t = {}
  for tag in string.gmatch(tags_clist, '([^,]+)') do
    t[#t+1]=tag
  end
  self['.tags clist']  = tags_clist
  self['.block tags']  = t
  self['.lines'] = {}
  self['.arguments'] = {
    __cls__ = 'Arguments',
    tags    = tags_clist,
    source  = '',
    cache   = false,
    debug   = false,
    pygopts = {
      __cls__ = 'PygOpts',
      lang = 'tex',
      style = 'default',
    },
    texopts = {
      __cls__ = 'TeXOpts',
      inline        = false,
      ignore_style  = false,
      ignore_source = false,
      pyg_sty_p = '',
      pyg_tex_p = ''
    }
  }
end

%    \end{MacroCode}
%
% \begin{function}{record_line}
% \begin{syntax}
% CDR:record_line(\meta{line variable name})
% \end{syntax}
% Store the content of the given named variable.
% \end{function}
%    \begin{MacroCode}[OK]
local function record_line(self, line_variable_name)
  local line = assert(token.get_macro(assert(line_variable_name)))
  local ll = assert(self['.lines'])
  ll[#ll+1] = line
  local lt = self['lines by tag'] or {}
  self['lines by tag'] = lt
  for _,tag in ipairs(self['.block tags']) do
    ll = lt[tag] or {}
    lt[tag] = ll
    ll[#ll+1] = line
  end
end
%    \end{MacroCode}
%
% \begin{function}{hilight_block}
% \begin{syntax}
% CDR:hilight_block()
% \end{syntax}
% Hilight the currently entered block.
% Build a configuration table with all data necessary for the processing,
% save it as a |JSON| file and launch \CDRPy{} with the proper arguments.
% \end{function}
%    \begin{MacroCode}
local function hilight_block(self)
  local args = self['.arguments']
  local texopts = args.texopts
  local pygopts = args.pygopts
  local ll = self['.lines']
  local source = table.concat(ll, '\n')
  args.source = source
  args.md5 = md5.sumhexa( ('%s:%s:%s'
    ):format(
      source,
      texopts.inline and 'code' or 'block',
      pygopts.style
    )
  )
  local pyg_sty_p = dir_p..pygopts.style..'.pyg.sty'
  texopts.pyg_sty_p = pyg_sty_p
  local pyg_tex_p = dir_p..args.md5..'.pyg.tex'
  texopts.pyg_tex_p = pyg_tex_p
  local last = ''
  local use_tool = args.cache == 'false'
  if not use_tool then
    if not texopts.ignore_style then
      local mode,_,__ = lfs.attributes(pyg_sty_p,'mode')
      if mode == 'file' or mode == 'link' then
        tex.print([[\input{]]..pyg_sty_p..'}%')
        texopts.ignore_style = true
      else
        use_tool = true
      end  
    end
    local mode,_,__ = lfs.attributes(pyg_tex_p,'mode')
    if mode == 'file' or mode == 'link' then
      last = [[\input{]]..pyg_tex_p..'}%'
      texopts.ignore_source = true
    else
      use_tool = true
    end  
  end
  if use_tool then
    local json_p = self.json_p
    local f = assert(io.open(json_p, 'w'))
    local ok, err = f:write(json.tostring(args, true))
    f:close()
    if ok == nil then
      print('File error('..json_p..'): '..err)
    end
    local cmd = ('%s %s %q'):format(
      self.PYTHON_PATH,
      self.CDR_PY_PATH,
      json_p
    )
    local o = io.popen(cmd):read('a')
    self:load_exec_output(o)
  else
    print('NO PYTHON')
  end
  if #last > 0 then
    tex.print(last)
  end
  self:cache_record(pyg_sty_p, pyg_tex_p)
end
%    \end{MacroCode}
%
% \begin{function}{hilight_advance}
% \begin{syntax}
% CDR:hilight_advance(\metatt{count})
% \end{syntax}
% \metatt{count} is the number of line hilighted.
% \end{function}
%    \begin{MacroCode}
local function hilight_advance(self, count)
end
%    \end{MacroCode}
%
% \section{Exportation}
% For each file to be exported, \CDRSty{} calls |export_file|
% to initialte the exportation. Then it calls |export_file_info| to
% share the |tags|, |raw|, |preamble|, |postamble| data.
% Finally, |export_complete| is called to complete the exportation.
% \begin{function}{export_file}
% \begin{syntax}
% CDR:export_file(\meta{file name var})
% \end{syntax}
% This is called at export time.
% \metatt{file name var} is the name of an \pkg{str} variable
% containing the file name.
% \end{function}
%    \begin{MacroCode}[OK]
local function export_file(self, file_name)
  self['.name'] = assert(token.get_macro(assert(file_name)))
  self['.export'] = {}
end
%    \end{MacroCode}
% \begin{function}{export_file_info}
% \begin{syntax}
% CDR:export_file_info(\meta{key}, \meta{value name var})
% \end{syntax}
% This is called at export time.
% \metatt{value name var} is the name of an \pkg{str} variable
% containing the value.
% \end{function}
%    \begin{MacroCode}[OK]
local function export_file_info(self, key, value)
  local export = self['.export']
  value = assert(token.get_macro(assert(value)))
  export[key] = value
end
%    \end{MacroCode}
% \begin{function}{export_complete}
% \begin{syntax}
% CDR:export_complete()
% \end{syntax}
% This is called at export time.
% \end{function}
%    \begin{MacroCode}[OK]
local function export_complete(self)
  local name    = self['.name']
  local export  = self['.export']
  local records = self['.records']
  local tt = {}
  local s = export.preamble
  if s then
    tt[#tt+1] = s
  end
  for _,tag in ipairs(export.tags) do
    s = records[tag]:concat('\n')
    tt[#tt+1] = s
    records[tag] = { [1] = s }
  end
  s = export.postamble
  if s then
    tt[#tt+1] = s
  end
  if #tt>0 then
    local fh = assert(io.open(name,'w'))
    fh:write(tt:concat('\n'))
    fh:close()
  end
  self['.file'] = nil
  self['.exportation'] = nil
end
%    \end{MacroCode}
%
% \section{Caching}
% We save some computation time by pygmentizing files only when necessary.
% The \CDRPy{} is expected to create a |*.pyg.sty| file for a style
% and a |*.pyg.tex| file for hilighted code.
% These files are cached during one whole \LaTeX{} run and possibly between
% different \LaTeX{} runs. Lua keeps track
% of both the style files created and hilighted code files created.
% \begin{function}{cache_clean_all, cache_record, cache_clean_unused}
% \begin{syntax}
% CDR:cache_clean_all()
% CDR:cache_record(\meta{style name.pyg.sty}, \meta{digest.pyg.tex})
% CDR:cache_clean_unused()
% \end{syntax}
% Instance methods.
% |cache_clean_all| removes any file in the cache directory named \texttt{\meta{jobname}.pygd}.
% This is automatically executed at the beginning of the document processing
% when there is no aux file.
% This can also be executed on demand with |\directlua{CDR:cache_clean_all()}|.
% The |cache_record| method stores both \metatt{style name.pyg.sty} and \metatt{digest.pyg.tex}.
% These are file names relative to the \texttt{\meta{jobname}.pygd} directory.
% |cache_clean_unused| removes any file in the cache directory \texttt{\meta{jobname}.pygd}
% except the ones that were previously recorded. This is executed at the end of the
% document processing.
% \end{function}
%    \begin{MacroCode}[OK]
local function cache_clean_all(self)
  local to_remove = {}
  for f in lfs.dir(dir_p) do
    to_remove[f] = true
  end
  for k,_ in pairs(to_remove) do
    os.remove(dir_p .. k)
  end
end
local function cache_record(self, pyg_sty_p, pyg_tex_p)
  self['.style_set']  [pyg_sty_p] = true
  self['.colored_set'][pyg_tex_p] = true
end
local function cache_clean_unused(self)
  local to_remove = {}
  for f in lfs.dir(dir_p) do
    f = dir_p .. f
    if not self['.style_set'][f] and not self['.colored_set'][f] then
      to_remove[f] = true
    end 
  end
  for f,_ in pairs(to_remove) do
    os.remove(f)
  end
end
%    \end{MacroCode}
%
% \begin{variable}{_DESCRIPTION}
% Short text description of the module.
%    \begin{MacroCode}[OK]
local _DESCRIPTION = [[Global coder utilities on the lua side]]
%    \end{MacroCode}
% \end{variable}
% \section{Return the module}
%    \begin{MacroCode}
return {
%    \end{MacroCode}
% Known fields are
% \begin{description}
%    \begin{MacroCode}
  _DESCRIPTION       = _DESCRIPTION,
%    \end{MacroCode}
% \item[\texttt{_VERSION}] to store \meta{version string},
%    \begin{MacroCode}
  _VERSION           = token.get_macro('fileversion'),
%    \end{MacroCode}
% \item[\texttt{date}] to store \meta{date string},
%    \begin{MacroCode}
  date               = token.get_macro('filedate'),
%    \end{MacroCode}
% \item[Various paths],
%    \begin{MacroCode}
  CDR_PY_PATH        = CDR_PY_PATH,
  PYTHON_PATH        = PYTHON_PATH,
  set_python_path    = set_python_path,
%    \end{MacroCode}
% \item[escape]
%    \begin{MacroCode}
  escape             = escape,
%    \end{MacroCode}
% \item[make_directory]
%    \begin{MacroCode}
  make_directory     = make_directory,
%    \end{MacroCode}
% \item[load_exec]
%    \begin{MacroCode}
  load_exec          = load_exec,
%    \end{MacroCode}
%    \begin{MacroCode}
  load_exec_output   = load_exec_output,
%    \end{MacroCode}
% \item[record_line]
%    \begin{MacroCode}
  record_line        = record_line,
%    \end{MacroCode}
% \item[hilight_code]
%    \begin{MacroCode}
  hilight_code_prepare = hilight_code_prepare,
  hilight_set          = hilight_set,
  hilight_set_var      = hilight_set_var,
  hilight_code         = hilight_code,
%    \end{MacroCode}
% \item[hilight_block_prepare, hilight_block]
%    \begin{MacroCode}
  hilight_block_prepare = hilight_block_prepare,
  hilight_block         = hilight_block,
  hilight_advance       = hilight_advance,
%    \end{MacroCode}
% \item[cache_clean_all]
%    \begin{MacroCode}
  cache_clean_all    = cache_clean_all,
%    \end{MacroCode}
% \item[cache_record]
%    \begin{MacroCode}
  cache_record       = cache_record,
%    \end{MacroCode}
% \item[cache_clean_unused]
%    \begin{MacroCode}
  cache_clean_unused = cache_clean_unused,
%    \end{MacroCode}
% \item[Internals]
%    \begin{MacroCode}
  ['.style_set']     = {},
  ['.colored_set']   = {},
  ['.options']       = {},
  ['.export']        = {},
  ['.name']          = nil,
%    \end{MacroCode}
% \item[\texttt{already}] false at the beginning,
% true after the first call of \CDRPy{}
%    \begin{MacroCode}
  already            = false,
%    \end{MacroCode}
% \itemtt[Other]
%    \begin{MacroCode}
  json_p             = json_p,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}
}
%    \end{MacroCode}
%    \begin{MacroCode}
%</lua>
%    \end{MacroCode}
%
% \part{\CDRPy{} implementation}
%
% The standard header is managed specially because of the way \pkg{docstrip} automatically 
% adds some header when extracting stuff from an archive.
% The next two lines are added by \pkg{docstrip} at the top of the preamble.
% 
%    \begin{MacroCode}[OK]
%<*py>
#! /usr/bin/env python3
# -*- coding: utf-8 -*-
%</py>
%    \end{MacroCode}
%
% \section{Usage}
% Run: \texttt{\CDRPy{} -h}.
%
% \section{Header and global declarations}
% 
%    \begin{MacroCode}[OK]
%<*py>
__version__ = '0.10'
__YEAR__  = '2022'
__docformat__ = 'restructuredtext'

import sys
import os
import argparse
import re
from pathlib import Path
import json
from pygments import highlight as hilight
from pygments.formatters.latex import LatexEmbeddedLexer, LatexFormatter
from pygments.lexers import get_lexer_by_name
from pygments.util import ClassNotFound
%    \end{MacroCode}
%
% \section{\texttt{Options} classes}
% |Object| is used to turn a dictionary into a full fledged object.
% The real class is given by the |__cls__| key.
%  
%    \begin{MacroCode}[OK]
class BaseOpts(object):
  @staticmethod
  def ensure_bool(x):
    if x == True or x == False: return x
    x = x[0:1]
    return x == 'T' or x == 't'
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
  def __init__(self, d={}):
    for k, v in d.items():
      if type(v) == str:
        if v.lower() == 'true':
          setattr(self, k, True)
          continue
        elif v.lower() == 'false':
          setattr(self, k, False)
          continue
      setattr(self, k, v)
%    \end{MacroCode}
%
% \subsection{\texttt{TeXOpts} class}
%
%    \begin{MacroCode}
class TeXOpts(BaseOpts):
  tags = ''
  inline = True
  ignore_style = False
  ignore_source  = False
  pyg_sty_p    = None
  pyg_tex_p    = None
%    \end{MacroCode}
% The templates are provided by \CDRSty{}.
% The style template wraps the style definitions provided by \pkg{pygments}.
% It may include the style name
%    \begin{MacroCode}
  sty_template=r'''% !TeX root=...
\makeatletter
\CDR@StyleDefine{<placeholder:style_name>}{%
  <placeholder:style_defs>}%
\makeatother'''
  code_template =r'''% !TeX root=...
\makeatletter
\CDR@StyleUseTag%
\CDR@CodeEngineApply{<placeholder:hilighted>}%
\makeatother'''

  single_line_template='<placeholder:number><placeholder:line>'
  first_line_template='<placeholder:number><placeholder:line>'
  second_line_template='<placeholder:number><placeholder:line>'
  white_line_template='<placeholder:number><placeholder:line>'
  black_line_template='<placeholder:number><placeholder:line>'
  block_template=r'''% !TeX root=...
\makeatletter
\CDR@StyleUseTag
<placeholder:hilighted>%
\makeatother'''
  def __init__(self, *args, **kvargs):
    super().__init__(*args, **kvargs)
    self.inline = self.ensure_bool(self.inline)
    self.ignore_style  = self.ensure_bool(self.ignore_style)
    self.ignore_source = self.ensure_bool(self.ignore_source)
    self.pyg_sty_p = Path(self.pyg_sty_p or '')
    self.pyg_tex_p = Path(self.pyg_tex_p or '')
%    \end{MacroCode}
%
% \subsection{\texttt{PygOpts}class}
% \pkg{pygments} |LaTeXFormatter| options.
% Some of them may be deliberately unused.
% In particular, line numbering is governed by \pkg{fancyvrb} options.
% The description of these options is in a forthcoming section.
%    \begin{MacroCode}
class PygOpts(BaseOpts):
  style = 'default'
  nobackground = False
  linenos = False
  linenostart = 1
  linenostep = 1
  commandprefix = 'Py'
  texcomments = False
  mathescape =  False
  escapeinside = ""
  envname = 'Verbatim'
  lang = 'tex'
  def __init__(self, *args, **kvargs):
    super().__init__(*args, **kvargs)
    self.linenos = self.ensure_bool(self.linenos)
    self.linenostart = abs(int(self.linenostart))
    self.linenostep  = abs(int(self.linenostep))
    self.texcomments = self.ensure_bool(self.texcomments)
    self.mathescape  = self.ensure_bool(self.mathescape)
%    \end{MacroCode}
%
% \subsection{\texttt{FV}class}
% 
%    \begin{MacroCode}
class FVOpts(BaseOpts):
  gobble = 0
  tabsize = 4
  linenosep = '0pt'
  commentchar = ''
  frame = 'none'
  label = ''
  labelposition = 'none'
  numbers = 'left'
  numbersep = r'\hspace{1ex}'
  firstnumber = 'auto'
  stepnumber = 1
  numberblanklines = True
  firstline = ''
  lastline = ''
  baselinestretch = 'auto'
  resetmargins = True
  xleftmargin = '0pt'
  xrightmargin = '0pt'
  hfuzz = '2pt'
  samepage = False
  def __init__(self, *args, **kvargs):
    super().__init__(*args, **kvargs)
    self.gobble  = abs(int(self.gobble))
    self.tabsize = abs(int(self.tabsize))
    if self.firstnumber != 'auto':
      self.firstnumber = abs(int(self.firstnumber))
    self.stepnumber = abs(int(self.stepnumber))
    self.numberblanklines = self.ensure_bool(self.numberblanklines)
    self.resetmargins  = self.ensure_bool(self.resetmargins)
    self.samepage  = self.ensure_bool(self.samepage)
%    \end{MacroCode}
%
% \subsection{\texttt{Arguments}class}
%
%    \begin{MacroCode}
class Arguments(BaseOpts):
  cache  = False
  debug  = False
  source = ""
  style  = "default"
  json   = ""
  directory = "."
  texopts = TeXOpts()
  pygopts = PygOpts()
  fv_opts = FVOpts()
%    \end{MacroCode}
% \section{\texttt{Controller} main class}
%    \begin{MacroCode}[OK]
class Controller:
%    \end{MacroCode}
%
% \subsection{Static methods}
%
% \begin{function}{object_hook}
% Helper for json parsing.
% \end{function}
%    \begin{MacroCode}[OK]
  @staticmethod
  def object_hook(d):
    __cls__ = d.get('__cls__', 'Arguments')
    if __cls__ == 'PygOpts':
      return PygOpts(d)
    elif __cls__ == 'FVOpts':
      return FVOpts(d)
    elif __cls__ == 'TeXOpts':
      return TeXOpts(d)
    else:
      return Arguments(d)
%    \end{MacroCode}
%
% \begin{function}{lua_command,lua_command_now,lua_debug}
% \begin{syntax}
% self.lua_command(\meta{asynchronous lua command})
% self.lua_command_now(\meta{synchronous lua command})
% \end{syntax}
% Wraps the given command between markers. It will be in the output of the
% \CDRPy{}, further captured by \CDRLua{}
% and either forwarded to \TeX{} ot executed synchronously.
% \end{function}
%    \begin{MacroCode}[OK]
  @staticmethod
  def lua_command(cmd):
    print(f'<<<<<*LUA:{cmd}>>>>>')
  @staticmethod
  def lua_command_now(cmd):
    print(f'<<<<<!LUA:{cmd}>>>>>')
  @staticmethod
  def lua_debug(msg):
    print(f'<<<<<?LUA:{msg}>>>>>')
%    \end{MacroCode}
%
% \begin{function}{lua_text_escape}
% \begin{syntax}
% self.lua_text_escape(\meta{text})
% \end{syntax}
% Wraps the given command between |[=...=[| and |]=...=]|
% with as many equal signs as necessary to ensure a correct |lua| syntax.
% \end{function}
%    \begin{MacroCode}[OK]
  @staticmethod
  def lua_text_escape(s):
    k = 0
    for m in re.findall('=+', s):
      if len(m) > k: k = len(m)
    k = (k + 1) * "="
    return f'[{k}[{s}]{k}]'
%    \end{MacroCode}
%
% \subsection{Computed properties}
%
% \begin{variable}{self.json_p}
% The full path to the \texttt{json} file containing all the data used for the processing.
% \end{variable}
%    \begin{MacroCode}[OK]
  _json_p = None
  @property
  def json_p(self):
    p = self._json_p
    if p:
      return p
    else:
      p = self.arguments.json
      if p:
        p = Path(p).resolve()
    self._json_p = p
    return p
%    \end{MacroCode}
%
% \begin{variable}{self.parser}
% The correctly set up \texttt{argarse} instance. 
% \end{variable}
%    \begin{MacroCode}[OK]
  @property
  def parser(self):
    parser = argparse.ArgumentParser(
      prog=sys.argv[0],
      description='''
Writes to the output file a set of LaTeX macros describing
the syntax hilighting of the input file as given by pygments.
'''
    )
    parser.add_argument(
      "-v", "--version",
      help="Print the version and exit",
      action='version',
      version=f'coder-tool version {__version__},'
      ' (c) {__YEAR__} by Jérôme LAURENS.'
    )
    parser.add_argument(
      "--debug",
      action='store_true',
      default=None,
      help="display informations useful for debugging"
    )
    parser.add_argument(
      "json",
      metavar="<json data file>",
      help="""
file name with extension, contains processing information
"""
    )
    return parser

%    \end{MacroCode}
%
% \subsection{Methods}
% \subsubsection{\texttt{__init__}}
% \begin{function}{__init__}
% Constructor. Reads the command line arguments.
% \end{function}
%    \begin{MacroCode}[OK]
  def __init__(self, argv = sys.argv):
    argv = argv[1:] if re.match(".*coder\-tool\.py$", argv[0]) else argv
    ns = self.parser.parse_args(
      argv if len(argv) else ['-h']
    )
    with open(ns.json, 'r') as f:
      self.arguments = json.load(
        f,
        object_hook = Controller.object_hook
      )
    args = self.arguments
    args.json = ns.json
    texopts = self.texopts = args.texopts
    pygopts = self.pygopts = args.pygopts
    fv_opts = self.fv_opts = args.fv_opts
    formatter = self.formatter = LatexFormatter(
      style = pygopts.style,
      nobackground = pygopts.nobackground,
      commandprefix = pygopts.commandprefix,
      texcomments = pygopts.texcomments,
      mathescape = pygopts.mathescape,
      escapeinside = pygopts.escapeinside,
      envname = 'CDR@Pyg@Verbatim',
    )

    try:
      lexer = self.lexer = get_lexer_by_name(pygopts.lang)
    except ClassNotFound as err:
      sys.stderr.write('Error: ')
      sys.stderr.write(str(err))

    escapeinside = pygopts.escapeinside
    # When using the LaTeX formatter and the option `escapeinside` is
    # specified, we need a special lexer which collects escaped text
    # before running the chosen language lexer.
    if len(escapeinside) == 2:
      left  = escapeinside[0]
      right = escapeinside[1]
      lexer = self.lexer = LatexEmbeddedLexer(left, right, lexer)

    gobble = fv_opts.gobble
    if gobble:
      lexer.add_filter('gobble', n=gobble)
    tabsize = fv_opts.tabsize
    if tabsize:
      lexer.tabsize = tabsize
    lexer.encoding = ''
       
%    \end{MacroCode}
%
% \subsubsection{\texttt{create\texorpdfstring{_}{-}style}}
% \begin{function}{self.create_style}
% \begin{syntax}
% self.create_style()
% \end{syntax}
% Where the \meta{style} is created.
% Does quite nothing if the style is already available.
% \end{function}
%    \begin{MacroCode}[OK]
  def create_style(self):
    arguments = self.arguments
    texopts = arguments.texopts
    if texopts.ignore_style:
      return
    pyg_sty_p = texopts.pyg_sty_p
    if arguments.cache and pyg_sty_p.exists():
      if arguments.debug:
        self.lua_debug(f'Style already available: {os.path.relpath(pyg_sty_p)}')
      return
    texopts = self.texopts
    style = self.pygopts.style
    if texopts.ignore_style:
      if arguments.debug:
        self.lua_debug(f'Syle already available: {style}')
      return
    formatter = self.formatter
    style_defs = formatter.get_style_defs() \
      .replace(r'\makeatletter', '') \
      .replace(r'\makeatother', '') \
      .replace('\n', '%\n')
    sty = self.texopts.sty_template.replace(
      '<placeholder:style_name>',
      style,
    ).replace(
      '<placeholder:style_defs>', 
      style_defs,
    ).replace(
      '{}%',
      '{%}\n}%{'
    ).replace(
      '[}%',
      '[%]\n}%'
    ).replace(
      '{]}%',
      '{%[\n]}%'
    )
    with pyg_sty_p.open(mode='w',encoding='utf-8') as f:  
      f.write(sty)
    cmd = rf'\input{{./{os.path.relpath(pyg_sty_p)}}}%'
    self.lua_command_now(
      rf'tex.print({self.lua_text_escape(cmd)})'
    )
%    \end{MacroCode}
%
% \subsubsection{\texttt{pygmentize}}
% \begin{function}{self.pygmentize}
% \begin{syntax}
% \meta{code variable} = self.pygmentize(\meta{code}[, inline=\meta{yorn}])
% \end{syntax}
% Where the \meta{code} is hilighted by \pkg{pygments}.
% \end{function}
%    \begin{MacroCode}[OK]
  def pygmentize(self, source):
    source = hilight(source, self.lexer, self.formatter)
    m = re.match(
      r'\\begin{CDR@Pyg@Verbatim}.*?\n(.*?)\n\\end{CDR@Pyg@Verbatim}\s*\Z',
      source,
      flags=re.S
    )
    assert(m)
    hilighted = m.group(1)
    texopts = self.texopts
    if texopts.inline:
      return texopts.code_template.replace(
        '<placeholder:hilighted>', hilighted
      ), 0
    fv_opts = self.fv_opts
    lines = hilighted.split('\n')
    try:
      firstnumber = abs(int(fv_opts.firstnumber))
    except ValueError:
      firstnumber = 1
    number = firstnumber
    stepnumber = fv_opts.stepnumber
    numbering = fv_opts.numbers != 'none'
    ans_code = []
    def more(template, line):
      nonlocal number
      ans_code.append(template.replace(
          '<placeholder:number>', f'{number}',
        ).replace(
          '<placeholder:line>', line,
      ))
      number += 1
    if len(lines) == 1:
      more(texopts.single_line_template, lines.pop(0))
    elif len(lines):
      more(texopts.first_line_template, lines.pop(0))
      more(texopts.second_line_template, lines.pop(0))
      if stepnumber < 2:
        def template():
          return texopts.black_line_template
      elif stepnumber % 5 == 0:
        def template():
          return texopts.black_line_template if number %\
            stepnumber == 0 else texopts.white_line_template
      else:
        def template():
          return texopts.black_line_template if (number - firstnumber) %\
            stepnumber == 0 else texopts.white_line_template
         
      for line in lines:
        more(template(), line)

    hilighted = '\n'.join(ans_code)
    return texopts.block_template.replace(
      '<placeholder:hilighted>', hilighted
    ), number-firstnumber
%%%
%%%    ans_code.append(fr'''%
%%%\begin{{CDR@Block/engine/{pygopts.style}}}
%%%\CDRBlock@linenos@used:n {{{','.join(numbers)}}}%
%%%{m.group(1)}{'\n'.join(lines)}{m.group(3)}%
%%%\end{{CDR@Block/engine/{pygopts.style}}}
%%%''' )
%%%      ans_code = "".join(ans_code)
%%%    return texopts.block_template.replace('<placeholder:hilighted>',hilighted)
%    \end{MacroCode}
%
% \subsubsection{\texttt{create_pygmented}}
% \begin{function}{self.create_pygmented}
% \begin{syntax}
% self.create_pygmented()
% \end{syntax}
% Call \texttt{self.pygmentize} and save the resulting pygmented code
% at the proper location.
% \end{function}
%    \begin{MacroCode}[OK]
  def create_pygmented(self):
    arguments = self.arguments
    texopts = arguments.texopts
    if texopts.ignore_source:
      return True
    source = arguments.source
    if not source:
      return False
    pyg_tex_p = texopts.pyg_tex_p
    hilighted, count = self.pygmentize(source)
    with pyg_tex_p.open(mode='w',encoding='utf-8') as f:
      f.write(hilighted)
    cmd = rf'\input{{./{os.path.relpath(pyg_tex_p)}}}%'
    self.lua_command_now(
      rf'self:hilight_advance({count});tex.print({self.lua_text_escape(cmd)})'
    )
%    \end{MacroCode}
%
% \subsection{Main entry}
%
%    \begin{MacroCode}[OK]
if __name__ == '__main__':
  try:
    ctrl = Controller()
    x = ctrl.create_style() or ctrl.create_pygmented()
    print(f'{sys.argv[0]}: done')    
    sys.exit(x)
  except KeyboardInterrupt:
    sys.exit(1)
%</py>
%    \end{MacroCode}
%
% \part{\CDRSty{} implementation}
%    \begin{MacroCode}
%<*sty>
\makeatletter
%    \end{MacroCode}
% \section{Installation test}
%    \begin{MacroCode}
\NewDocumentCommand \CDRTest {} {
  \sys_if_shell:TF {
    \CDR_has_pygments:F {
      \msg_warning:nnn
        { coder }
        { :n }
        { No~"pygmentize"~found. }
    }
  } {
    \msg_warning:nnn
      { coder }
      { :n }
      { No~unrestricted~shell~escape~for~"pygmentize".}
  }
}
%    \end{MacroCode}
% \section{Messages}
%    \begin{MacroCode}[OK]
\msg_new:nnn { coder } { unknown-choice } {
  #1~given~value~`#3'~not~in~#2
}
%    \end{MacroCode}
% \section{Constants}
% \begin{variable}{\c_CDR_tag,\c_CDR_Tags}
% Paths of \pkg{L3keys} modules.\\
% These are root path components used throughout the pakage.
%    \begin{MacroCode}[OK]
\str_const:Nn \c_CDR_Tags { CDR@Tags }
\str_const:Nx \c_CDR_tag { \c_CDR_Tags/tag }
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\c_CDR_tag_get, \c_CDR_slash}
% Root identifier for tag properties, used throughout the pakage.
% \vspace{1\baselineskip}
%    \begin{MacroCode}[OK]
\str_const:Nn \c_CDR_tag_get { CDR@tag@get }
\str_const:Nx \c_CDR_slash { \tl_to_str:n {/} }
%    \end{MacroCode}
% \end{variable}
%
% \section{Implementation details}
% As far as possible, macro making assignments
% to variables are protected.
% All variables following \pkg{expl3} naming conventions are
% implementation details and therefore must be considered private.
%
% \section{Variables}
% \subsection{Internal scratch variables}
% These local variables are used in a very limited scope.
% \begin{variable}{\l_CDR_bool}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\bool_new:N \l_CDR_bool
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_tl}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_str}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\str_new:N \l_CDR_str
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_seq}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\seq_new:N \l_CDR_seq
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_prop}
% Local scratch variable.
%    \begin{MacroCode}[OK]
\prop_new:N \l_CDR_prop
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_clist}
% The comma separated list of current chunks.
%    \begin{MacroCode}[OK]
\clist_new:N \l_CDR_clist
%    \end{MacroCode}
% \end{variable}
% \subsection{Files}
% \begin{variable}{\l_CDR_in}
% Input file identifier
%    \begin{MacroCode}[OK]
\ior_new:N \l_CDR_in
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_out}
% Output file identifier
%    \begin{MacroCode}[OK]
\iow_new:N \l_CDR_out
%    \end{MacroCode}
% \end{variable}
% \subsection{Global variables}
% Line number counter for the source code chunks.
% \begin{variable}{\g_CDR_source_int}
% Chunk number counter.
%    \begin{MacroCode}
\int_new:N \g_CDR_source_int
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\g_CDR_source_prop}
% Global source property list.
%    \begin{MacroCode}
\prop_new:N \g_CDR_source_prop
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\g_CDR_chunks_tl,\l_CDR_chunks_tl}
% The comma separated list of current chunks.
% If the next list of chunks is the same as the current one,
% then it might not display. 
%    \begin{MacroCode}
\tl_new:N \g_CDR_chunks_tl
\tl_new:N \l_CDR_chunks_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\g_CDR_vars}
% Tree storage for global variables.
%    \begin{MacroCode}
\prop_new:N \g_CDR_vars
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\g_CDR_hook_tl}
% Hook general purpose.
%    \begin{MacroCode}
\tl_new:N \g_CDR_hook_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\g/CDR/Chunks/<name>}
% List of chunk keys for given named code.
% \end{variable}
%
% \subsection{Local variables}
% \begin{variable}{\l_CDR_keyval_tl}
% keyval storage.
%    \begin{MacroCode}
\tl_new:N \l_CDR_keyval_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_options_tl}
% options storage.
%    \begin{MacroCode}
\tl_new:N \l_CDR_options_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_recorded_tl}
% Full verbatim body of the \texttt{CDR} environment.
%    \begin{MacroCode}
\tl_new:N \l_CDR_recorded_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\g_CDR_int}
% Global integer to store linenos locally in time.
%    \begin{MacroCode}
\int_new:N \g_CDR_int
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\l_CDR_line_tl}
% Token list for one line.
%    \begin{MacroCode}
\tl_new:N \l_CDR_line_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_lineno_tl}
% Token list for lineno display.
%    \begin{MacroCode}
\tl_new:N \l_CDR_lineno_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_name_tl}
% Token list for chunk name display.
%    \begin{MacroCode}
\tl_new:N \l_CDR_name_tl
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_info_tl}
% Token list for the info of line.
%    \begin{MacroCode}
\tl_new:N \l_CDR_info_tl
%    \end{MacroCode}
% \end{variable}
%
% \section{Tag properties}
% The tag properties concern the code chunks.
% They are set from different path, such that
% |\l_keys_path_str| must
% be properly parsed for that purpose.
% Commands in this section and the next ones contain |CDR_tag|.
%
% The \metatt{tag names} starting with a double underscore are reserved by the package.
%
% \subsection{Helpers}
% \begin{variable}{\g_CDR_tag_path_seq}
% Global variable to store relative key path.
% Used for automatic management to know what has been defined explicitly.
%    \begin{MacroCode}[OK]
\seq_new:N \g_CDR_tag_path_seq
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}[EXP]{\CDR_tag_get_path:cc, \CDR_tag_get_path:c}
% \begin{syntax}
% \cs{CDR_tag_get_path:cc} \Arg{tag name} \Arg{relative key path}
% \cs{CDR_tag_get_path:c} \Arg{relative key path}
% \end{syntax}
% Internal: return a unique key based on the arguments.
% Used to store and retrieve values.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_get_path:cc #1 #2 {
  \c_CDR_tag_get @ #1 / #2
}
\cs_new:Npn \CDR_tag_get_path:c {
  \CDR_tag_get_path:cc { __local }
}
%    \end{MacroCode}
%
% \subsection{Set}
% \begin{function}{\CDR_tag_set:ccn,\CDR_tag_set:ccV}
% \begin{syntax}
% \cs{CDR_tag_set:ccn} \Arg{tag name} \Arg{relative key path} \Arg{value}
% \end{syntax}
% Store \metatt{value}, which is further retrieved with the instruction
% |\CDR_tag_get:cc {|\metatt{tag name}|}| \linebreak[3]|{|\metatt{relative key path}|}|.
% Only \metatt{tag name} and \metatt{relative key path}
% containing no |@| character are supported.
% Record the relative key path (the part after the tag name)
% of the current full key path in |g_CDR_tag_path_seq|.
% All the affectations are made at the current \TeX{} group level.
% \emph{Nota Bene:} |\cs_generate_variant:Nn| is buggy when there is a `c' argument.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_tag_set:ccn #1 #2 #3 {
  \seq_put_left:Nx \g_CDR_tag_path_seq { #2 }
  \cs_set:cpn { \CDR_tag_get_path:cc { #1 } { #2 } } { \exp_not:n { #3 } }
}
\cs_new_protected:Npn \CDR_tag_set:ccV #1 #2 #3 {
  \exp_args:NnnV
  \CDR_tag_set:ccn { #1 } { #2 } #3
}
%    \end{MacroCode}
%
% \begin{variable}{\c_CDR_tag_regex}
% To parse a \pkg{l3keys} full key path.
%    \begin{MacroCode}[OK]
\tl_set:Nn \l_CDR_tl { /([^/]*)/(.*)$ } \use_none:n { $ }
\tl_put_left:NV \l_CDR_tl \c_CDR_tag
\tl_put_left:Nn \l_CDR_tl { ^ }
\exp_args:NNV
\regex_const:Nn \c_CDR_tag_regex \l_CDR_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDR_tag_set:n}
% \begin{syntax}
% \cs{CDR_tag_set:n} \Arg{value}
% \end{syntax}
% The value is provided but not the \meta{dir} nor the \meta{relative key path},
% both are guessed from |\l_keys_path_str|.
% More precisely, |\l_keys_path_str| is expected to read something like
% \cs{c_CDR_tag}|/|\metatt{tag name}|/|\metatt{relative key path},
% an exception is raised on the contrary.
% This is meant to be call from |\keys_define:nn| argument.
% Implementation detail: the last argument is parsed by the last command.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_set:n {
  \exp_args:NnV
  \regex_extract_once:NnNTF \c_CDR_tag_regex
      \l_keys_path_str \l_CDR_seq {
    \CDR_tag_set:ccn
      { \seq_item:Nn \l_CDR_seq 2 }
      { \seq_item:Nn \l_CDR_seq 3 }
  } {
    \PackageWarning
      { coder }
      { Unexpected~key~path~`\l_keys_path_str' }
    \use_none:n
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR_tag_set:}
% \begin{syntax}
% \cs{CDR_tag_set:}
% \end{syntax}
% None of \meta{dir}, \meta{relative key path} and \metatt{value} are provided.
% The latter is guessed from |\l_keys_value_tl|, and |CDR_tag_set:n| is called.
% This is meant to be call from |\keys_define:nn| argument.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_set: {
  \exp_args:NV
  \CDR_tag_set:n \l_keys_value_tl
}
%    \end{MacroCode}
% \begin{function}{\CDR_tag_set:cn}
% \begin{syntax}
% \cs{CDR_tag_set:cn} \Arg{key path} \Arg{value}
% \end{syntax}
% When the last component of |\l_keys_path_str| should not be used
% to store the \metatt{value}, but \metatt{key path} should be used instead.
% This last component is replaced and |\CDR_tag_set:n| is called afterwards.
% Implementation detail: the second argument is parsed by the last command
% of the expansion.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_set:cn #1 {
  \exp_args:NnV
  \regex_extract_once:NnNTF \c_CDR_tag_regex
      \l_keys_path_str \l_CDR_seq {
    \CDR_tag_set:ccn
      { \seq_item:Nn \l_CDR_seq 2 }
      { #1 }
  } {
    \PackageWarning
      { coder }
      { Unexpected~key~path~`\l_keys_path_str' }
    \use_none:n
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR_tag_choices:}
% \begin{syntax}
% \cs{CDR_tag_choices:}
% \end{syntax}
% Ensure that the |\l_keys_path_str| is set properly.
% This is where a syntax like |\keys_set:nn {...} { choice/a }|
% is managed.
% \end{function}
%    \begin{MacroCode}[OK]
\regex_const:Nn \c_CDR_root_regex { ^(.*)/.*$ } \use_none:n { $ }
\cs_new:Npn \CDR_tag_choices: {
  \exp_args:NVV
  \str_if_eq:nnT \l_keys_key_tl \l_keys_choice_tl {
    \exp_args:NnV
    \regex_extract_once:NnNT \c_CDR_root_regex
        \l_keys_path_str \l_CDR_seq {
      \str_set:Nx \l_keys_path_str {
        \seq_item:Nn \l_CDR_seq 2
      }
    }
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR_tag_choices_set:}
% \begin{syntax}
% \cs{CDR_tag_choices_set:}
% \end{syntax}
% Calls |\CDR_tag_set:n| with the content of |\l_keys_choice_tl| as value.
% Before, ensure that the |\l_keys_path_str| is set properly.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_choices_set: {
  \CDR_tag_choices:
  \exp_args:NV
  \CDR_tag_set:n \l_keys_choice_tl
}
%    \end{MacroCode}
%
% \begin{function}[EXP,TF]{ \CDR_if_tag_truthy:cc, \CDR_if_tag_truthy:cc }
% \begin{syntax}
% \cs{CDR_if_truthy:ccTF} \Arg{tag name} \Arg{relative key path} \Arg{true code} \Arg{false code}
% \cs{CDR_if_truthy:cTF} \Arg{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when te property for \metatt{tag name}
% and \metatt{relative key path} is a truthy value,
% \metatt{false code} otherwise.
% A truthy value is a text which is not ``false'' in a case insensitive comparison.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_tag_truthy:cc { p, T,  F, TF } {
  \exp_args:Ne
  \str_compare:nNnTF {
    \str_lowercase:n { \CDR_tag_get:cc { #1 } { #2 } }
  } = { false } {
    \prg_return_false:
  } {
    \prg_return_true:
  }
}
\prg_new_conditional:Nnn \CDR_if_tag_truthy:c { p, T,  F, TF } {
  \exp_args:Ne
  \str_compare:nNnTF {
    \str_lowercase:n { \CDR_tag_get:c { #1 } }
  } = { false } {
    \prg_return_false:
  } {
    \prg_return_true:
  }
}
%    \end{MacroCode}
%
% \begin{function}[TF]{ \CDR_if_truthy:n, \CDR_if_truthy:e }
% \begin{syntax}
% \cs{CDR_if_truthy:nTF} \Arg{token list} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when \metatt{token list} is a truthy value,
% \metatt{false code} otherwise.
% A truthy value is a text which leading character, if any,
% is none of ``fFnN''.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_truthy:n { p, T,  F, TF } {
  \exp_args:Nf
  \str_compare:nNnTF { \str_lowercase:n { #1 } } = { false } {
    \prg_return_false:
  } {
    \prg_return_true:
  }
}
\prg_generate_conditional_variant:Nnn \CDR_if_truthy:n { e } { p, T, F, TF }
%    \end{MacroCode}
%
% \begin{function}{\CDR_tag_boolean_set:n}
% \begin{syntax}
% \cs{CDR_tag_boolean_set:n} \Arg{choice}
% \end{syntax}
% Calls |\CDR_tag_set:n| with |true| if the argument is truthy,
% |false| otherwise.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_tag_boolean_set:n #1 {
  \CDR_if_truthy:nTF { #1 } {
    \CDR_tag_set:n { true }
  } {
    \CDR_tag_set:n { false }
  }
}
\cs_generate_variant:Nn \CDR_tag_boolean_set:n { x }
%    \end{MacroCode}
%
% \subsection{Retrieving tag properties}
% Internally, all tag properties are collected with a full key path like
% |\c_CDR_tag_get/|\metatt{tag name}|/|\metatt{relative key path}.
% When typesetting some code with either the \cs{CDRCode} command or the
% |CDRBlock| environment, all properties defined locally are collected under
% the reserved |\c_CDR_tag_get/__local/|\metatt{relative path} full key paths.
% The \pkg{l3keys} module |\c_CDR_tag_get/__local| is modified in \TeX{} groups only.
% For running text code chunks, this module inherits from
% \begin{enumerate}
% \item |\c_CDR_tag_get/|\metatt{tag name} for the provided \metatt{tag name},
% \item |\c_CDR_tag_get/default.code|
% \item |\c_CDR_tag_get/default|
% \item |\c_CDR_tag_get/__pygments|
% \item |\c_CDR_tag_get/__fancyvrb|
% \item |\c_CDR_tag_get/__fancyvrb.all| when no using \pkg{pygments}
% \end{enumerate}
% For text block code chunks, this module inherits from
% \begin{enumerate}
% \item |\c_CDR_tag_get/|\metatt{name_1}, ..., |\c_CDR_tag_get/|\metatt{name_n}
% for each tag name of the ordered tags list
% \item |\c_CDR_tag_get/default.block|
% \item |\c_CDR_tag_get/default|
% \item |\c_CDR_tag_get/__pygments|
% \item |\c_CDR_tag_get/__pygments.block|
% \item |\c_CDR_tag_get/__fancyvrb|
% \item |\c_CDR_tag_get/__fancyvrb.block|
% \item |\c_CDR_tag_get/__fancyvrb.all| when no using \pkg{pygments}
% \end{enumerate}
%
% \begin{function}[TF,EXP]{\CDR_tag_if_exist_here:cc}
% \begin{syntax}
% \cs{CDR_tag_if_exist_here:ccTF} \Arg{tag name} \meta{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% If the \metatt{relative key path} is known within \metatt{tag name},
% the \metatt{true code} is executed,
% otherwise, the \metatt{false code} is executed.
% No inheritance.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_tag_if_exist_here:cc { T, F, TF } {
  \cs_if_exist:cTF { \CDR_tag_get_path:cc { #1 } { #2 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \begin{function}[TF,EXP]{\CDR_tag_if_exist:cc, \CDR_tag_if_exist:c}
% \begin{syntax}
% \cs{CDR_tag_if_exist:ccTF} \Arg{tag name} \meta{relative key path} \Arg{true code} \Arg{false code}
% \cs{CDR_tag_if_exist:cTF} \meta{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% If the \metatt{relative key path} is known within \metatt{tag name},
% the \metatt{true code} is executed,
% otherwise, the \metatt{false code} is executed if none of the  parents has the \metatt{relative key path} on its own.
% In the second version, the \metatt{tag name} is not provided and set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_tag_if_exist:cc { T, F, TF } {
  \cs_if_exist:cTF { \CDR_tag_get_path:cc { #1 } { #2 } } {
    \prg_return_true:
  } {
    \seq_if_exist:cTF { \CDR_tag_parent_seq:c { #1 } } {
      \seq_map_tokens:cn
        { \CDR_tag_parent_seq:c { #1 } }
        { \CDR_tag_if_exist_f:cn { #2 } }
    } {
      \prg_return_false:
    }
  }
}
\prg_new_conditional:Nnn \CDR_tag_if_exist:c { T, F, TF } {
  \cs_if_exist:cTF { \CDR_tag_get_path:c { #1 } } {
    \prg_return_true:
  } {
    \seq_if_exist:cTF { \CDR_tag_parent_seq:c { __local } } {
      \seq_map_tokens:cn
        { \CDR_tag_parent_seq:c { __local } }
        { \CDR_tag_if_exist_f:cn { #1 } }
    } {
      \prg_return_false:
    }
  }
}
\cs_new:Npn \CDR_tag_if_exist_f:cn #1 #2 {
  \quark_if_no_value:nTF { #2 } {
    \seq_map_break:n {
      \prg_return_false:
    }
  } {
    \CDR_tag_if_exist:ccT { #2 } { #1 } {
      \seq_map_break:n {
        \prg_return_true:
      }
    }
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP]{\CDR_tag_get:cc, \CDR_tag_get:c}
% \begin{syntax}
% \cs{CDR_tag_get:cc} \Arg{tag name} \Arg{relative key path}
% \cs{CDR_tag_get:c} \Arg{relative key path}
% \end{syntax}
% The property value stored for \metatt{tag name}
% and \metatt{relative key path}.
% Takes care of inheritance.
% In the second version, the \metatt{tag name} is not provided an set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_get:cc #1 #2 {
  \CDR_tag_if_exist_here:ccTF { #1 } { #2 } {
    \use:c { \CDR_tag_get_path:cc { #1 } { #2 } }
  } {
    \seq_if_exist:cT { \CDR_tag_parent_seq:c { #1 } } {
      \seq_map_tokens:cn
        { \CDR_tag_parent_seq:c { #1 } }
        { \CDR_tag_get_f:cn { #2 } }
    }
  }
}
\cs_new:Npn \CDR_tag_get_f:cn #1 #2 {
  \quark_if_no_value:nF { #2 } {
    \CDR_tag_if_exist_here:ccT { #2 } { #1 } {
      \seq_map_break:n {
        \use:c { \CDR_tag_get_path:cc { #2 } { #1 } }  
      }
    }
  }
}
\cs_new:Npn \CDR_tag_get:c {
  \CDR_tag_get:cc { __local }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_tag_get:ccN, \CDR_tag_get:cN}
% \begin{syntax}
% \cs{CDR_tag_get:ccN} \Arg{tag name} \Arg{relative key path} \Arg{tl variable}
% \cs{CDR_tag_get:cN} \Arg{relative key path} \Arg{tl variable}
% \end{syntax}
% Put in \metatt{tl variable} the property value stored
% for the |__local| \metatt{tag name} and \metatt{relative key path}.
% In the second version, the \metatt{tag name} is not provided an set to |__local|.
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_tag_get:ccN #1 #2 #3 {
  \tl_set:Nf #3 { \CDR_tag_get:cc { #1 } { #2 } }
}
\cs_new_protected:Npn \CDR_tag_get:cN {
  \CDR_tag_get:ccN { __local }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}[TF]{\CDR_tag_get:ccN, \CDR_tag_get:cN}
% \begin{syntax}
% \cs{CDR_tag_get:ccNTF} \Arg{tag name} \Arg{relative key path} \meta{tl var} \Arg{true code} \Arg{false code}
% \cs{CDR_tag_get:cNTF} \Arg{relative key path} \meta{tl var} \Arg{true code} \Arg{false code}
% \end{syntax}
% Getter with branching.
% If the \metatt{relative key path} is knwon,
% save the value into \metatt{tl var} and
% execute \meta{true code}.
% Otherwise, execute \metatt{false code}.
% In the second version, the \metatt{tag name} is not provided an set to |__local|.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_protected_conditional:Nnn \CDR_tag_get:ccN { T, F, TF } {
  \CDR_tag_if_exist:ccTF { #1 } { #2 } {
    \CDR_tag_get:ccN { #1 } { #2 } #3
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_protected_conditional:Nnn \CDR_tag_get:cN { T, F, TF } {
  \CDR_tag_if_exist:cTF { #1 } {
    \CDR_tag_get:cN { #1 } #2
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \subsection{Inheritance}
% When a child inherits from a parent, all the keys of the parent
% that are not inherited are made available to the child
% (inheritance does not jump over generations).
% \begin{function}[EXP]{\CDR_tag_parent_seq:c}
% \begin{syntax}
% \cs{CDR_tag_parent_seq:c} \Arg{tag name}
% \end{syntax}
% Return the name of the sequence variable containing the list of the parents. Each child has its own sequence of parents.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_parent_seq:c #1 {
  g_CDR:parent.tag @ #1 _seq
}
%    \end{MacroCode}
% \begin{function}{\CDR_tag_inherit:cn, \CDR_tag_inherit:cf, \CDR_tag_inherit:cV}
% \begin{syntax}
% \cs{CDR_tag_inherit:cn} \Arg{child name} \Arg{parent names comma list}
% \end{syntax}
% Set the parents of \metatt{child name} to the
% given list.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_inherit:cn #1 #2 {
  \seq_set_from_clist:cn { \CDR_tag_parent_seq:c { #1 } } { #2 }
  \seq_remove_duplicates:c \l_CDR_tl
  \seq_remove_all:cn \l_CDR_tl {}
  \seq_put_right:cn \l_CDR_tl { \q_no_value }
}
\cs_new:Npn \CDR_tag_inherit:cf {
  \exp_args:Nnf \CDR_tag_inherit:cn
}
\cs_new:Npn \CDR_tag_inherit:cV {
  \exp_args:NnV \CDR_tag_inherit:cn
}
%    \end{MacroCode}
% \section{Cache management}
% If there is no \metatt{jobname}|.aux| file, there should be no cached files either,
% \CDRLua{} is asked to clean all of them, if any.
%    \begin{MacroCode}[OK]
\AddToHook { begindocument/before } {
  \IfFileExists {./\jobname.aux} {} {
   \lua_now:n {CDR:cache_clean_all()}
  }
}
%    \end{MacroCode}
% At the end of the document, \CDRLua{} is asked to clean all
% unused cached files that could come from a previous process.
%    \begin{MacroCode}[OK]
\AddToHook { enddocument/end } {
  \lua_now:n {CDR:cache_clean_unused()}
}
%    \end{MacroCode}
%
% \section{Utilities}
% \begin{function}{\CDR_clist_map_inline:Nnn}
% \begin{syntax}
% \cs{CDR_clist_map_inline:Nnn} \meta{clist var} \Arg{empty code} \Arg{non empty code}
% \end{syntax}
% Execute \metatt{empty code} when the list is empty, otherwise
% call |\clist_map_inline:Nn| with \metatt{non empty code}.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_clist_map_inline:Nnn #1 #2 {
  \clist_if_empty:NTF #1 {
    #2
    \use_none:n
  } {
    \clist_map_inline:Nn #1
  }
}
%    \end{MacroCode}
% \end{function}
% \begin{function}[EXP,pTF]{\CDR_if_block:}
% \begin{syntax}
% \cs{CDR_if_block:TF} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when inside a code block,
% \metatt{false code} when inside an inline code.
% Raises an error otherwise.
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_block: { p, T, F, TF } {
  \PackageError
    { coder }
    { Conditional~not~available }
}
%    \end{MacroCode}
% \end{function}
% \begin{function}{\CDR_process_record:}
% Record the current line or not.
% The default implementation does nothing and is meant to
% be defines locally.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_process_record: {}
%    \end{MacroCode}
% \end{function}
%
% \section{\pkg{l3keys} modules for code chunks}
%
% All these modules are initialized at the beginning
% of the document using the |__initialize| meta key.
%
% \subsection{Utilities}
% \begin{function}{\CDR_tag_keys_define:nn}
% \begin{syntax}
% \cs{CDR_tag_keys_define:nn} \Arg{ module base } \Arg{ keyval list }
% \end{syntax}
% The \metatt{module} is uniquely based on \metatt{module base} before
% forwarding to |\keys_define:nn|.
%    \begin{MacroCode}[OK]
\cs_generate_variant:Nn \keys_define:nn { Vn, xn }
\cs_new:Npn \CDR_tag_keys_define:nn #1 {
  \keys_define:xn { \c_CDR_tag / \exp_not:n { #1 } }
}
\cs_generate_variant:Nn \CDR_tag_keys_define:nn { nx }
%    \end{MacroCode}
% \end{function}
% \begin{function}{\CDR_tag_keys_set:nn}
% \begin{syntax}
% \cs{CDR_tag_keys_set:nn} \Arg{module base} \Arg{keyval list}
% \end{syntax}
% The \metatt{module} is uniquely based on \metatt{module base} before
% forwarding to |\keys_set:nn|.
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_tag_keys_set:nn #1 {
  \exp_args:Nx
  \keys_set:nn { \c_CDR_tag / \exp_not:n { #1 } }
}
\cs_generate_variant:Nn \CDR_tag_keys_set:nn { nV }
%    \end{MacroCode}
% \end{function}
%
% \subsubsection{Handling unknown tags}
% While using |\keys_set:nn| and variants, each time a full key path matching the pattern
% |\c_CDR_tag/|\metatt{tag name}|/|\metatt{relative key path}
% is not recognized, we assume that the client implicitly wants a tag
% with the given \metatt{tag name} to be defined. For that purpose, we collect
% unknown keys with |\keys_set_known:nnnN| then process them to find
% each \metatt{tag name} and define
% the new tag accordingly.
% A similar situation occurs for display engine options where the
% full key path reads
% |\c_CDR_tag/|\metatt{tag name}|/|\metatt{engine name}| engine options|
% where \metatt{engine name} is not known in advance.
%
% \begin{function}{\CDR_keys_set_known:nnN}
% \begin{syntax}
% \cs{CDR_keys_set_known:nnN} \Arg{module} \Arg{key[=value] items} \meta{tl var}
% \end{syntax}
% Wrappers over |\keys_set_known:nnnN|
% where the \metatt{root} is also the \metatt{module}.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_keys_set_known:nnN #1 #2 {
  \keys_set_known:nnnN { #1 } { #2 } { #1 }
}
\cs_generate_variant:Nn \CDR_keys_set_known:nnN { x, VV }
%    \end{MacroCode}
%
% \begin{function}{\CDR_keys_inherit:nnn}
% \begin{syntax}
% \cs{CDR_keys_inherit:nnn} \Arg{tag root} \Arg{tag name} \Arg{parents comma list}
% \end{syntax}
% The \metatt{tag name} and parents are given relative to \metatt{tag root}.
% Set the inheritance.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_keys_inherit__:nnn #1 #2 #3 {
  \keys_define:nn { #1 } { #2 .inherit:n = { #3 } }
}
\cs_new:Npn \CDR_keys_inherit:nnn #1 #2 #3 {
  \tl_if_empty:nTF { #1 } {
    \CDR_keys_inherit__:nnn { } { #2 } { #3 }
  } {
    \clist_set:Nn \l_CDR_clist { #3 }
    \exp_args:Nnnx
    \CDR_keys_inherit__:nnn { #1 } { #2 } {
      #1 / \clist_use:Nn \l_CDR_clist { ,#1/ }
    }    
  }
}
\cs_generate_variant:Nn \CDR_keys_inherit:nnn { VnV, Vnn }
%    \end{MacroCode}
%
% \begin{function}{\CDR_tag_keys_set_known:nnN}
% \begin{syntax}
% \cs{CDR_tag_keys_set_known:nnN} \Arg{tag name} \Arg{key[=value] items} \meta{tl var}
% \end{syntax}
% Wrappers over |\keys_set_known:nnnN|
% where the module is given by |\c_CDR_tag/|\metatt{tag name}.
% \emph{Implementation detail} the remaining arguments are absorbed by the last macro.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_generate_variant:Nn \keys_set_known:nnnN { VVV, nVx }
\cs_new:Npn \CDR_tag_keys_set_known:nnN #1 {
  \CDR_keys_set_known:xnN { \c_CDR_tag / \exp_not:n { #1 } }
}
\cs_generate_variant:Nn \CDR_tag_keys_set_known:nnN { nV }
%    \end{MacroCode}
% \begin{variable}{\c_CDR_provide_regex}
% To parse a \pkg{l3keys} full key path.
%    \begin{MacroCode}[OK]
\tl_set:Nn \l_CDR_tl { /([^/]*)(?:/(.*))?$ } \use_none:n { $ }
\tl_put_left:NV \l_CDR_tl \c_CDR_tag
\tl_put_left:Nn \l_CDR_tl { ^ }
\exp_args:NNV
\regex_const:Nn \c_CDR_provide_regex \l_CDR_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDR_tag_provide_from_clist:n,\CDR_tag_provide_from_keyval:n}
% \begin{syntax}
% \cs{CDR_tag_provide_from_clist:n} \Arg{deep comma list}
% \cs{CDR_tag_provide_from_keyval:n} \Arg{key-value list}
% \end{syntax}
% \metatt{deep comma list} has format
% |tag/|\metatt{tag name comma list}.
% Parse the \metatt{key-value list} for full key path matching
% |tag/|\metatt{tag name}|/|\metatt{relative key path},
% then ensure that \cs{c_CDR_tag}|/|\metatt{tag name} is a known full key path.
% For that purpose, we use |\keyval_parse:nnn| with two |\CDR_tag_provide:| helper.
%
% Notice that a tag name should contain no `/'.
% \end{function}
%    \begin{MacroCode}[OK]
\regex_const:Nn \c_CDR_engine_regex { ^[^/]*\sengine\soptions$ } \use_none:n { $ }
\cs_new:Npn \CDR_tag_provide_from_clist:n #1 {
  \exp_args:NNx
  \regex_extract_once:NnNTF \c_CDR_provide_regex {
    \c_CDR_Tags / #1
  } \l_CDR_seq {
    \tl_set:Nx \l_CDR_tl { \seq_item:Nn \l_CDR_seq 3 }
    \exp_args:Nx
    \clist_map_inline:nn {
      \seq_item:Nn \l_CDR_seq 2
    } {
      \exp_args:NV
      \keys_if_exist:nnF \c_CDR_tag { ##1 } {
        \CDR_keys_inherit:Vnn \c_CDR_tag { ##1 } {
          __pygments, __pygments.block,
          default.block, default.code, default,
          __fancyvrb, __fancyvrb.block, __fancyvrb.all
        }
        \keys_define:Vn \c_CDR_tag {
          ##1 .code:n = \CDR_tag_keys_set:nn { ##1 } { ####1 },
          ##1 .value_required:n = true,
        }
      }
      \exp_args:NxV
      \keys_if_exist:nnF { \c_CDR_tag / ##1 } \l_CDR_tl {
        \exp_args:NNV
        \regex_match:NnT \c_CDR_engine_regex
            \l_CDR_tl {
          \CDR_tag_keys_define:nx { ##1 } {
            \l_CDR_tl .code:n = \exp_not:n { \CDR_tag_set:n { ####1 } },
            \l_CDR_tl .value_required:n = true,
          }
        }
      }
    }
  } {
    \regex_match:NnT \c_CDR_engine_regex { #1 } {
      \CDR_tag_keys_define:nn { default } {
        #1 .code:n = \CDR_tag_set:n { ##1 },
        #1 .value_required:n = true,
      }
    }
  }
}
\cs_new:Npn \CDR_tag_provide_from_clist:nn #1 #2 {
  \CDR_tag_provide_from_clist:n { #1 }
}
\cs_new:Npn \CDR_tag_provide_from_keyval:n {
  \keyval_parse:nnn {
    \CDR_tag_provide_from_clist:n
  } {
    \CDR_tag_provide_from_clist:nn
  }
}
\cs_generate_variant:Nn \CDR_tag_provide_from_keyval:n { V }
%    \end{MacroCode}
%
%
% \subsection{\pkg{pygments}}
% These are \pkg{pygments}'s |LatexFormatter| options,
% that are not covered by |__fancyvrb|.
% They are made available at the end user level,
% but may not be relevant when \pkg{pygments} is nor used.
%
% \subsubsection{Utilities}
% \begin{function}[EXP,pTF]
%   {\CDR_has_pygments:}
%   \begin{syntax}
%     \cs{CDR_has_pygments:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \metatt{true code} when \pkg{pygments} is available,
% \meta{false code} otherwise.
% \emph{Implementation detail}: we define the conditionals and set
% them afterwards.
%    \begin{MacroCode}[OK]
\sys_get_shell:nnN {which~pygmentize} {} \l_CDR_tl
\prg_new_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } { }  
\tl_if_in:NnTF \l_CDR_tl { pygmentize } {
  \prg_set_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
    \prg_return_true:
  }  
} {
  \prg_set_conditional:Nnn \CDR_has_pygments: { p, T, F, TF } {
    \prg_return_false:
  }  
}
%    \end{MacroCode}
% \end{function}
%
% \subsubsection{\texttt{__pygments }
% \pkg{l3keys} module}
%
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __pygments } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed lang=\meta{language name}]^^A
%where \metatt{language name} is recognized by \texttt{pygments}, including a void string,
%    \begin{MacroCode}[OK]
  lang .code:n = \CDR_tag_set:,
  lang .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed pygments{[=true$\vert$false]}]^^A
% whether \pkg{pygments} should be used for syntax coloring.
% Initially |true| if \pkg{pygments} is available,
% |false| otherwise.
%    \begin{MacroCode}[OK]
  pygments .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed style=\meta{style name}]^^A
%where \metatt{style name} is recognized by \texttt{pygments}, including a void string,
%    \begin{MacroCode}[OK]
  style .code:n = \CDR_tag_set:,
  style .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed commandprefix=\meta{text}]^^A
% The \LaTeX{} commands used to produce colored output are constructed
%        using this prefix and some letters.
% Initially |PY|.
%    \begin{MacroCode}[OK]
  commandprefix .code:n = \CDR_tag_set:,
  commandprefix .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed mathescape{[=true$\vert$false]}]^^A
% If set to |true|, enables \LaTeX{} math mode escape in comments. That
%        is, |$...$| inside a comment will trigger math mode.
% Initially |false|.
%    \begin{MacroCode}[OK]
  mathescape .code:n = \CDR_tag_boolean_set:x { #1 },
  mathescape .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed escapeinside=\meta{before}\meta{after}]^^A
% If set to a string of length 2, enables escaping to \LaTeX{}. Text
%        delimited by these 2 characters is read as \LaTeX{} code and
%        typeset accordingly. It has no effect in string literals. It has
%        no effect in comments if |texcomments| or |mathescape| is
%        set.
% Initially empty.
%    \begin{MacroCode}[OK]
  escapeinside .code:n = \CDR_tag_set:,
  escapeinside .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% Initializer.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    lang = tex,
    pygments = \CDR_has_pygments:TF { true } { false },
    style=default,
    commandprefix=PY,
    mathescape=false,
    escapeinside=,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __pygments } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{\textbackslash c_CDR_tag / __pygments.block }
% \pkg{l3keys} module}
%
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __pygments.block } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed texcomments{[=true$\vert$false]}]^^A
% If set to |true|, enables \LaTeX{} comment lines.  That is, \LaTeX{} markup
%        in comment tokens is not escaped so that \LaTeX{} can render it.
% Initially |false|.
%    \begin{MacroCode}[OK]
  texcomments .code:n = \CDR_tag_boolean_set:x { #1 },
  texcomments .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% Initializer.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    texcomments=false,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __pygments.block } { __initialize }
}
%    \end{MacroCode}
%
% \subsection{Specifc to \pkg{coder}}
%
% \subsubsection{\texttt{default} \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { default } {
%    \end{MacroCode}
% Keys are:
% \begin{description}
% \itemtt[\CDRCheckRed format=\meta{format commands}]^^A
% the format used to display the code (mainly font, size and color),
% after the font has been selected.
% Initially empty.
%    \begin{MacroCode}[OK]
  format .code:n = \CDR_tag_set:,
  format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed cache]^^A
% Set to |true| if \CDRPy{} should use already existing files
% instead of creating new ones.
% Initially true.
%    \begin{MacroCode}[OK]
  cache .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed debug]^^A
% Set to |true| if various debugging messages should be printed to the console .
% Initially false.
%    \begin{MacroCode}[OK]
  debug .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed post processor=\meta{command}]^^A
% the command for \pkg{pygments} post processor.
% This is a string where every occurrence of ``|%%file%%|'' is replaced by
% the full path of the |*.pyg.tex| file to be post processed
% and then executed as terminal instruction.
% Initially empty.
%    \begin{MacroCode}[OK]
  post~processor .code:n = \CDR_tag_set:,
  post~processor .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed parskip]^^A
% the value of the \cs{parskip} in code blocks,
%    \begin{MacroCode}[OK]
  parskip .code:n = \CDR_tag_set:,
  parskip .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed engine=\meta{engine name}]^^A
% to specify the engine used to display inline code or blocks.
% Initially |default|.
%    \begin{MacroCode}[OK]
  engine .code:n = \CDR_tag_set:,
  engine .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed default engine options=\meta{default engine options}]^^A
% to specify the corresponding options,
%    \begin{MacroCode}[OK]
  default~engine~options .code:n = \CDR_tag_set:,
  default~engine~options .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed \meta{engine name} engine options=\meta{engine options}]^^A
% to specify the options
% for the named engine,
% \itemtt[\CDRCheckRed __initialize]^^A
% to initialize storage properly. We cannot use |.initial:n| actions
% because the |\l_keys_path_str| is not set up properly.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    format = ,
    cache = true,
    debug = false,
    post~processor = ,
    parskip = \the\parskip,
    engine = default,
    default~engine~options = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
%
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { default } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{default.code }
% \pkg{l3keys} module}
% Void for the moment.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { default.code } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed __initialize]^^A
% to initialize storage properly. We cannot use |.initial:n| actions
% because the |\l_keys_path_str| is not set up properly.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
%
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { default.code } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{default.block} \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { default.block } {
%    \end{MacroCode}
% Known keys include:
% \begin{description}
% \itemtt[\CDRCheckRed show tags{[=true$\vert$false]}]^^A
% to enable/disable the display
% of the code chunks tags.
% Initially |true|.
% \itemtt[\CDRCheckRed tags=\meta{tag name comma list}]^^A
% to export and display.
%    \begin{MacroCode}
  tags .code:n = {
    \clist_set:Nn \l_CDR_tags_clist { #1 }
    \clist_remove_duplicates:N \l_CDR_tags_clist
    \exp_args:NV
    \CDR_tag_set:n \l_CDR_tags_clist
  },
  tags .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed tags format=\meta{format commands}]^^A
%, where \meta{format} is used
% the format used to display the tag names (mainly font, size and color),
% after it is appended to the |numbers format|.
% Initially empty.
%    \begin{MacroCode}[OK]
  tags~format .code:n = \CDR_tag_set:,
  tags~format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed numbers format=\meta{format commands}]^^A
%, where \meta{format} is used
% the format used to display line numbers (mainly font, size and color).
%    \begin{MacroCode}[OK]
  numbers~format .code:n = \CDR_tag_set:,
  numbers~format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed show tags={[=true$\vert$false]}]^^A
% whether tags should be displayed.
%    \begin{MacroCode}[OK]
  show~tags .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed only top{[=true$\vert$false]}]^^A
% to avoid chunk tags repetitions, if on the same page,
% two consecutive code chunks have the same tag names, the second names are not displayed.
%    \begin{MacroCode}[OK]
  only~top .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed use margin{[=true$\vert$false]}]^^A
% to use the magin to display line numbers
% and tag names, or not,
%    \begin{MacroCode}[OK]
  use~margin .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed blockskip]^^A
% the separation with the surrounding text, above and below.
% Initially |\topsep|.
%    \begin{MacroCode}[OK]
  blockskip .code:n = \CDR_tag_set:,
  blockskip .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% the separation with the surrounding text.
% Initially |\topsep|.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    tags = ,
    show~tags = true,
    only~top = true,
    use~margin = true,
    numbers~format = {
      \sffamily
      \scriptsize
      \color{gray}
    },
    tags~format = {
      \bfseries
    },
    blockskip = \topsep,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { default.block } { __initialize }
}
%    \end{MacroCode}
%
% \subsection{\pkg{fancyvrb}}
% These are \pkg{fancyvrb} options verbatim.
% The \pkg{fancyvrb} manual has more details, only some parts are reproduced hereafter.
% All of these options may not be relevant for all situations.
% Some of them make no sense in |code| mode, whereas others may not be
% compatible with the display engine.
%
% \subsubsection{\texttt{__fancyvrb } \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __fancyvrb } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed formatcom=\meta{command}]^^A
% execute before printing verbatim text.
% Initially empty.
%    \begin{MacroCode}[OK]
  formatcom .code:n = \CDR_tag_set:,
  formatcom .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed fontfamily=\meta{family name}]^^A
% font family to use. |tt|, |courier| and |helvetica| are pre-defined.
% Initially \texttt{tt}.
%    \begin{MacroCode}[OK]
  fontfamily .code:n = \CDR_tag_set:,
  fontfamily .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed fontsize=\meta{font size}]^^A
% size of the font to use. If you use the \pkg{relsize} package as well,
% you can require a change of the size proportional to the current one
% (for instance: |fontsize=\relsize{-2}|).
% Initially \texttt{auto}: the same as the current font.
%    \begin{MacroCode}[OK]
  fontsize .code:n = \CDR_tag_set:,
  fontsize .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed fontshape=\meta{font shape}]^^A
% font shape to use. Initially \texttt{auto}: the same as the current font.
%    \begin{MacroCode}[OK]
  fontshape .code:n = \CDR_tag_set:,
  fontshape .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed fontseries=\meta{series name}]^^A
% \LaTeX{} font ‘series’ to use.
% Initially \texttt{auto}: the same as the current font.
%    \begin{MacroCode}[OK]
  fontseries .code:n = \CDR_tag_set:,
  fontseries .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed showspaces{[=true$\vert$false]}]^^A
% print a special character representing each space.
% Initially |false|: spaces not shown.
%    \begin{MacroCode}[OK]
  showspaces .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed showtabs=true$\vert$false]^^A
% explicitly show tab characters.
% Initially |false|: tab characters not shown.
%    \begin{MacroCode}[OK]
  showtabs .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed obeytabs=true$\vert$false]^^A
% position characters according to the tabs.
% Initially false: tab characters are added to the current position.
%    \begin{MacroCode}[OK]
  obeytabs .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed tabsize=\meta{integer}]^^A
% number of spaces given by a tab character,
% Initially 2 (8 for \pkg{fancyvrb}).
%    \begin{MacroCode}[OK]
  tabsize .code:n = \CDR_tag_set:,
  tabsize .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed defineactive=\meta{macro}]^^A
% to define the effect of active characters.
% This allows to do some devious tricks, see the \pkg{fancyvrb} package.
% Initially empty.
%    \begin{MacroCode}[OK]
  defineactive .code:n = \CDR_tag_set:, 
  defineactive .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen reflabel=\meta{label}]^^A
% define a label to be used with |\pageref|.
% Initially empty.
%    \begin{MacroCode}[OK]
  reflabel .code:n = \CDR_tag_set:, 
  reflabel .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    formatcom = ,
    fontfamily = tt,
    fontsize = auto,
    fontseries = auto,
    fontshape = auto,
    showspaces = false,
    showtabs = false,
    obeytabs = false,
    tabsize = 2,
    defineactive = ,
    reflabel = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __fancyvrb } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__fancyvrb.block} \pkg{l3keys} module}
%
% Block specific options, except numbering.
%    \begin{MacroCode}[OK]
\regex_const:Nn \c_CDR_integer_regex { ^(+|-)?\d+$ } \use_none:n { $ }
\CDR_tag_keys_define:nn { __fancyvrb.block } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed frame=none$\vert$leftline$\vert$topline$\vert$bottomline$\vert$lines$\vert$single]^^A
% type of frame around the verbatim environment.
% With \texttt{leftline} and \texttt{single} modes, a space of a length given
% by the \LaTeX{} |\fboxsep| macro is added between the left vertical line
% and the text. Initially \texttt{none}: no frame.
%    \begin{MacroCode}[OK]
  frame .choices:nn =
    { none, leftline, topline, bottomline, lines, single }
    { \CDR_tag_choices_set: },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed label={\{[\meta{top string}]^^A
%\meta{string}\}}]
% label(s) to print on top, bottom or both, frame lines.
% If the label(s) contains special characters, comma or equal sign,
% it must be placed inside a group.
% If an optional \metatt{top string} is given between square brackets,
% it will be used for the top line and \metatt{string} for the bottom line.
% Otherwise, \metatt{string} is used for both the top or bottom lines.
% Label(s) are printed only if the \texttt{frame} parameter is one of
% \texttt{topline}, \texttt{bottomline}, \texttt{lines} or \texttt{single}.
% Initially empty: no label.
%    \begin{MacroCode}[OK]
  label .code:n = \CDR_tag_set:,
  label .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed labelposition=none$\vert$topline$\vert$bottomline$\vert$all]^^A
% position where to print the label(s) when defined.
% When options happen to be contradictory,
% like |frame=topline| and  |labelposition=bottomline|,
% nothing is displayed.
% Initially |none| when no labels are defined,
% |topline| for one label and |all| otherwise.
%    \begin{MacroCode}[OK]
  labelposition .choices:nn =
    { none, topline, bottomline, all }
    { \CDR_tag_choices_set: },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed baselinestretch=auto$\vert$\meta{dimension}]^^A
% value to give to the usual \cs{baselinestretch} \LaTeX{} parameter.
% Initially \texttt{auto}: its current value just before the verbatim command.
%    \begin{MacroCode}[OK]
  baselinestretch .code:n = \CDR_tag_set:, 
  baselinestretch .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckProhibited commandchars=\meta{three characters}]^^A
% characters which define the character which starts a macro and marks the
% beginning and end of a group; thus lets us introduce escape sequences in
% verbatim code. Of course, it is better to choose special characters which
% are not used in the verbatim text.
% Private to \pkg{coder}, unavailable to users.
% \itemtt[\CDRCheckRed xleftmargin=\meta{dimension}]^^A
% indentation to add at the start of each line.
% Initially |0pt|: no left margin.
%    \begin{MacroCode}[OK]
  xleftmargin .code:n = \CDR_tag_set:, 
  xleftmargin .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed xrightmargin=\meta{dimension}]^^A
% right margin to add after each line.
% Initially |0pt|: no right margin.
%    \begin{MacroCode}[OK]
  xrightmargin .code:n = \CDR_tag_set:, 
  xrightmargin .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed resetmargins{[=true$\vert$false]}]^^A
% reset the left margin, which is useful if we are inside other indented environments.
% Initially |true|.
%    \begin{MacroCode}[OK]
  resetmargins .code:n = \CDR_tag_boolean_set:x { #1 }, 
%    \end{MacroCode}
% \itemtt[\CDRCheckRed hfuzz=\meta{dimension}]^^A
% value to give to the \TeX{} |\hfuzz| dimension for text to format.
% This can be used to avoid seeing some unimportant overfull box messages.
% Initially 2pt.
%    \begin{MacroCode}[OK]
  hfuzz .code:n = \CDR_tag_set:, 
  hfuzz .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed samepage{[=true$\vert$false]}]^^A
% in very special circumstances, we may want to make sure that a verbatim environment
% is not broken, even if it does not fit on the current page.
% To avoid a page break, we can set the samepage parameter to |true|.
% Initially |false|.
%    \begin{MacroCode}[OK]
  samepage .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    frame = none,
    label = ,
    labelposition = none,% auto?
    baselinestretch = auto,
    resetmargins = true,
    xleftmargin = 0pt,
    xrightmargin = 0pt,
    hfuzz = 2pt,
    samepage = false,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __fancyvrb.block } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__fancyvrb.number} \pkg{l3keys} module}
% Block line numbering.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __fancyvrb.number } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed commentchar=\meta{character}]^^A
% lines starting with this character are ignored.
% Initially empty.
%    \begin{MacroCode}[OK]
  commentchar .code:n = \CDR_tag_set:,
  commentchar .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed gobble=\meta{integer}]^^A
% number of characters to suppress
% at the beginning of each line (from 0 to 9),
% mainly useful when environments are indented.
% Only |block| mode.
%    \begin{MacroCode}[OK]
  gobble .choices:nn = {
    0,1,2,3,4,5,6,7,8,9
  } {
    \CDR_tag_choices_set:
  },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed numbers=none$\vert$left$\vert$right]^^A
% numbering of the verbatim lines.
% If requested, this numbering is done outside the verbatim environment.
% Initially none: no numbering.
% 
%    \begin{MacroCode}[OK]
  numbers .choices:nn =
    { none, left, right }
    { \CDR_tag_choices_set: },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed numbersep=\meta{dimension}]^^A
% gap between numbers and verbatim lines.
% Initially 12pt.
%    \begin{MacroCode}[OK]
  numbersep .code:n = \CDR_tag_set:,
  numbersep .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed firstnumber=auto$\vert$last$\vert$\meta{integer}]^^A
% number of the first line.
% |last| means that the numbering is continued from the previous verbatim environment.
% If an integer is given, its value will be used to start the numbering.
% Initially \texttt{auto}: numbering starts from 1.
%    \begin{MacroCode}[OK]
  firstnumber .code:n = {
    \regex_match:NnTF \c_CDR_integer_regex { #1 } {
      \CDR_tag_set:
    } {
      \str_case:nnF { #1 } {
        { auto } { \CDR_tag_set: }
        { last } { \CDR_tag_set: }
      } {
        \PackageWarning
          { CDR }
          { Value~`#1'~not~in~auto,~last. }
      }
    }
  },
  firstnumber .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed stepnumber=\meta{integer}]^^A
% interval at which line numbers are printed.
% Initially 1: all lines are numbered.
%    \begin{MacroCode}[OK]
  stepnumber .code:n = \CDR_tag_set:,
  stepnumber .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed numberblanklines{[=true$\vert$false]}]^^A
% to number or not the white lines (really empty or containing blank characters only).
% Initially |true|: all lines are numbered.
%    \begin{MacroCode}[OK]
  numberblanklines .code:n = \CDR_tag_boolean_set:x { #1 },
%    \end{MacroCode}
% \itemtt[\CDRCheckRed firstline=\meta{integer}]^^A
% first line to print.
% Initially empty: all lines from the first are printed.
%    \begin{MacroCode}[OK]
  firstline .code:n = \CDR_tag_set:,
  firstline .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed lastline=\meta{integer}]^^A
% last line to print.
% Initially empty: all lines until the last one are printed.
%    \begin{MacroCode}[OK]
  lastline .code:n = \CDR_tag_set:,
  lastline .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    commentchar = ,
    gobble = 0,
    numbers = left,
    numbersep = \hspace{1ex},
    firstnumber = auto,
    stepnumber = 1,
    numberblanklines = true,
    firstline = ,
    lastline = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __fancyvrb.number } { __initialize }
}
%    \end{MacroCode}
%
% \subsubsection{\texttt{__fancyvrb.all }
% \pkg{l3keys} module}
% Options available when \pkg{pygments} is not used.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __fancyvrb.all } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed commandchars=\meta{three characters}]^^A
% characters that define the character that starts a macro and marks the beginning
% and end of a group; allows to introduce escape sequences in the verbatim code.
% Of course, it is better to choose special characters that are not used in
% the verbatim text!
% Initially |none|.
% Ignored in \pkg{pygments} mode.
%    \begin{MacroCode}[OK]
  commandchars .code:n = \CDR_tag_set:, 
  commandchars .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed codes=\meta{macro}]^^A
% to specify catcode changes.
% For instance, this allows us to include formatted mathematics in verbatim text.
% Initially empty.
% Ignored in \pkg{pygments} mode.
%    \begin{MacroCode}[OK]
  codes .code:n = \CDR_tag_set:, 
  codes .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Initialization.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    commandchars = ,
    codes = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
\AtBeginDocument{
  \CDR_tag_keys_set:nn { __fancyvrb.all } { __initialize }
}
%    \end{MacroCode}
%
% \section{\cs{CDRSet}}
% \begin{function}{\CDRSet}
% \begin{syntax}
% \cs{CDRSet} \Arg{key[=value] list}
% \cs{CDRSet} \{only description=true, font family=tt\}
% \cs{CDRSet} \{tag/default.code/font family=sf\}
% \end{syntax}
% To set up the package. This is executed at least once at the end of the preamble.
% The unique mandatory argument of \cs{CDRSet} is a
% list of \texttt{\meta{key}[=\meta{value}]} items defined by
% the \texttt{CDR@Set} \pkg{l3keys} module.
% \end{function}
%
% \subsection{\texttt{CDR@Set} \pkg{l3keys} module}
%    \begin{MacroCode}[OK]
\keys_define:nn { CDR@Set } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed only description]^^A
% to typeset only the description
% section and ignore the implementation section.
%    \begin{MacroCode}[OK]
  only~description .choices:nn = { false, true, {} } {
    \int_compare:nNnTF \l_keys_choice_int = 1 {
      \prg_set_conditional:Nnn \CDR_if_only_description: { p, T, F, TF } { \prg_return_true: }
    } {
      \prg_set_conditional:Nnn \CDR_if_only_description: { p, T, F, TF } { \prg_return_false: }
    }
  },
  only~description .initial:n = false,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed python path]^^A
% if automatic processing is not available, manually setting the path
% to the |python| utility is required. Giving a void path forces an automatic
% guess using |which|.
%    \begin{MacroCode}[OK]
  python~path .code:n = {
    \str_set:Nn \l_CDR_str { #1 }
    \lua_now:n { CDR:set_python_path('l_CDR_str') }
  },
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%
% \subsection{Branching}
% \begin{function}[pTF]{\CDR_if_only_description:}
% \begin{syntax}
% \cs{CDR_if_only_description:TF} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} when only the description is expected,
% \metatt{false code} otherwise.
% \emph{Implementation detail}: the functions are defined as part
% of the \texttt{CDR@Set} \pkg{l3keys} module.
% \end{function}
%
% \subsection{Implementation}
% \begin{function}{\CDR_check_unknown:N}
% \begin{syntax}
% \cs{CDR_check_unknown:N} \marg{tl variable}
% \end{syntax}
% In normal situation, the argument is expected to be empty.
% When the argument is not empty, send a package warning for each key. 
% \end{function}
%    \begin{MacroCode}[OK]
\exp_args_generate:n { xV, nnV }
\cs_new:Npn \CDR_check_unknown:N #1 {
  \tl_if_empty:NF #1 {
    \cs_set:Npn \CDR_check_unknown:n ##1 {
      \PackageWarning
        { coder }
        { Unknow~key~`##1' }
    }
    \cs_set:Npn \CDR_check_unknown:nn ##1 ##2 {
      \CDR_check_unknown:n { ##1 }
    }
    \exp_args:NnnV
    \keyval_parse:nnn {
      \CDR_check_unknown:n
    } {
      \CDR_check_unknown:nn
    } #1
  }
}
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRSet { m } {
  \CDR_keys_set_known:nnN { CDR@Set } { #1 } \l_CDR_keyval_tl
  \clist_map_inline:nn {
    __pygments, __pygments.block,
    default.block, default.code, default,
    __fancyvrb, __fancyvrb.block, __fancyvrb.all
  } {
    \CDR_tag_keys_set_known:nVN { ##1 } \l_CDR_keyval_tl \l_CDR_keyval_tl
  }
  \CDR_keys_set_known:VVN \c_CDR_Tags \l_CDR_keyval_tl \l_CDR_keyval_tl
  \CDR_tag_provide_from_keyval:V \l_CDR_keyval_tl
  \CDR_keys_set_known:VVN \c_CDR_Tags \l_CDR_keyval_tl \l_CDR_keyval_tl
  \CDR_tag_keys_set:nV { default } \l_CDR_keyval_tl
}
%    \end{MacroCode}
%
%
% \section{\cs{CDRExport}}
% \begin{function}{\CDRExport}
% \begin{syntax}
% \cs{CDRExport} \Arg{key[=value] controls}
% \end{syntax}
% The \texttt{\meta{key}[=\meta{value}]} controls are defined by
% \texttt{CDR@Export} \pkg{l3keys} module.
% \end{function}
%
% \subsection{Storage}
%
% \begin{function}[EXP]{\CDR_export_get_path:cc}
% \begin{syntax}
% \cs{CDR_tag_export_path:cc} \Arg{file name} \Arg{relative key path}
% \end{syntax}
% Internal: return a unique key based on the arguments.
% Used to store and retrieve values.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_export_get_path:cc #1 #2 {
  CDR @ export @ get @ #1 / #2
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_export_set:ccn, \CDR_export_set:Vcn, \CDR_export_set:VcV}
% \begin{syntax}
% \cs{CDR_export_set:ccn} \Arg{file name} \Arg{relative key path} \Arg{value}
% \end{syntax}
% Store \metatt{value}, which is further retrieved with the instruction
% |\CDR_get_get:cc {|\metatt{file name}|}| \linebreak[3]|{|\metatt{relative key path}|}|.
% All the affectations are made at the current \TeX{} group level.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new_protected:Npn \CDR_export_set:ccn #1 #2 #3 {
  \cs_set:cpn { \CDR_export_get_path:cc { #1 } { #2 } } { \exp_not:n { #3 } }
}
\cs_new_protected:Npn \CDR_export_set:Vcn #1 {
  \exp_args:NV
  \CDR_export_set:ccn { #1 }
}
\cs_new_protected:Npn \CDR_export_set:VcV #1 #2 #3 {
  \exp_args:NVnV
  \CDR_export_set:ccn #1 { #2 } #3
}
%    \end{MacroCode}
%
% \begin{function}[TF,EXP]{\CDR_export_if_exist:cc}
% \begin{syntax}
% \cs{CDR_export_if_exist:ccTF} \Arg{file name} \meta{relative key path} \Arg{true code} \Arg{false code}
% \end{syntax}
% If the \metatt{relative key path} is known within \metatt{file name},
% the \metatt{true code} is executed,
% otherwise, the \metatt{false code} is executed.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_export_if_exist:cc { p, T, F, TF } {
  \cs_if_exist:cTF { \CDR_export_get_path:cc { #1 } { #2 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \begin{function}[EXP]{\CDR_export_get:cc}
% \begin{syntax}
% \cs{CDR_export_get:cc} \Arg{file name} \Arg{relative key path}
% \end{syntax}
% The property value stored for \metatt{file name}
% and \metatt{relative key path}.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_export_get:cc #1 #2 {
  \CDR_export_if_exist:ccT { #1 } { #2 } {
    \use:c { \CDR_export_get_path:cc { #1 } { #2 } }
  }
}
%    \end{MacroCode}
%
% \begin{function}[TF]{\CDR_export_get:ccN}
% \begin{syntax}
% \cs{CDR_export_get:ccNTF} \Arg{file name} \Arg{relative key path}
% \meta{tl var} \Arg{true code} \Arg{false code}
% \end{syntax}
% Get the property value stored for \metatt{file name}
% and \metatt{relative key path}, copy it to \metatt{tl var}.
% Execute \metatt{true code} on success, \metatt{false code} otherwise.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_protected_conditional:Nnn \CDR_export_get:ccN { T, F, TF } {
  \CDR_export_if_exist:ccTF { #1 } { #2 } {
    \tl_set:Nx #3 { \CDR_export_get:cc { #1 } { #2 } }
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \subsection{Storage}
%
% \begin{variable}{\g_CDR_export_prop}
% Global storage for \texttt{\meta{file name}=\meta{file export info}}
%    \begin{MacroCode}[OK]
\prop_new:N \g_CDR_export_prop
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\l_CDR_file_tl}
% Store the file name used for exportation, used as key in the above property list.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_file_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\l_CDR_tags_clist, \g_CDR_tags_clist}
% Used by \texttt{CDR@Export} \pkg{l3keys} module to temporarily store tags
% during the export declaration.
%    \begin{MacroCode}[OK]
\clist_new:N \l_CDR_tags_clist
\clist_new:N \g_CDR_tags_clist
%    \end{MacroCode}
% \end{variable}
%
% \begin{variable}{\l_CDR_export_prop}
% Used by \texttt{CDR@Export} \pkg{l3keys} module to temporarily store properties.
% \emph{Nota Bene}: nothing similar with |\g_CDR_export_prop| except the name.
%    \begin{MacroCode}[OK]
\prop_new:N \l_CDR_export_prop
%    \end{MacroCode}
% \end{variable}
%
% \subsection{\texttt{CDR@Export} \pkg{l3keys} module}
% No initial value is given for every key.
% An |__initialize| action will set the storage with proper initial values.
%    \begin{MacroCode}[OK]
\keys_define:nn { CDR@Export } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed file=\meta{name}]^^A
% the output file name, must be provided otherwise an error is raised.
%    \begin{MacroCode}[OK]
  file .tl_set:N = \l_CDR_file_tl,
  file .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed tags=\meta{tags comma list}]^^A
% the list of tags. No exportation when this list is void.
% Initially empty.
%    \begin{MacroCode}[OK]
  tags .code:n = {
    \clist_set:Nn \l_CDR_tags_clist { #1 }
    \clist_remove_duplicates:N \l_CDR_tags_clist
    \prop_put:NVV \l_CDR_prop \l_keys_key_str \l_CDR_tags_clist
  },
  tags .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed lang]^^A
% one of the languages \pkg{pygments} is aware of.
% Initially |tex|.
%    \begin{MacroCode}[OK]
  lang .code:n = {
    \prop_put:NVn \l_CDR_prop \l_keys_key_str { #1 }
  },
  lang .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed preamble]^^A
% the added preamble.
% Initially empty.
%    \begin{MacroCode}[OK]
  preamble .code:n = {
    \prop_put:NVn \l_CDR_prop \l_keys_key_str { #1 }
  },
  preamble .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed postamble]^^A
% the added postamble.
% Initially empty.
%    \begin{MacroCode}[OK]
  postamble .code:n = {
    \prop_put:NVn \l_CDR_prop \l_keys_key_str { #1 }
  },
  postamble .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed raw{[=true$\vert$false]}]^^A
% true to remove any additional material, false otherwise.
% Initially |false|.
%    \begin{MacroCode}[OK]
  raw .choices:nn = { false, true, {} } {
    \prop_put:NVx \l_CDR_prop \l_keys_key_str {
      \int_compare:nNnTF
        \l_keys_choice_int = 1 { false } { true }
    }
  },
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize]^^A
% Meta key to properly initialize all the variables.
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    __initialize_prop = #1,
    file=,
    tags=,
    lang=tex,
    preamble=,
    postamble=,
    raw=false,
  },
  __initialize .default:n = \l_CDR_export_prop,
%    \end{MacroCode}
% \itemtt[\CDRCheckGreen __initialize_prop]^^A
% Goody: properly initialize the local property storage.
%    \begin{MacroCode}[OK]
  __initialize_prop .code:n = \prop_clear:N #1,
  __initialize_prop .value_required:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
% 
% \subsection{Implementation}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRExport { m } {
  \keys_set:nn { CDR@Export } { __initialize }
  \keys_set:nn { CDR@Export } { #1 }
  \tl_if_empty:NTF \l_CDR_file_tl {
    \PackageWarning
      { coder }
      { Missing~key~`file' }
  } {
    \CDR_export_set:VcV \l_CDR_file_tl { file } \l_CDR_file_tl
    \prop_map_inline:Nn \l_CDR_prop {
      \CDR_export_set:Vcn \l_CDR_file_tl { ##1 } { ##2 }
    }
%    \end{MacroCode}
% The list of tags must not be empty, raise an error otherwise.
% Records the list in |\g_CDR_tags_clist|, it will be the default list
% of forthcoming code blocks.
%    \begin{MacroCode}[OK]
    \tl_if_empty:NTF \l_CDR_tags_clist {
      \PackageWarning
        { coder }
        { Missing~key~`tags' }
    } {
      \clist_set_eq:NN \g_CDR_tags_clist \l_CDR_tags_clist
      \CDR_export_set:VcV \l_CDR_file_tl { file } \l_CDR_file_tl
%    \end{MacroCode}
% If a |lang| is given, forwards the declaration
% to all the code chunks tagged within |\l_CDR_tags_clist|.
%    \begin{MacroCode}[OK]
      \exp_args:NV
      \CDR_export_get:ccNT \l_CDR_file_tl { lang } \l_CDR_tl {
        \clist_map_inline:Nn \l_CDR_tags_clist {
          \CDR_tag_set:ccV { ##1 } { lang } \l_CDR_tl
        }
      }
    }
  }
}
%    \end{MacroCode}
%
% Files are created at the end of the typesetting process.
%    \begin{MacroCode}[OK]
\AddToHook { enddocument / end } {
  \prop_map_inline:Nn \g_CDR_export_prop {
    \tl_set:Nn \l_CDR_prop { #2 }
    \str_set:Nx \l_CDR_str {
      \prop_item:Nn \l_CDR_prop { file }
    }
    \lua_now:n { CDR:export_file('l_CDR_str') }
    \clist_map_inline:nn {
      tags, raw, preamble, postamble
    } {
      \str_set:Nx \l_CDR_str {
        \prop_item:Nn \l_CDR_prop { ##1 }
      }
      \lua_now:n {
        CDR:export_file_info('##1','l_CDR_str')
      }
    }
    \lua_now:n { CDR:export_file_complete() }
  }
}
%    \end{MacroCode}
%
% \section{Style}
% \pkg{pygments}, through \CDRPy{}, creates style commands,
% but the storage is managed on the \LaTeX{} side by \CDRSty{}.
% This is a \LaTeX{} style API.
%
% \begin{function}{\CDR@StyleDefine}
% \begin{syntax}
% \cs{CDR@StyleDefine} \Arg{pygments style name} \Arg{definitions}
% \end{syntax}
% Define the definitions for the given \metatt{pygments style name}.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDR@StyleDefine #1 {
  \tl_gset:cn { g_CDR@Style/#1 }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR@StyleUse, CDR@StyleUseTag}
% \begin{syntax}
% \cs{CDR@StyleUse} \Arg{pygments style name}
% \cs{CDR@StyleUseTag}
% \end{syntax}
% Use the definitions for the given \metatt{pygments style name}.
% No safe check is made.
% The |\CDR@StyleUseTag| version finds the \metatt{pygments style name}
% from the context. It is defined locally.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \CDR@StyleUse #1 {
  \tl_use:c { g_CDR@Style/#1 }
}
%    \end{MacroCode}
%
% \begin{function}{\CDR@StyleExist}
% \begin{syntax}
% \cs{CDR@StyleExist} \Arg{pygments style name} \Arg{true code} \Arg{false code}
% \end{syntax}
% Execute \metatt{true code} if a style exists with that given name,
% \metatt{false code} otherwise.
% \end{function}
%    \begin{MacroCode}
\prg_new_conditional:Nnn \CDR@StyleIfExist:c { TF } {
  \tl_if_exist:cTF { g_CDR@Style/#1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\cs_set_eq:NN \CDR@StyleIfExist \CDR@StyleIfExist:cTF
%    \end{MacroCode}
%
% \section{Creating display engines}
% \subsection{Utilities}
% \begin{function}[EXP]{\CDR_code_engine:c, \CDR_code_engine:V, \CDR_block_engine:c, \CDR_block_engine:V}
% \begin{syntax}
% \cs{CDR_code_engine:c} \Arg{engine name}
% \cs{CDR_block_engine:c} \Arg{engine name}
% \end{syntax}
% |\CDR_code_engine:c| builds a command sequence name
% based on \metatt{engine name}.
% |\CDR_block_engine:c| builds an environment name
% based on \metatt{engine name}.
%\end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_code_engine:c #1 {
  CDR@colored/code/#1:nn
}
\cs_new:Npn \CDR_block_engine:c #1 {
  CDR@colored/block/#1
}
\cs_new:Npn \CDR_code_engine:V {
  \exp_args:NV \CDR_code_engine:c
}
\cs_new:Npn \CDR_block_engine:V {
  \exp_args:NV \CDR_block_engine:c
}
%    \end{MacroCode}
%
% \begin{variable}{\l_CDR_engine_tl}
% Storage for an engine name.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_engine_tl
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}{\CDRGetOption}
% \begin{syntax}
% \cs{CDRGetOption} \Arg{relative key path}
% \end{syntax}
% Returns the value given to |\CDRCode| command or |CDRBlock| environment
% for the \metatt{relative key path}.
% This function is only available during |\CDRCode| execution
% and inside |CDRBlock| environment.
% \end{function}
%
% \subsection{Implementation}
% \begin{function}{\CDRCodeEngineNew, \CDRCodeEngineRenew}
% \begin{syntax}
% \cs{CDRCodeEngineNew}  \Arg{engine name}\Arg{engine body}
% \cs{CDRCodeEngineRenew}\Arg{engine name}\Arg{engine body}
% \end{syntax}
% \metatt{engine name} is a non void string, once expanded.
% The \metatt{engine body} is a list of instructions which may refer to
% the first argument as |#1|,
% which is the value given for key \metatt{engine name}| engine options|,
% and the second argument as |#2|, which is the colored code.
% \end{function}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRCodeEngineNew { mm } {
  \exp_args:Nx
  \tl_if_empty:nTF { #1 } {
    \PackageWarning
      { coder }
      { The~engine~cannot~be~void. }
  } {
    \cs_new:cpn { \CDR_code_engine:c {#1} } ##1 ##2 {
      \cs_set_eq:NN \CDRGetOption \CDR_tag_get:c
      #2
    }
    \ignorespaces
  }
}
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRCodeEngineRenew { mm } {
  \exp_args:Nx
  \tl_if_empty:nTF { #1 } {
    \PackageWarning
      { coder }
      { The~engine~cannot~be~void. }
      \use_none:n
  } {
    \cs_if_exist:cTF { \CDR_code_engine:c { #1 } } {
      \cs_set:cpn { \CDR_code_engine:c { #1 } } ##1 ##2 {
        \cs_set_eq:NN \CDRGetOption \CDR_tag_get:c
        #2
      }
    } {
      \PackageWarning
        { coder }
        { No~code~engine~#1.}
    }
    \ignorespaces
  }
}
%    \end{MacroCode}
% \begin{function}{\CDR@CodeEngineApply}
% \begin{syntax}
% \cs{CDR@CodeEngineApply} \Arg{source}
% \end{syntax}
% Get the code engine and apply it to the given \metatt{source}.
% When the code engine is not recognized, an error is raised.
% \emph{Implementation detail}: the argument is parsed by the last macro.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR@CodeEngineApply #1 {
  \CDR_tag_get:cN { engine } \l_CDR_engine_tl
  \CDR_if_code_engine:VF \l_CDR_engine_tl {
    \PackageError
      { coder }
      { \l_CDR_engine_tl\space code~engine~unknown,~replaced~by~'default' }
      {See~\CDRCodeEngineNew~in~the~coder~manual}
    \tl_set:Nn \l_CDR_engine_tl { default }
  }
  \tl_set:Nf \l_CDR_options_tl {
    \CDR_tag_get:c { engine~options }
  }
  \tl_if_empty:NTF \l_CDR_options_tl {
    \tl_set:Nf \l_CDR_options_tl {
      \CDR_tag_get:c { \l_CDR_engine_tl\space engine~options }
    }
  } {
    \tl_put_left:Nx \l_CDR_options_tl {
      \CDR_tag_get:c { \l_CDR_engine_tl\space engine~options } ,
    }
  }
  \exp_args:NnV
  \use:c { \CDR_code_engine:V \l_CDR_engine_tl } \l_CDR_options_tl {
    \CDR_tag_get:c { format }
    #1
  }
}
%    \end{MacroCode}
% \begin{function}{\CDRBlockEngineNew, \CDRBlockEngineRenew}
% \begin{syntax}
% \cs{CDRBlockEngineNew}   \Arg{engine name} \Arg{begin instructions} \Arg{end instructions}
% \cs{CDRBlockEngineRenew} \Arg{engine name} \Arg{begin instructions} \Arg{end instructions}
% \end{syntax}
% Create a \LaTeX{} environment uniquely named after \metatt{engine name},
% which must be a non void string once expanded.
% The \metatt{begin instructions} and \metatt{end instructions}
% are list of instructions which may refer to the unique argument as |#1|,
% which is the value given to |CDRBlock| environment
% for key \metatt{engine name}| engine options|.
% Various options are available with the |\CDRGetOption| function.
% \emph{Implementation detail}: the third argument is parsed by
% |\NewDocumentEnvironment|.
% \end{function}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRBlockEngineNew { mm } {
  \NewDocumentEnvironment { \CDR_block_engine:c { #1 } } { m } {
    \cs_set_eq:NN \CDRGetOption \CDR_tag_get:c
    #2
  }
}
%    \end{MacroCode}
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRBlockEngineRenew { mm } {
  \tl_if_empty:nTF { #1 } {
    \PackageWarning
      { coder }
      { The~engine~cannot~be~void. }
      \use_none:n
  } {
    \RenewDocumentEnvironment { \CDR_block_engine:c { #1 } } { m } {
      \cs_set_eq:NN \CDRGetOption \CDR_tag_get:c
      #2
    }
  }
}
%    \end{MacroCode}
%
% \subsection{Conditionals}
%
% \begin{function}[EXP,TF]{\CDR_if_code_engine:c}
% \begin{syntax}
% \cs{CDR_if_code_engine:cTF} \Arg{engine name} \Arg{true code} \Arg{false code}
% \end{syntax}
% If there exists a code engine with the given \metatt{engine name},
% execute \metatt{true code}.
% Otherwise, execute \metatt{false code}.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_code_engine:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDR_code_engine:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDR_if_code_engine:V { p, T, F, TF } {
  \cs_if_exist:cTF { \CDR_code_engine:V #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \begin{function}[EXP,TF]{\CDR_if_block_engine:c}
% \begin{syntax}
% \cs{CDR_if_block_engine:c} \Arg{engine name} \Arg{true code} \Arg{false code}
% \end{syntax}
% If there exists a block engine with the given \metatt{engine name},
% execute \metatt{true code}, otherwise, execute \metatt{false code}.
% \end{function}
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_block_engine:c { p, T, F, TF } {
  \cs_if_exist:cTF { \CDR_block_engine:c { #1 } } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
\prg_new_conditional:Nnn \CDR_if_block_engine:V { p, T, F, TF } {
  \cs_if_exist:cTF { \CDR_block_engine:V #1 } {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
%
% \subsection{Default code engine}
% The default code engine does nothing special and forwards its argument as is.
%    \begin{MacroCode}[OK]
\CDRCodeEngineNew { default } { #2 }
%    \end{MacroCode}
% 
% \subsection{Default block engine}
% The default block engine does nothing.
%    \begin{MacroCode}[OK]
\CDRBlockEngineNew { default } { } { }
%    \end{MacroCode}
% 
% \subsection{\pkg{efbox} code engine}
%    \begin{MacroCode}
\AtBeginDocument {
  \@ifpackageloaded{efbox} {
    \CDRCodeEngineNew {efbox} {
      \efbox[#1]{#2}%
    }
  }
}
%    \end{MacroCode}
% \subsection{Block mode default engine}
%    \begin{MacroCode}
\CDRBlockEngineNew {} {
} {
}
%    \end{MacroCode}
%
% \subsection{\pkg{tcolorbox} related engine}
% If the \pkg{tcolorbox} is loaded, related code and block engines are available.
% 
% \section{\cs{CDRCode} function}
%
% \subsection{API}
% \begin{function}{\CDRCode}
% \begin{syntax}
% \cs{CDRCode}\Arg{key[=value]}\meta{delimiter}\meta{code}\meta{same delimiter}
% \end{syntax}
% Public method to declare inline code.
% \end{function}
%
% \subsection{Storage}
% \begin{variable}{\l_CDR_tag_tl}
% To store the tag given.
%    \begin{MacroCode}[OK]
\tl_new:N \l_CDR_tag_tl
%    \end{MacroCode}
% \end{variable}
%
% \subsection{\texttt{__code} \pkg{l3keys} module}
% This is the module used to parse the user interface of the \cs{CDRCode} command.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __code } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckGreen tag=\meta{name}]^^A
% to use the settings of the already existing named tag to display.
%    \begin{MacroCode}[OK]
  tag .tl_set:N = \l_CDR_tag_tl,
  tag .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed engine options=\meta{engine options}]^^A
% options forwarded to the engine. They are appended to the options
% given with key \metatt{engine name}| engine options|.
%    \begin{MacroCode}[OK]
  engine~options .code:n = \CDR_tag_set:,
  engine~options .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% initialize
%    \begin{MacroCode}[OK]
  __initialize .meta:n = { 
    tag = default,
    engine~options = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%
% \subsection{Implementation}
%
% \begin{function}{\CDR_code_format:}
% \begin{syntax}
% \cs{CDR_code_format:}
% \end{syntax}
% Private utility to setup the formatting.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_brace_if_contains_comma:n #1 {
  \tl_if_in:nnTF { #1 } { , } { { #1 } } { #1 }
}
\cs_generate_variant:Nn \CDR_brace_if_contains_comma:n { V }
\cs_new:Npn \CDR_code_format: {
  \frenchspacing
  \CDR_tag_get:cN { baselinestretch } \l_CDR_tl
  \tl_if_eq:NnF \l_CDR_tl { auto } {
    \exp_args:NNV
    \def \baselinestretch \l_CDR_tl
  }
  \CDR_tag_get:cN { fontfamily } \l_CDR_tl
  \tl_if_eq:NnT \l_CDR_tl { tt } { \tl_set:Nn \l_CDR_tl { lmtt } }
  \exp_args:NV
  \fontfamily \l_CDR_tl
  \clist_map_inline:nn { series, shape } {
    \CDR_tag_get:cN { font##1 } \l_CDR_tl
    \tl_if_eq:NnF \l_CDR_tl { auto } {
      \exp_args:NnV
      \use:c { font##1 } \l_CDR_tl
    }
  }
  \CDR_tag_get:cN { fontsize } \l_CDR_tl
  \tl_if_eq:NnF \l_CDR_tl { auto } {
    \tl_use:N \l_CDR_tl
  }
  \selectfont
%  \@noligs ?? this is in fancyvrb but does not work here as is
}
%    \end{MacroCode}
%
% \begin{function}{\CDR_code:n}
% \begin{syntax}
% \cs{CDR_code:n} \meta{delimiter}
% \end{syntax}
% Main utility used by |\CDRCode|.
% \end{function}
%    \begin{MacroCode}[OK]
\cs_new:Npn \CDR_code:n #1 {
  \CDR_if_tag_truthy:cTF {pygments} {
    \cs_set:Npn \CDR@StyleUseTag {
      \CDR@StyleUse { \CDR_tag_get:c { style } }
      \cs_set:Npn \CDR@StyleUseTag \prg_do_nothing:
    }
    \CDR_keys_inherit:Vnn \c_CDR_tag { __local } {
      __fancyvrb,
    }
    \CDR_tag_keys_set:nV { __local } \l_CDR_keyval_tl
    \DefineShortVerb { #1 }
    \SaveVerb [
      aftersave = {
        \UndefineShortVerb { #1 }
        \lua_now:n { CDR:hilight_code_prepare() }
        \CDR_tag_get:cN {lang} \l_CDR_tl
        \lua_now:n { CDR:hilight_set_var('lang') }
        \CDR_tag_get:cN {cache} \l_CDR_tl
        \lua_now:n { CDR:hilight_set_var('cache') }
        \CDR_tag_get:cN {debug} \l_CDR_tl
        \lua_now:n { CDR:hilight_set_var('debug') }
        \CDR_tag_get:cN {style} \l_CDR_tl
        \lua_now:n { CDR:hilight_set_var('style') }
        \CDR@StyleIfExist { \l_CDR_tl } {
          \lua_now:n { CDR:hilight_set('ignore_style', 'true') }
        } { }
        \lua_now:n { CDR:hilight_set_var('source', 'FV@SV@CDR@Source') }
        \CDR_code_format:
        \FV@UseKeyValues
        \frenchspacing
        %  \FV@SetupFont Break
        \FV@DefineWhiteSpace
        \FancyVerbDefineActive
        \FancyVerbFormatCom
        \CDR_tag_get:c { format }
        \lua_now:n { CDR:hilight_code() }
        \group_end:
      }
    ] { CDR@Source } #1
  } {
    \exp_args:NV \fvset \l_CDR_keyval_tl
    \DefineShortVerb { #1 }
    \SaveVerb [
      aftersave = {
        \UndefineShortVerb { #1 }
        \cs_set_eq:NN \CDR@FormattingPrep \FV@FormattingPrep
        \cs_set:Npn \FV@FormattingPrep {
          \CDR@FormattingPrep
          \CDR_tag_get:c { format }
        }
        \CDR@CodeEngineApply { \UseVerb { CDR@Code } }
        \group_end:
      }
    ] { CDR@Code } #1
  }
}
%    \end{MacroCode}
%
%    \begin{MacroCode}[OK]
\NewDocumentCommand \CDRCode { O{} } {
  \group_begin:
  \prg_set_conditional:Nnn \CDR_if_block: { p, T, F, TF } {
    \prg_return_false:
  }  
  \CDR_keys_inherit:Vnn \c_CDR_tag { __local } {
    __code, default.code, __pygments, default,
  }
  \CDR_tag_keys_set_known:nnN { __local } { #1 } \l_CDR_keyval_tl
  \CDR_tag_provide_from_keyval:V \l_CDR_keyval_tl
  \CDR_tag_keys_set_known:nVN { __local } \l_CDR_keyval_tl \l_CDR_keyval_tl
  \exp_args:NV
  \fvset \l_CDR_keyval_tl
  \CDR_keys_inherit:Vnn \c_CDR_tag { __local } {
    __fancyvrb,
  }
  \CDR_tag_keys_set:nV { __local } \l_CDR_keyval_tl  
  \CDR_tag_inherit:cf { __local } {
    \tl_if_empty:NF \l_CDR_tag_tl { \l_CDR_tag_tl, }
    __code, default.code, __pygments, default, __fancyvrb,
  }
  \CDR_code:n
}
%    \end{MacroCode}
%
% \section{\texttt{CDRBlock} environment}
%
% \begin{environment}{CDRBlock}
% \begin{syntax}
% \cs{begin}\{CDRBlock\}\Arg{key[=value] list} ... \cs{end}\{CDRBlock\}
% \end{syntax}
% \end{environment}
%
%
% \subsection{Storage}
% \begin{variable}{\l_CDR_block_prop}
%    \begin{MacroCode}
\prop_new:N \l_CDR_block_prop
%    \end{MacroCode}
% \end{variable}
%
% \subsection{\texttt{__block} \pkg{l3keys} module}
% This module is used to parse the user interface of the |CDRBlock| environment.
%    \begin{MacroCode}[OK]
\CDR_tag_keys_define:nn { __block } {
%    \end{MacroCode}
% \begin{description}
% \itemtt[\CDRCheckRed no~export{[=true$\vert$false]}]^^A
% to ignore this code chunk at export time.
%    \begin{MacroCode}[OK]
  no~export .code:n = \CDR_tag_boolean_set:x { #1 },
  no~export .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed no export format=\metatt{format commands}]^^A
% a format appended to |tags format| and |numbers format| when |no export| is |true|..
% Initially empty.
%    \begin{MacroCode}[OK]
  no~export~format .code:n = \CDR_tag_set:,
  no~export~format .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed test{[=true$\vert$false]}]^^A
% whether the chunk is a test,
%    \begin{MacroCode}[OK]
  test .code:n = \CDR_tag_boolean_set:x { #1 },
  test .default:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed engine options=\meta{engine options}]^^A
% options forwarded to the engine. They are appended to the options
% given with key \metatt{engine name}| engine options|.
% Mainly a convenient user interface shortcut.
%    \begin{MacroCode}[OK]
  engine~options .code:n = \CDR_tag_set:,
  engine~options .value_required:n = true,
%    \end{MacroCode}
% \itemtt[\CDRCheckRed __initialize]^^A
% initialize
%    \begin{MacroCode}[OK]
  __initialize .meta:n = {
    no~export = false,
    no~export~format = ,
    test = false,
    engine~options = ,
  },
  __initialize .value_forbidden:n = true,
%    \end{MacroCode}
% \end{description}
%    \begin{MacroCode}[OK]
}
%    \end{MacroCode}
%
% \subsection{Context}
% Inside the |CDRBlock| environments,
% some local variables are available:
% \begin{description}
% \item [\CDRCheckRed \cs{l_CDR_tags_clist}]
% \end{description}
% \subsection{Implementation}
% We start by saving some \pkg{fancyvrb} macros that we further want to extend.
% The unique mandatory argument of these macros will eventually be recorded
% to be saved later on.
%    \begin{MacroCode}[OK]
\clist_map_inline:nn { i, ii, iii, iv } {
  \cs_set_eq:cc { CDR@ListProcessLine@ #1 } { FV@ListProcessLine@ #1 }
}
\cs_new:Npn \CDR_process_line:n #1 {
  \str_set:Nn \l_CDR_str { #1 }
  \lua_now:n {CDR:record_line('l_CDR_str')}
}
%    \end{MacroCode}
%
%    \begin{MacroCode}
\def\FVB@CDRBlock #1 {
  \@bsphack
  \group_begin:
  \prg_set_conditional:Nnn \CDR_if_block: { p, T, F, TF } {
    \prg_return_true:
  }  
  \CDR_tag_keys_set:nn { __block } { __initialize }
%    \end{MacroCode}
% By default, this code chunk will have the same list of tags
% as the last code block or last |\CDRExport| stored in |\g_CDR_tags_clist|. 
%    \begin{MacroCode}
  \clist_set_eq:NN \l_CDR_tags_clist \g_CDR_tags_clist
  \CDR_keys_inherit:Vnn \c_CDR_tag { __local } {
    __block, __pygments.block, default.block,
    __pygments, default,
  }
  \exp_args:NnV
  \CDR_tag_keys_set_known:nnN { __local } \FV@KeyValues \l_CDR_keyval_tl
  \CDR_tag_provide_from_keyval:V \l_CDR_keyval_tl
  \exp_args:NnV
  \CDR_tag_keys_set_known:nnN { __local } \l_CDR_keyval_tl \l_CDR_keyval_tl
  \clist_if_empty:NT \l_CDR_tags_clist {
    \PackageWarning
      { coder }
      { No~(default)~tags~provided }
  }
%    \end{MacroCode}
% |\l_CDR_pygments_bool| is |true| iff one of the tags needs \pkg{pygments}.
%    \begin{MacroCode}
  \clist_map_inline:Nn \l_CDR_tags_clist {
    \CDR_if_truthy:ccT { ##1 } { pygments } {
      \clist_map_break:n {
        \bool_set_true:N \l_CDR_pygments_bool
      }
    }
  }
  \bool_if:NTF \l_CDR_pygments_bool {
    \CDR_keys_inherit:Vnn \c_CDR_tag { __local } {
      __fancyvrb.number
    }
    \CDR_tag_keys_set_known:nVN { __local } \l_CDR_keyval_tl \l_CDR_keyval_tl
    \exp_args:NV \fvset \l_CDR_keyval_tl
    \CDR_keys_inherit:Vnn \c_CDR_tag { __local } {
      __fancyvrb, __fancyvrb.block
    }
    \exp_args:NnV
    \CDR_tag_keys_set:nn { __local } \l_CDR_keyval_tl
%    \end{MacroCode}
% Get the list of tags and setup \CDRLua{} for recording or hilighting.
%    \begin{MacroCode}  
    \CDR_tag_inherit:cf { __local } {
      \l_CDR_tags_clist,
      __block, default.block, __pygments.block, __fancyvrb.block,
       __pygments, default, __fancyvrb,
    }
    \lua_now:n {
      CDR:hilight_block_prepare('l_CDR_tags_clist')
    }
    \def\FV@KeyValues{}
    \CDR_tag_get:cN {lang} \l_CDR_tl
    \lua_now:n { CDR:hilight_set_var('lang') }
    \CDR_tag_get:cN {cache} \l_CDR_tl
    \lua_now:n { CDR:hilight_set_var('cache') }
    \CDR_tag_get:cN {debug} \l_CDR_tl
    \lua_now:n { CDR:hilight_set_var('debug') }
    \CDR_tag_get:cN {style} \l_CDR_tl
    \lua_now:n { CDR:hilight_set_var('style') }
    \CDR@StyleIfExist { \l_CDR_tl } {
      \lua_now:n { CDR:hilight_set('ignore_style', 'true') }
    } { }
  } {
    \exp_args:NNV
    \def \FV@KeyValues \l_CDR_keyval_tl
    \CDR_tag_inherit:cf { __local } {
      \l_CDR_tags_clist,
      __block, default.block, __pygments.block, __fancyvrb.block,
       __pygments, default, __fancyvrb, __fancyvrb.all,
    }
  }
  \exp_args:Nnx
  \CDR_if_tag_truthy:cTF {no~export} {
    \bool_if:NT \l_CDR_pygments_bool {
      \cs_map_inline:nn { i, ii, iii, iv } {
        \cs_set:cpn { FV@ListProcessLine@ ####1 } ##1 {
          \CDR_hilight_record:n { ##1 }
        }
      }
    }
  } {
    \bool_if:NTF \l_CDR_pygments_bool {
      \cs_map_inline:nn { i, ii, iii, iv } {
        \cs_set:cpn { FV@ListProcessLine@ ####1 } ##1 {
          \CDR_hilight_record:n { ##1 }
          \CDR_export_record:n { ##1 }
        }
      }
    } {
      \cs_map_inline:nn { i, ii, iii, iv } {
        \cs_set:cpn { FV@ListProcessLine@ ####1 } ##1 {
          \CDR_export_record:n { ##1 }
          \use:c { CDR@ListProcessLine@ ####1 } { ##1 }
        }
      }
    }
  }
  \CDR_tag_get:cN { \l_CDR_engine_tl~engine~options } \l_CDR_options_tl
  \tl_if_empty:NTF \l_CDR_options_tl {
%    \end{MacroCode}
% No |\begin| works here. Why?
% This may be related to the required |\relax| below.
%    \begin{MacroCode}
    \use:c { \CDR_block_engine:V \l_CDR_engine_tl }
  } {
    \exp_args:NnNV
    \use:c { \CDR_block_engine:V \l_CDR_engine_tl }
      [ \l_CDR_options_tl ]
  }
  \relax
  \cs_set_eq:NN \CDR@FormattingPrep \FV@FormattingPrep
  \cs_set:Npn \FV@FormattingPrep {
    \CDR@FormattingPrep
    \CDR_tag_get:c { format }
  }
  \FV@VerbatimBegin
  \FV@Scan
}
\def\FVE@CDRBlock{
  \FV@VerbatimEnd
  \bool_if:NT \l_CDR_pygments_bool {
    \lua_now:n { CDR:hilight_code() }
  }
  \use:c { end \CDR_block_engine:V \l_CDR_engine_tl }
  \group_end:
  \@esphack
}
\DefineVerbatimEnvironment{CDRBlock}{CDRBlock}{}

%    \end{MacroCode}
% 
%
% \section{The \texttt{\CDRPygVerbatim} environment}
% This is the environment wrapping the \pkg{pygments} generated code when in block mode.
% It is the sole content of the various |*.pyg.tex| files.
%    \begin{MacroCode}
\def\FVB@CDR@Pyg@Verbatim #1 {
  \group_begin:
  \FV@VerbatimBegin
  \FV@Scan
}
\def\FVE@CDR@Pyg@Verbatim{
  \FV@VerbatimEnd
  \group_end:
}
\DefineVerbatimEnvironment{CDR@Pyg@Verbatim}{CDR@Pyg@Verbatim}{}

%    \end{MacroCode}
% 
%
% \section{More}
% \begin{function} [EXP, TF] {\CDR_if_record:}
%   \begin{syntax}
%     \cs{CDR_if_record:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
% Execute \meta{true code} when code should be recorded, \meta{false code} otherwise.
% The code should be recorded for the |CDRBlock| environment
% when there is a non empty list of tags and \pkg{pygments} is used.
% \emph{Implementation details}: we assume that if |\l_CDR_tags_clist| is not empty
% then we are in a |CDRBlock| environment.
%    \begin{MacroCode}[OK]
\prg_new_conditional:Nnn \CDR_if_record: { T, F, TF } {
  \clist_if_empty:NTF \l_CDR_tags_clist {
    \prg_return_false:
  } {
    \CDR_if_use_pygments:TF {
      \prg_return_true:
    } {
      \prg_return_false:
    }
  }
}
%    \end{MacroCode}
% \end{function}
%    \begin{MacroCode}
\cs_new:Npn \CDR_process_recordNO: {
  \tl_put_right:Nx \l_CDR_recorded_tl { \the\verbatim@line \iow_newline: }
  \group_begin:
  \tl_set:Nx \l_tmpa_tl { \the\verbatim@line }
  \lua_now:e {CDR.records.append([===[\l_tmpa_tl]===])}
  \group_end:
}
%    \end{MacroCode}
% \begin{environment}{CDR}
% \begin{syntax}
% \cs{begin}\Arg{CDR} ... \cs{end}\Arg{CDR}
% \end{syntax}
% Private environment.
% \end{environment}
%    \begin{MacroCode}
\newenvironment{CDR}{
  \def \verbatim@processline {
    \group_begin:
    \CDR_process_line_code_append:
    \group_end:
  }
%  \CDR_if_show_code:T {
%    \CDR_if_use_minted:TF {
%      \Needspace* { 2\baselineskip }
%    } {
%      \frenchspacing\@vobeyspaces
%    }
%  }
} {
  \CDR:nNTF { lang } \l_tmpa_tl {
    \tl_if_empty:NT \l_tmpa_tl {
      \clist_map_inline:Nn \l_CDR_clist {
        \CDR:nnNT { ##1 } { lang } \l_tmpa_tl {
          \tl_if_empty:NF \l_tmpa_tl {
            \clist_map_break:
          }
        }
      }
      \tl_if_empty:NT \l_tmpa_tl {
        \tl_set:Nn \l_tmpa_tl { tex }
      }
    }
  } {
    \tl_set:Nn \l_tmpa_tl { tex }
  }
% NO WAY
  \clist_map_inline:Nn \l_CDR_clist {
    \CDR_gput:nnV { ##1 } { lang } \l_tmpa_tl
  }
}
%    \end{MacroCode}
% \begin{environment}{CDR.M}
% \begin{syntax}
% \cs{begin}\Arg{CDR.M} ... \cs{end}\Arg{CDR.N}
% \end{syntax}
% Private environment when \texttt{minted}.
% \end{environment}
%    \begin{MacroCode}
\newenvironment{CDR_M}{
  \setkeys { FV } { firstnumber=last, }
  \clist_if_empty:NTF \l_CDR_clist {
    \exp_args:Nnx \setkeys { FV } {
      firstnumber=\CDR_int_use:n { },
  } } {
    \clist_map_inline:Nn \l_CDR_clist {
      \exp_args:Nnx \setkeys { FV } {
        firstnumber=\CDR_int_use:n { ##1 },
      }
      \clist_map_break:
  } }
  \iow_open:Nn \minted@code { \jobname.pyg }
  \tl_set:Nn \l_CDR_line_tl {
    \tl_set:Nx \l_tmpa_tl { \the\verbatim@line }
    \exp_args:NNV \iow_now:Nn \minted@code \l_tmpa_tl
  }
} {
  \CDR_if_show_code:T {
    \CDR_if_use_minted:TF {
      \iow_close:N \minted@code
      \vspace* { \dimexpr -\topsep-\parskip }
      \tl_if_empty:NF \l_CDR_info_tl {
        \tl_use:N \l_CDR_info_tl
        \vspace* { \dimexpr -\topsep-\parskip-\baselineskip }        
        \par\noindent
      }
      \exp_args:NV \minted@pygmentize \l_tmpa_tl
      \DeleteFile { \jobname.pyg }
      \vspace* { \dimexpr -\topsep -\partopsep }
    } {
      \@esphack
    }
  }
}
%    \end{MacroCode}
% \begin{environment}{CDR.P}
% \begin{syntax}
% \cs{begin}\Arg{CDR.P} ... \cs{end}\Arg{CDR.P}
% \end{syntax}
% Private pseudo environment.
% This is just a practical way of declaring balanced actions.
% \end{environment}
%    \begin{MacroCode}
\newenvironment{CDR_P}{
  \if_mode_vertical:
    \noindent
  \else
    \vspace*{ \topsep }
    \par\noindent
  \fi
  \CDR_gset_chunks:
  \tl_if_empty:NTF \g_CDR_chunks_tl {
    \CDR_if:nTF {show_lineno} {
      \CDR_if_use_margin:TF {
%    \end{MacroCode}
% No chunk name, line numbers in the margin
%    \begin{MacroCode}
        \tl_set:Nn \l_CDR_info_tl {
          \hbox_overlap_left:n {
            \CDR:n { format/code }
            {
              \CDR:n { format/name }
              \CDR:n { format/lineno }
              \clist_if_empty:NTF \l_CDR_clist {
                \CDR_int_use:n { }
              } {
                \clist_map_inline:Nn \l_CDR_clist {
                  \CDR_int_use:n { ##1 }
                  \clist_map_break:
                }
              }
            }
            \hspace*{1ex}
          }
        }
      } {
%    \end{MacroCode}
% No chunk name, line numbers not in the margin
%    \begin{MacroCode}
        \tl_set:Nn \l_CDR_info_tl {
          {
            \CDR:n { format/code }
            {
              \CDR:n { format/name }
              \CDR:n { format/lineno }
              \hspace*{3ex}
              \hbox_overlap_left:n {
                \clist_if_empty:NTF \l_CDR_clist {
                  \CDR_int_use:n { }
                } {
                  \clist_map_inline:Nn \l_CDR_clist {
                    \CDR_int_use:n { ##1 }
                    \clist_map_break:
                  }
                }
              }
              \hspace*{1ex}
            }
          }
        }        
      }
    } {
%    \end{MacroCode}
% No chunk name, no line numbers
%    \begin{MacroCode}
      \tl_clear:N \l_CDR_info_tl
    }    
  } {
    \CDR_if:nTF {show_lineno} {
%    \end{MacroCode}
% Chunk names, line numbers, in the margin
%    \begin{MacroCode}
      \tl_set:Nn \l_CDR_info_tl {
        \hbox_overlap_left:n {
          \CDR:n { format/code }
          {
            \CDR:n { format/name }
            \g_CDR_chunks_tl :
            \hspace*{1ex}
            \CDR:n { format/lineno }
            \clist_map_inline:Nn \l_CDR_clist {
              \CDR_int_use:n { ####1 }
              \clist_map_break:
            }
          }
          \hspace*{1ex}
        }
        \tl_set:Nn \l_CDR_info_tl {
          \hbox_overlap_left:n {
            \CDR:n { format/code }
            {
              \CDR:n { format/name }
              \CDR:n { format/lineno }
              \clist_map_inline:Nn \l_CDR_clist {
                \CDR_int_use:n { ####1 }
                \clist_map_break:
              }
            }
            \hspace*{1ex}
          }
        }
      }
    } {
%    \end{MacroCode}
% Chunk names, no line numbers, in the margin
%    \begin{MacroCode}
      \tl_set:Nn \l_CDR_info_tl {
        \hbox_overlap_left:n {
          \CDR:n { format/code }
          {
            \CDR:n { format/name }
            \g_CDR_chunks_tl :
          }
          \hspace*{1ex}
        }
        \tl_clear:N \l_CDR_info_tl
      }
    }
  }
  \CDR_if_use_minted:F {
    \tl_set:Nn \l_CDR_line_tl {
      \noindent
      \hbox_to_wd:nn { \textwidth } {
        \tl_use:N \l_CDR_info_tl
        \CDR:n { format/code }
        \the\verbatim@line        
        \hfill
      }
      \par
    }
    \@bsphack
  }
} {
  \vspace*{ \topsep }
  \par
  \@esphack
}
%    \end{MacroCode}
%
% \section{Management}
% \begin{variable}{\g_CDR_in_impl_bool}
% Whether we are currently in the implementation section.
%    \begin{MacroCode}
\bool_new:N \g_CDR_in_impl_bool
%    \end{MacroCode}
% \end{variable}
% \begin{function}[TF]
%   {\CDR_if_show_code:}
%   \begin{syntax}
%     \cs{CDR_if_show_code:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when code should be printed, \meta{false code} otherwise.
%    \begin{MacroCode}
\prg_new_conditional:Nnn \CDR_if_show_code: { T, F, TF } {
  \bool_if:nTF {
    \g_CDR_in_impl_bool && !\g_CDR_with_impl_bool
  } {
    \prg_return_false:
  } {
    \prg_return_true:
  }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{variable}{\g_CDR_with_impl_bool}
%    \begin{MacroCode}
\bool_new:N \g_CDR_with_impl_bool
%    \end{MacroCode}
% \end{variable}
%
% \section{\texttt{minted} and \texttt{pygments}}
% \begin{variable}{\g_CDR_minted_on_bool}
% Whether minted is available, initially set to \texttt{false}.
%    \begin{MacroCode}
\bool_new:N \g_CDR_minted_on_bool
%    \end{MacroCode}
% \end{variable}
% \begin{variable}{\g_CDR_use_minted_bool}
% Whether minted is used, initially set to \texttt{false}.
%    \begin{MacroCode}
\bool_new:N \g_CDR_use_minted_bool
%    \end{MacroCode}
% \end{variable}
%
% \begin{function}[TF]
%   {\CDR_if_use_minted:}
%   \begin{syntax}
%     \cs{CDR_if_use_minted:TF} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when using |minted|, \meta{false code} otherwise.
%    \begin{MacroCode}
\prg_new_conditional:Nnn \CDR_if_use_minted: { T, F, TF } {
  \bool_if:NTF \g_CDR_use_minted_bool
    { \prg_return_true:  }
    { \prg_return_false: }
}
%    \end{MacroCode}
% \end{function}
%
% \begin{function}{\_CDR_minted_on:}
% \begin{syntax}
% \cs{_CDR_minted_on:}
% \end{syntax}
% Private function. During the preamble, loads \pkg{minted},
% sets \cs{g_CDR_minted_on_bool} to \texttt{true} and prepares \texttt{pygments} processing.
% \end{function}
%    \begin{MacroCode}
\cs_set:Npn \_CDR_minted_on: {
  \bool_gset_true:N \g_CDR_minted_on_bool
  \RequirePackage{minted}
  \setkeys{ minted@opt@g } { linenos=false }
  \minted@def@opt{post~processor}
  \minted@def@opt{post~processor~args}
  \pretocmd\minted@inputpyg{
    \CDR@postprocesspyg {\minted@outputdir\minted@infile}
  }{}{\fail}  
%    \end{MacroCode}
% In the execution context of \cs{minted@inputpyg},
% \begin{description}
% \item[\texttt{\#1}] is the name of the python script, e.g., ``\texttt{process.py}''
% \item[\texttt{\#2}] is the input ``.pygtex'' file ``\cs{minted@outputdir}\cs{minted@infile}''
% \item[\texttt{\#3}] are more args passed to the python script, possibly empty
% \end{description}
%    \begin{MacroCode}
  \newcommand{\CDR@postprocesspyg}[1]{%
    \group_begin:
    \tl_set:Nx \l_tmpa_tl {\CDR:n { post_processor } }
    \tl_if_empty:NF \l_tmpa_tl {
%    \end{MacroCode}
% Execute \texttt{`python3 <script.py> <file.pygtex> <more_args>`}
%    \begin{MacroCode}
      \tl_set:Nx \l_tmpb_tl {\CDR:n { post_processor_args } }
      \exp_args:Nx
      \sys_shell_now:n {
        python3\space
        \l_tmpa_tl\space
        ##1\space
        \l_tmpb_tl
      }  
    }
    \group_end:
  }
}
%    \end{MacroCode}
%    \begin{MacroCode}
%\AddToHook { begindocument / end } {
%  \cs_set_eq:NN \_CDR_minted_on: \prg_do_nothing:
%}
%    \end{MacroCode}
% Utilities to setup \pkg{pygments} post processing.
% The \pkg{pygments} post processor marks some code with \cs{CDREmph}.
%    \begin{MacroCode}
\ProvideDocumentCommand{\CDREmph}{m}{\textcolor{red}{#1}}
%    \end{MacroCode}
%
% \begin{function}{\CDRPreamble}
% \begin{syntax}
% \cs{CDRPreamble} \Arg{variable} \Arg{file name}
% \end{syntax}
% Store the content of \meta{file name} into the variable \meta{variable}.
% \end{function}
%    \begin{MacroCode}
\DeclareDocumentCommand \CDRPreamble { m m } {
  \msg_info:nnn
    { coder }
    { :n }
    { Reading~preamble~from~file~"#2". }
  \group_begin:
  \tl_set:Nn \l_tmpa_tl { #2 }
  \exp_args:NNNx
  \group_end:  
  \tl_set:Nx #1 { \lua_now:n {CDR.print_file_content('l_tmpa_tl')} }
}
%    \end{MacroCode}
%
% \section{Section separators}
% \begin{function}{\CDRImplementation,\CDRFinale}
% \begin{syntax}
% \cs{CDRImplementation}
% \cs{CDRFinale}
% \end{syntax}
% \cs{CDRImplementation} start an implementation part
% where all the sectioning commands do nothing,
% whereas \cs{CDRFinale} stop an implementation part.
% \end{function}
% \section{Finale}
%    \begin{MacroCode}
\newcounter{CDR@impl@page}
\DeclareDocumentCommand \CDRImplementation {} {
  \bool_if:NF \g_CDR_with_impl_bool {
    \clearpage
    \bool_gset_true:N \g_CDR_in_impl_bool
    \let\CDR@old@part\part
    \DeclareDocumentCommand\part{som}{}
    \let\CDR@old@section\section
    \DeclareDocumentCommand\section{som}{}
    \let\CDR@old@subsection\subsection
    \DeclareDocumentCommand\subsection{som}{}
    \let\CDR@old@subsubsection\subsubsection
    \DeclareDocumentCommand\subsubsection{som}{}
    \let\CDR@old@paragraph\paragraph
    \DeclareDocumentCommand\paragraph{som}{}
    \let\CDR@old@subparagraph\subparagraph
    \DeclareDocumentCommand\subparagraph{som}{}
    \cs_if_exist:NT \refsection{ \refsection }
    \setcounter{ CDR@impl@page }{ \value{page} }
  }
}
\DeclareDocumentCommand\CDRFinale {} {
  \bool_if:NF \g_CDR_with_impl_bool {
    \clearpage
    \bool_gset_false:N \g_CDR_in_impl_bool
    \let\part\CDR@old@part
    \let\section\CDR@old@section
    \let\subsection\CDR@old@subsection
    \let\subsubsection\CDR@old@subsubsection
    \let\paragraph\CDR@old@paragraph
    \let\subparagraph\CDR@old@subparagraph
    \setcounter { page } { \value{ CDR@impl@page } }
  }
}
\cs_set_eq:NN \CDR_line_number: \prg_do_nothing:
%    \end{MacroCode}
% \section{Finale}
%    \begin{MacroCode}
\AddToHook { cmd/FancyVerbFormatLine/before } {
  \CDR_line_number:
}
\AddToHook { shipout/before } {
  \tl_gclear:N \g_CDR_chunks_tl
}
%    \end{MacroCode}
%    \begin{MacroCode}
% =========================================================
% Auxiliary:
%   finding the widest string in a comma
%   separated list of strings delimited by parenthesis
% =========================================================

% arguments:
% #1) text: a comma separeted list of strings
% #2) formatter: a macro to format each string
% #3) dimension: will hold the result

\cs_new:Npn \CDRWidest (#1) #2 #3 {
  \group_begin:
  \dim_set:Nn #3 { 0pt }
  \clist_map_inline:nn { #1 } {
    \hbox_set:Nn \l_tmpa_box { #2{##1} }
    \dim_set:Nn \l_tmpa_dim { \dim_eval:n { \box_wd:N \l_tmpa_box } }
    \dim_compare:nNnT { #3 } < { \l_tmpa_dim } {
      \dim_set_eq:NN #3 \l_tm pa_dim
    }
  }
  \exp_args:NNNV
  \group_end:
  \dim_set:Nn #3 #3
}
\ExplSyntaxOff

%    \end{MacroCode}  
% \section{\pkg{pygmentex} implementation}
%    \begin{MacroCode} 
% =========================================================
% fancyvrb new commands to append to a file
% =========================================================

% See http://tex.stackexchange.com/questions/47462/inputenc-error-with-unicode-chars-and-verbatim

\ExplSyntaxOn

\seq_new:N \l_CDR_records_seq

\long\def\unexpanded@write#1#2{\write#1{\unexpanded{#2}}}

\def\CDRAppend{\FV@Environment{}{CDRAppend}}

\def\FVB@CDRAppend#1{%
  \@bsphack
  \begingroup
    \seq_clear:N \l_CDR_records_seq
    \FV@UseKeyValues
    \FV@DefineWhiteSpace
    \def\FV@Space{\space}%
    \FV@DefineTabOut
    \def\FV@ProcessLine{%##1
      \seq_put_right:Nn \l_CDR_records_seq { ##1 }%
      \immediate\unexpanded@write#1%{##1}
    }%
    \let\FV@FontScanPrep\relax
    \let\@noligs\relax
    \FV@Scan
}
\def\FVE@CDRAppend{
  \seq_use:Nn \l_CDR_records_seq /
  \endgroup
  \@esphack
}
\DefineVerbatimEnvironment{CDRAppend}{CDRAppend}{}

\DeclareDocumentEnvironment { Inline } { m } {
  \clist_clear:N \l_CDR_clist
  \keys_set:nn { CDR_code } { #1 }
  \clist_map_inline:Nn \l_CDR_clist {
    \CDR_int_if_exist:nF { ##1 } {
      \CDR_int_new:nn { ##1 } { 1 }
      \seq_new:c { g/CDR/chunks/##1 }
    }
  }
  \CDR_if:nT {reset} {
    \CDR_clist_map_inline:Nnn \l_CDR_clist {
      \CDR_int_gset:nn { } 1
    } {
      \CDR_int_gset:nn { ##1 } 1
    }
  }
  \tl_clear:N \l_CDR_code_name_tl
  \clist_map_inline:Nn \l_CDR_clist {
    \prop_concat:ccc
      {g/CDR/Code/}
      {g/CDR/Code/##1/}
      {g/CDR/Code/}
    \tl_set:Nn \l_CDR_code_name_tl { ##1 }
    \clist_map_break:
  }
  \int_gset:Nn \g_CDR_int
    { \CDR_int_use:n { \l_CDR_code_name_tl } }
  \tl_clear:N \l_CDR_info_tl
  \tl_clear:N \l_CDR_name_tl
  \tl_clear:N \l_CDR_recorded_tl
  \tl_clear:N \l_CDR_chunks_tl
  \cs_set:Npn \verbatim@processline {
    \CDR_process_record:
  }
  \CDR_if_show_code:TF {
    \exp_args:NNx
    \skip_set:Nn \parskip { \CDR:n { parskip } }
    \clist_if_empty:NTF \l_CDR_clist {
      \tl_gclear:N \g_CDR_chunks_tl
    } {
      \clist_set_eq:NN \l_tmpa_clist \l_CDR_clist
      \clist_sort:Nn \l_tmpa_clist {
        \str_compare:nNnTF { ##1 } > { ##2 } {
          \sort_return_swapped:
        } {
          \sort_return_same:
        }
      }
      \tl_set:Nx \l_tmpa_tl { \clist_use:Nn \l_tmpa_clist , }
      \CDR_if:nT {show_name} {
        \CDR_if:nT {use_margin} {
          \CDR_if:nT {only_top} {
            \tl_if_eq:NNT \l_tmpa_tl \g_CDR_chunks_tl {
              \tl_gset_eq:NN \g_CDR_chunks_tl \l_tmpa_tl
              \tl_clear:N \l_tmpa_tl
            }
          }
          \tl_if_empty:NF \l_tmpa_tl {
            \tl_set:Nx \l_CDR_chunks_tl {
              \clist_use:Nn \l_CDR_clist ,
            }
            \tl_set:Nn \l_CDR_name_tl {
              {
                \CDR:n { format/name }
                \l_CDR_chunks_tl :
                \hspace*{1ex}
              }
            }
          }
        }
        \tl_if_empty:NF \l_tmpa_tl {
          \tl_gset_eq:NN \g_CDR_chunks_tl \l_tmpa_tl          
        }
      }
    }
    \if_mode_vertical:
    \else:
    \par
    \fi:
    \vspace{ \CDR:n { sep } }
    \noindent
    \frenchspacing
    \@vobeyspaces
    \normalfont\ttfamily
    \CDR:n { format/code }
    \hyphenchar\font\m@ne
    \@noligs
    \CDR_if_record:F {
      \cs_set_eq:NN \CDR_process_record: \prg_do_nothing:
    }
    \CDR_if_use_minted:F {
      \CDR_if:nT {show_lineno} {
        \CDR_if:nTF {use_margin} {
          \tl_set:Nn \l_CDR_info_tl {
            \hbox_overlap_left:n {
              {
                \l_CDR_name_tl
                \CDR:n { format/name }
                \CDR:n { format/lineno }
                \int_use:N \g_CDR_int
                \int_gincr:N \g_CDR_int
              }
              \hspace*{1ex}
            }
          }
        } {
          \tl_set:Nn \l_CDR_info_tl {
            {
              \CDR:n { format/name }
              \CDR:n { format/lineno }
              \hspace*{3ex}
              \hbox_overlap_left:n {
                \int_use:N \g_CDR_int
                \int_gincr:N \g_CDR_int
              }
            }
            \hspace*{1ex}
          }
        }
      }
      \cs_set:Npn \verbatim@processline {
        \CDR_process_record:
        \hspace*{\dimexpr \linewidth-\columnwidth}%
        \hbox_to_wd:nn { \columnwidth } {
          \l_CDR_info_tl
          \the\verbatim@line
          \color{lightgray}\dotfill
        }
        \tl_clear:N \l_CDR_name_tl
        \par\noindent
      }
    }
  } {
    \@bsphack
  }
  \group_begin:
  \g_CDR_hook_tl
  \let \do \@makeother
  \dospecials \catcode `\^^M \active
  \verbatim@start
} {
  \int_gsub:Nn \g_CDR_int {
    \CDR_int_use:n { \l_CDR_code_name_tl }
  }
  \int_compare:nNnT { \g_CDR_int } > { 0 } {
    \CDR_clist_map_inline:Nnn \l_CDR_clist {
      \CDR_int_gadd:nn { } { \g_CDR_int }
    } {
      \CDR_int_gadd:nn { ##1 } { \g_CDR_int }
    }
    \int_gincr:N \g_CDR_code_int
    \tl_set:Nx \l_tmpb_tl { \int_use:N \g_CDR_code_int }
    \clist_map_inline:Nn \l_CDR_clist {
      \seq_gput_right:cV { g/CDR/chunks/##1 } \l_tmpb_tl
    }
    \prop_gput:NVV \g_CDR_code_prop \l_tmpb_tl \l_CDR_recorded_tl
  }
  \group_end:
  \CDR_if_show_code:T {
  }
  \CDR_if_show_code:TF {
    \CDR_if_use_minted:TF {
      \tl_if_empty:NF \l_CDR_recorded_tl {
        \exp_args:Nnx \setkeys { FV } {
          firstnumber=\CDR_int_use:n { \l_CDR_code_name_tl },
        }
        \iow_open:Nn \minted@code { \jobname.pyg }
        \exp_args:NNV \iow_now:Nn \minted@code \l_CDR_recorded_tl
        \iow_close:N \minted@code
        \vspace* { \dimexpr -\topsep-\parskip }
        \tl_if_empty:NF \l_CDR_info_tl {
          \tl_use:N \l_CDR_info_tl
          \skip_vertical:n { \dimexpr -\topsep-\parskip-\baselineskip }        
          \par\noindent
        }
        \exp_args:Nnx \minted@pygmentize { \jobname.pyg } { \CDR:n { lang } }
        %\DeleteFile { \jobname.pyg }
        \skip_vertical:n { -\topsep-\partopsep }        
      }
    } {
      \exp_args:Nx \skip_vertical:n { \CDR:n { sep } }
      \noindent
    }
  } {
    \@esphack
  }  
}
% =========================================================
% Main options
% =========================================================

\newif\ifCDR@left
\newif\ifCDR@right


%    \end{MacroCode}
%
% \subsection{\texttt{options} key-value controls}
% We accept any value because we do not know in advance the real target.
% There are 2 ways to collect options:
% \section{Something else}
%    \begin{MacroCode}

% =========================================================
% pygmented commands and environments
% =========================================================


\newcommand\inputpygmented[2][]{%
  \begingroup
    \CDR@process@options{#1}%
    \immediate\write\CDR@outfile{<@@CDR@input@\the\CDR@counter}%
    \immediate\write\CDR@outfile{\exp_args:NV\detokenize\CDR@global@options,\detokenize{#1}}%
    \immediate\write\CDR@outfile{#2}%
    \immediate\write\CDR@outfile{>@@CDR@input@\the\CDR@counter}%
    %
    \csname CDR@snippet@\the\CDR@counter\endcsname
    \global\advance\CDR@counter by 1\relax
  \endgroup
}

\cs_generate_variant:Nn \exp_last_unbraced:NnNo { NxNo }

\newcommand\CDR@snippet@run[1]{%
  \group_begin:
  \typeout{DEBUG~PY~STYLE:< \CDR:n { style } > }
  \use_c:n { PYstyle }
  \CDR_when:nT { style } {
    \use_c:n { PYstyle \CDR:n { style } }
  }
  \cs_if_exist:cTF {PY} {PYOK} {PYKO}
  \CDR:n {font}
  \CDR@process@more@options{ \CDR:n {engine} }%
  \exp_last_unbraced:NxNo
  \use:c { \CDR:n {engine} } [ \CDRRemainingOptions ]{#1}%
  \group_end:
}

% ERROR: JL undefined \CDR@alllinenos

\ProvideDocumentCommand\captionof{mm}{}
\def\CDR@alllinenos{(0)}

\def\FormatLineNumber#1{{\rmfamily\tiny#1}}

\newdimen\CDR@leftmargin
\newdimen\CDR@linenosep

\def\CDR@lineno@do#1{%
  \CDR@linenosep 0pt%
  \use:c { CDR@ \CDR:n {block_engine} @margin }
  \exp_args:NNx
  \advance \CDR@linenosep { \CDR:n {linenosep} }
  \hbox_overlap_left:n {%
    \FormatLineNumber{#1}%
    \hspace*{\CDR@linenosep}%
  }%
}

\newcommand\CDR@tcbox@more@options{%
  nobeforeafter,%
  tcbox~raise~base,%
  left=0mm,%
  right=0mm,%
  top=0mm,%
  bottom=0mm,%
  boxsep=2pt,%
  arc=1pt,%
  boxrule=0pt,%
  \CDR_options_if_in:nT {colback} {
    colback=\CDR:n {colback}
  }
}

\newcommand\CDR@mdframed@more@options{%
  leftmargin=\CDR@leftmargin,%
  frametitlerule=true,%
  \CDR_if_in:nT {colback} {
    backgroundcolor=\CDR:n {colback}
  }
}

\newcommand\CDR@tcolorbox@more@options{%
  grow~to~left~by=-\CDR@leftmargin,%
  \CDR_if_in:nNT {colback} {
    colback=\CDR:n {colback}
  }
}

\newcommand\CDR@boite@more@options{%
  leftmargin=\CDR@leftmargin,%
  \ifcsname CDR@opt@colback\endcsname
    colback=\CDR@opt@colback,%
  \fi
}

\newcommand\CDR@mdframed@margin{%
  \advance \CDR@linenosep \mdflength{outerlinewidth}%
  \advance \CDR@linenosep \mdflength{middlelinewidth}%
  \advance \CDR@linenosep \mdflength{innerlinewidth}%
  \advance \CDR@linenosep \mdflength{innerleftmargin}%
}

\newcommand\CDR@tcolorbox@margin{%
  \advance \CDR@linenosep \kvtcb@left@rule
  \advance \CDR@linenosep \kvtcb@leftupper
  \advance \CDR@linenosep \kvtcb@boxsep
}

\newcommand\CDR@boite@margin{%
  \advance \CDR@linenosep \boite@leftrule
  \advance \CDR@linenosep \boite@boxsep
}

\def\CDR@global@options{}

\newcommand\setpygmented[1]{%
  \def\CDR@global@options{/CDR.cd,#1}%
}

%    \end{MacroCode}
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
% \section{Counters}
% \begin{function}{\CDR_int_new:nn}
% \begin{syntax}
% \cs{CDR_int_new:n} \Arg{name} \Arg{value}
% \end{syntax}
% Create an integer after \meta{name} and
% set it globally to \meta{value}.
% \meta{name} is a code name.
%    \begin{MacroCode}
\cs_new:Npn \CDR_int_new:nn #1 #2 {
  \int_new:c {g/CDR/int/#1}
  \int_gset:cn {g/CDR/int/#1} { #2 }
}
%    \end{MacroCode}
% \end{function}
% \begin{function}{\CDR_int_set:nn,\CDR_int_gset:nn}
% \begin{syntax}
% \cs{CDR_int_set:n} \Arg{name} \Arg{value}
% \end{syntax}
% Set the integer named after \meta{name} to the \meta{value}. \cs{CDR_int_gset:n} makes a global change.
% \meta{name} is a code name.
%    \begin{MacroCode}
\cs_new:Npn \CDR_int_set:nn #1 #2 {
  \int_set:cn {g/CDR/int/#1} { #2 }
}
\cs_new:Npn \CDR_int_gset:nn #1 #2 {
  \int_gset:cn {g/CDR/int/#1} { #2 }
}
%    \end{MacroCode}
% \end{function}
% \begin{function}{\CDR_int_add:nn,\CDR_int_gadd:nn}
% \begin{syntax}
% \cs{CDR_int_add:n} \Arg{name} \Arg{value}
% \end{syntax}
% Add the \meta{value} to the integer named after \meta{name}. \cs{CDR_int_gadd:n} makes a global change.
% \meta{name} is a code name.
%    \begin{MacroCode}
\cs_new:Npn \CDR_int_add:nn #1 #2 {
  \int_add:cn {g/CDR/int/#1} { #2 }
}
\cs_new:Npn \CDR_int_gadd:nn #1 #2 {
  \int_gadd:cn {g/CDR/int/#1} { #2 }
}
%    \end{MacroCode}
% \end{function}
% \begin{function}{\CDR_int_sub:nn,\CDR_int_gsub:nn}
% \begin{syntax}
% \cs{CDR_int_sub:n} \Arg{name} \Arg{value}
% \end{syntax}
% Substract the \meta{value} from the integer named after \meta{name}. \cs{CDR_int_gsub:n} makes a global change.
% \meta{name} is a code name.
%    \begin{MacroCode}
\cs_new:Npn \CDR_int_sub:nn #1 #2 {
  \int_sub:cn {g/CDR/int/#1} { #2 }
}
\cs_new:Npn \CDR_int_gsub:nn #1 #2 {
  \int_gsub:cn {g/CDR/int/#1} { #2 }
}
%    \end{MacroCode}
% \end{function}
% \begin{function}[TF]
%   {\CDR_int_if_exist:n}
%   \begin{syntax}
%     \cs{CDR_int_if_exist:nTF} \Arg{name} \Arg{true code} \Arg{false code}
%   \end{syntax}
%   Execute \meta{true code} when
% an integer named after \meta{name} exist,
% \meta{false code} otherwise.
%    \begin{MacroCode}
\prg_new_conditional:Nnn \CDR_int_if_exist:n { T, F, TF } {
  \int_if_exist:cTF {g/CDR/int/#1} {
    \prg_return_true:
  } {
    \prg_return_false:
  }
}
%    \end{MacroCode}
% \end{function}
% \begin{variable}{\g/CDR/int/}
% \begin{variable}{\g/CDR/int/<name>}
% Generic and named line number counter.
% \cs{l_CDR_code_name_t} is used as \meta{name}.
%    \begin{MacroCode}
\CDR_int_new:nn {} { 1 }
%    \end{MacroCode}
% \end{variable}
% \end{variable}
% \begin{function}[EXP]{\CDR_int_use:n}
% \begin{syntax}
% \cs{CDR_int_use:n} \Arg{name}
% \end{syntax}
% \meta{name} is a code name.
%    \begin{MacroCode}
\cs_new:Npn \CDR_int_use:n #1 {
  \int_use:c {g/CDR/int/#1}
}
%    \end{MacroCode}
% \end{function}
%
%
%    \begin{MacroCode}
\ExplSyntaxOff
%    \end{MacroCode}
%    \begin{MacroCode}
%</sty>
%    \end{MacroCode}
% \end{implementation}
%\Finale
%
% % ^^A \PrintIndex
